import { Component, EventEmitter, Output, ViewChild } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
export class NgxImageCaptureComponent {
    constructor() {
        this.imageCaptured = new EventEmitter();
        this.errorCapture = new EventEmitter();
        this.videoElement = null;
        this.videoStream = ViewChild('video');
        this.streamOpened = false;
    }
    startVideoCapture() {
        this.streamOpened = true;
        const constraints = {
            audio: false,
            video: {
                width: { ideal: 1920 },
                height: { ideal: 1080 },
                facingMode: { ideal: 'user' },
            },
        };
        navigator.mediaDevices
            .getUserMedia(constraints)
            .then(stream => {
            this.videoStream = stream;
            setTimeout(() => {
                if (this.videoElement?.nativeElement) {
                    this.videoElement.nativeElement.srcObject = stream;
                }
            }, 100);
        })
            .catch(error => {
            this.errorCapture.emit(`Ngx Image Compress: Could not access the camera. ${error}`);
            this.streamOpened = true;
        });
    }
    acquireImage() {
        const canvas = document.createElement('canvas');
        const video = this.videoElement?.nativeElement;
        if (!video) {
            this.errorCapture.emit('Ngx Image Compress - Error in acquisition of video element.');
            this.streamOpened = false;
            return;
        }
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        canvas.getContext('2d')?.drawImage(video, 0, 0);
        const newImage = canvas.toDataURL('jpg', 95);
        if (this.videoStream) {
            this.videoStream.getVideoTracks().forEach(track => track.stop());
        }
        this.imageCaptured.emit(newImage);
        this.streamOpened = false;
    }
}
NgxImageCaptureComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.2", ngImport: i0, type: NgxImageCaptureComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
NgxImageCaptureComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.1.2", type: NgxImageCaptureComponent, selector: "ngx-image-capture", outputs: { imageCaptured: "imageCaptured", errorCapture: "errorCapture" }, viewQueries: [{ propertyName: "videoElement", first: true, predicate: ["video"], descendants: true }], ngImport: i0, template: `
        <span (click)="startVideoCapture()" *ngIf="!streamOpened">
            <ng-content select="[openStreamBtn]"></ng-content>
        </span>
        <span (click)="acquireImage()" *ngIf="streamOpened">
            <ng-content select="[acquireImageBtn]"></ng-content>
        </span>
        <video #video autoplay *ngIf="streamOpened"></video>
    `, isInline: true, dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.2", ngImport: i0, type: NgxImageCaptureComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngx-image-capture', template: `
        <span (click)="startVideoCapture()" *ngIf="!streamOpened">
            <ng-content select="[openStreamBtn]"></ng-content>
        </span>
        <span (click)="acquireImage()" *ngIf="streamOpened">
            <ng-content select="[acquireImageBtn]"></ng-content>
        </span>
        <video #video autoplay *ngIf="streamOpened"></video>
    ` }]
        }], propDecorators: { imageCaptured: [{
                type: Output
            }], errorCapture: [{
                type: Output
            }], videoElement: [{
                type: ViewChild,
                args: ['video']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWltYWdlLWNhcHR1cmUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LWltYWdlLWNvbXByZXNzL3NyYy9saWIvbmd4LWltYWdlLWNhcHR1cmUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQWMsWUFBWSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUMsTUFBTSxlQUFlLENBQUM7OztBQWdCckYsTUFBTSxPQUFPLHdCQUF3QjtJQWJyQztRQWNjLGtCQUFhLEdBQUcsSUFBSSxZQUFZLEVBQVcsQ0FBQztRQUM1QyxpQkFBWSxHQUFHLElBQUksWUFBWSxFQUFVLENBQUM7UUFHcEQsaUJBQVksR0FBd0MsSUFBSSxDQUFDO1FBQ3pELGdCQUFXLEdBQXVCLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNyRCxpQkFBWSxHQUFHLEtBQUssQ0FBQztLQWdEeEI7SUE5Q0csaUJBQWlCO1FBQ2IsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7UUFFekIsTUFBTSxXQUFXLEdBQUc7WUFDaEIsS0FBSyxFQUFFLEtBQUs7WUFDWixLQUFLLEVBQUU7Z0JBQ0gsS0FBSyxFQUFFLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBQztnQkFDcEIsTUFBTSxFQUFFLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBQztnQkFDckIsVUFBVSxFQUFFLEVBQUMsS0FBSyxFQUFFLE1BQU0sRUFBQzthQUM5QjtTQUNKLENBQUM7UUFFRixTQUFTLENBQUMsWUFBWTthQUNqQixZQUFZLENBQUMsV0FBVyxDQUFDO2FBQ3pCLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNYLElBQUksQ0FBQyxXQUFXLEdBQUcsTUFBTSxDQUFDO1lBQzFCLFVBQVUsQ0FBQyxHQUFHLEVBQUU7Z0JBQ1osSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFLGFBQWEsRUFBRTtvQkFDbEMsSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQztpQkFDdEQ7WUFDTCxDQUFDLEVBQUMsR0FBRyxDQUFDLENBQUM7UUFDWCxDQUFDLENBQUM7YUFDRCxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDWCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxvREFBb0QsS0FBSyxFQUFFLENBQUMsQ0FBQztZQUNwRixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztRQUM3QixDQUFDLENBQUMsQ0FBQztJQUNYLENBQUM7SUFFRCxZQUFZO1FBQ1IsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNoRCxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLGFBQWEsQ0FBQztRQUMvQyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1IsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsNkRBQTZELENBQUMsQ0FBQztZQUN0RixJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQztZQUMxQixPQUFPO1NBQ1Y7UUFDRCxNQUFNLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUM7UUFDaEMsTUFBTSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDO1FBQ2xDLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDaEQsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDN0MsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2xCLElBQUksQ0FBQyxXQUFXLENBQUMsY0FBYyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7U0FDcEU7UUFDRCxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNsQyxJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQztJQUM5QixDQUFDOztxSEF0RFEsd0JBQXdCO3lHQUF4Qix3QkFBd0IsMk9BWHZCOzs7Ozs7OztLQVFUOzJGQUdRLHdCQUF3QjtrQkFicEMsU0FBUzsrQkFDSSxtQkFBbUIsWUFDbkI7Ozs7Ozs7O0tBUVQ7OEJBSVMsYUFBYTtzQkFBdEIsTUFBTTtnQkFDRyxZQUFZO3NCQUFyQixNQUFNO2dCQUdQLFlBQVk7c0JBRFgsU0FBUzt1QkFBQyxPQUFPIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgT3V0cHV0LCBWaWV3Q2hpbGR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEYXRhVXJsfSBmcm9tICcuL21vZGVscy9kYXRhLXVybCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnbmd4LWltYWdlLWNhcHR1cmUnLFxuICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxzcGFuIChjbGljayk9XCJzdGFydFZpZGVvQ2FwdHVyZSgpXCIgKm5nSWY9XCIhc3RyZWFtT3BlbmVkXCI+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJbb3BlblN0cmVhbUJ0bl1cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPHNwYW4gKGNsaWNrKT1cImFjcXVpcmVJbWFnZSgpXCIgKm5nSWY9XCJzdHJlYW1PcGVuZWRcIj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIlthY3F1aXJlSW1hZ2VCdG5dXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIDx2aWRlbyAjdmlkZW8gYXV0b3BsYXkgKm5nSWY9XCJzdHJlYW1PcGVuZWRcIj48L3ZpZGVvPlxuICAgIGAsXG4gICAgc3R5bGVzOiBbXSxcbn0pXG5leHBvcnQgY2xhc3MgTmd4SW1hZ2VDYXB0dXJlQ29tcG9uZW50IHtcbiAgICBAT3V0cHV0KCkgaW1hZ2VDYXB0dXJlZCA9IG5ldyBFdmVudEVtaXR0ZXI8RGF0YVVybD4oKTtcbiAgICBAT3V0cHV0KCkgZXJyb3JDYXB0dXJlID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XG5cbiAgICBAVmlld0NoaWxkKCd2aWRlbycpXG4gICAgdmlkZW9FbGVtZW50OiBFbGVtZW50UmVmPEhUTUxWaWRlb0VsZW1lbnQ+IHwgbnVsbCA9IG51bGw7XG4gICAgdmlkZW9TdHJlYW06IE1lZGlhU3RyZWFtIHwgbnVsbCA9IFZpZXdDaGlsZCgndmlkZW8nKTtcbiAgICBzdHJlYW1PcGVuZWQgPSBmYWxzZTtcblxuICAgIHN0YXJ0VmlkZW9DYXB0dXJlKCkge1xuICAgICAgICB0aGlzLnN0cmVhbU9wZW5lZCA9IHRydWU7XG5cbiAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSB7XG4gICAgICAgICAgICBhdWRpbzogZmFsc2UsXG4gICAgICAgICAgICB2aWRlbzoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiB7aWRlYWw6IDE5MjB9LFxuICAgICAgICAgICAgICAgIGhlaWdodDoge2lkZWFsOiAxMDgwfSxcbiAgICAgICAgICAgICAgICBmYWNpbmdNb2RlOiB7aWRlYWw6ICd1c2VyJ30sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuXG4gICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXNcbiAgICAgICAgICAgIC5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXG4gICAgICAgICAgICAudGhlbihzdHJlYW0gPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9TdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZGVvRWxlbWVudD8ubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQubmF0aXZlRWxlbWVudC5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LDEwMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yQ2FwdHVyZS5lbWl0KGBOZ3ggSW1hZ2UgQ29tcHJlc3M6IENvdWxkIG5vdCBhY2Nlc3MgdGhlIGNhbWVyYS4gJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbU9wZW5lZCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhY3F1aXJlSW1hZ2UoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjb25zdCB2aWRlbyA9IHRoaXMudmlkZW9FbGVtZW50Py5uYXRpdmVFbGVtZW50O1xuICAgICAgICBpZiAoIXZpZGVvKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yQ2FwdHVyZS5lbWl0KCdOZ3ggSW1hZ2UgQ29tcHJlc3MgLSBFcnJvciBpbiBhY3F1aXNpdGlvbiBvZiB2aWRlbyBlbGVtZW50LicpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1PcGVuZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMud2lkdGggPSB2aWRlby52aWRlb1dpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdmlkZW8udmlkZW9IZWlnaHQ7XG4gICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpPy5kcmF3SW1hZ2UodmlkZW8sIDAsIDApO1xuICAgICAgICBjb25zdCBuZXdJbWFnZSA9IGNhbnZhcy50b0RhdGFVUkwoJ2pwZycsIDk1KTtcbiAgICAgICAgaWYgKHRoaXMudmlkZW9TdHJlYW0pIHtcbiAgICAgICAgICAgIHRoaXMudmlkZW9TdHJlYW0uZ2V0VmlkZW9UcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbWFnZUNhcHR1cmVkLmVtaXQobmV3SW1hZ2UpO1xuICAgICAgICB0aGlzLnN0cmVhbU9wZW5lZCA9IGZhbHNlO1xuICAgIH1cbn1cbiJdfQ==