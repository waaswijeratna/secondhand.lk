import { Injectable } from '@angular/core';
import { ImageCompress } from './image-compress';
import { DOC_ORIENTATION } from './models/DOC_ORIENTATION';
import * as i0 from "@angular/core";
export class NgxImageCompressService {
    constructor(rendererFactory) {
        this.DOC_ORIENTATION = DOC_ORIENTATION;
        this.render = rendererFactory.createRenderer(null, null);
    }
    /**
     * helper to evaluate the compression rate
     * @param imgString the image in base64 string format
     */
    byteCount(image) {
        return ImageCompress.byteCount(image);
    }
    /**
     * Get the correct Orientation value from image tags
     */
    getOrientation(file) {
        return ImageCompress.getOrientation(file);
    }
    /**
     * return a promise with the new image data and image orientation
     * Nothing happen if no file have been selected
     */
    uploadFile() {
        return ImageCompress.uploadFile(this.render, false);
    }
    /**
     * return a promise with an array of image data and image orientation
     * Nothing happen if no files have been selected
     */
    uploadMultipleFiles() {
        return ImageCompress.uploadFile(this.render, true);
    }
    /**
     * return a promise with the new image data and image orientation
     * the promise will reject if no file have been selected
     */
    uploadFileOrReject() {
        return ImageCompress.uploadFile(this.render, false, true);
    }
    /**
     * return a promise with an array of image data and image orientation
     * the promise will reject if no files have been selected
     */
    uploadMultipleFilesOrReject() {
        return ImageCompress.uploadFile(this.render, true, true);
    }
    /**
   * perform a compression from the given DataUrl (string), provided by the uploadFile, or uploadMultipleFiles method
   *
   *
   | Parameter   | Type   | Description                                                                       |
   | ----------- | ------ | --------------------------------------------------------------------------------- |
   | image       | string | DataUrl (string) representing the image                                           |
   | orientation | number | EXIF Orientation value using the DOC_ORIENTATION enum value                       |
   | ratio       | number | Maximum scale factor as a percentage (optional, default: 50) <sup>[1](#fn1)</sup> |
   | quality     | number | JPEG quality factor as a percentage (optional, default: 50) <sup>[2](#fn2)</sup>  |
   | maxwidth    | number | Maximum width in pixels if you need to resize (optional, default: 0 - no resize)  |
   | maxheight   | number | Maximum height in pixels if you need to resize (optional, default: 0 - no resize) |
   */
    compressFile(image, orientation, ratio = 50, quality = 50, maxWidth = 0, maxHeight = 0) {
        return ImageCompress.compress(image, orientation, this.render, ratio, quality, maxWidth, maxHeight);
    }
    /**
     * Most simple function to use here.
     * Perform an upload and return an image dataUrl (string format) with a maximum size, given in *MegaBytes*
     * If the size can't be reached, the best that can be reached will be returned in promise *rejection*
     * Put debugMode to true if you have some trouble to print some help using console.debug
     */
    uploadAndGetImageWithMaxSize(maxSizeMb = 1, debugMode = false, rejectOnCancel = false) {
        return ImageCompress.getImageMaxSize(maxSizeMb, debugMode, this.render, rejectOnCancel)
            .then(uploadResponse => uploadResponse.image)
            .catch(e => {
            throw e.image;
        });
    }
    /**
     * Same as before, but return more informations (file name...)
     */
    uploadAndGetImageWithMaxSizeAndMetas(maxSizeMb = 1, debugMode = false, rejectOnCancel = false) {
        return ImageCompress.getImageMaxSize(maxSizeMb, debugMode, this.render, rejectOnCancel);
    }
}
NgxImageCompressService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.2", ngImport: i0, type: NgxImageCompressService, deps: [{ token: i0.RendererFactory2 }], target: i0.ɵɵFactoryTarget.Injectable });
NgxImageCompressService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.1.2", ngImport: i0, type: NgxImageCompressService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.2", ngImport: i0, type: NgxImageCompressService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i0.RendererFactory2 }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWltYWdlLWNvbXByZXNzLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtaW1hZ2UtY29tcHJlc3Mvc3JjL2xpYi9uZ3gtaW1hZ2UtY29tcHJlc3Muc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsVUFBVSxFQUE4QixNQUFNLGVBQWUsQ0FBQztBQUN0RSxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFDL0MsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLDBCQUEwQixDQUFDOztBQU96RCxNQUFNLE9BQU8sdUJBQXVCO0lBS2hDLFlBQVksZUFBaUM7UUFGdEMsb0JBQWUsR0FBRyxlQUFlLENBQUM7UUFHckMsSUFBSSxDQUFDLE1BQU0sR0FBRyxlQUFlLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksU0FBUyxDQUFDLEtBQWM7UUFDM0IsT0FBTyxhQUFhLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFRDs7T0FFRztJQUNJLGNBQWMsQ0FBQyxJQUFVO1FBQzVCLE9BQU8sYUFBYSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksVUFBVTtRQUNiLE9BQU8sYUFBYSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBNEIsQ0FBQztJQUNuRixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksbUJBQW1CO1FBQ3RCLE9BQU8sYUFBYSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBOEIsQ0FBQztJQUNwRixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksa0JBQWtCO1FBQ3JCLE9BQU8sYUFBYSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQTRCLENBQUM7SUFDekYsQ0FBQztJQUVEOzs7T0FHRztJQUNJLDJCQUEyQjtRQUM5QixPQUFPLGFBQWEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUE4QixDQUFDO0lBQzFGLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7O0tBWUM7SUFDTSxZQUFZLENBQ2YsS0FBYyxFQUNkLFdBQTRCLEVBQzVCLEtBQUssR0FBRyxFQUFFLEVBQ1YsT0FBTyxHQUFHLEVBQUUsRUFDWixRQUFRLEdBQUcsQ0FBQyxFQUNaLFNBQVMsR0FBRyxDQUFDO1FBRWIsT0FBTyxhQUFhLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxXQUFXLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUN4RyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSw0QkFBNEIsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxFQUFFLFNBQVMsR0FBRyxLQUFLLEVBQUUsY0FBYyxHQUFHLEtBQUs7UUFDeEYsT0FBTyxhQUFhLENBQUMsZUFBZSxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUM7YUFDbEYsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQzthQUM1QyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDUCxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUM7UUFDbEIsQ0FBQyxDQUFDLENBQUM7SUFDWCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxvQ0FBb0MsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxFQUFFLFNBQVMsR0FBRyxLQUFLLEVBQUUsY0FBYyxHQUFHLEtBQUs7UUFDaEcsT0FBTyxhQUFhLENBQUMsZUFBZSxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUMsQ0FBQztJQUM1RixDQUFDOztvSEFuR1EsdUJBQXVCO3dIQUF2Qix1QkFBdUIsY0FGcEIsTUFBTTsyRkFFVCx1QkFBdUI7a0JBSG5DLFVBQVU7bUJBQUM7b0JBQ1IsVUFBVSxFQUFFLE1BQU07aUJBQ3JCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtJbmplY3RhYmxlLCBSZW5kZXJlcjIsIFJlbmRlcmVyRmFjdG9yeTJ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtJbWFnZUNvbXByZXNzfSBmcm9tICcuL2ltYWdlLWNvbXByZXNzJztcbmltcG9ydCB7RE9DX09SSUVOVEFUSU9OfSBmcm9tICcuL21vZGVscy9ET0NfT1JJRU5UQVRJT04nO1xuaW1wb3J0IHtVcGxvYWRSZXNwb25zZX0gZnJvbSAnLi9tb2RlbHMvdXBsb2FkLXJlc3BvbnNlJztcbmltcG9ydCB7RGF0YVVybH0gZnJvbSAnLi9tb2RlbHMvZGF0YS11cmwnO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBOZ3hJbWFnZUNvbXByZXNzU2VydmljZSB7XG4gICAgcHJpdmF0ZSByZWFkb25seSByZW5kZXI6IFJlbmRlcmVyMjtcblxuICAgIHB1YmxpYyBET0NfT1JJRU5UQVRJT04gPSBET0NfT1JJRU5UQVRJT047XG5cbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlckZhY3Rvcnk6IFJlbmRlcmVyRmFjdG9yeTIpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIgPSByZW5kZXJlckZhY3RvcnkuY3JlYXRlUmVuZGVyZXIobnVsbCwgbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGVscGVyIHRvIGV2YWx1YXRlIHRoZSBjb21wcmVzc2lvbiByYXRlXG4gICAgICogQHBhcmFtIGltZ1N0cmluZyB0aGUgaW1hZ2UgaW4gYmFzZTY0IHN0cmluZyBmb3JtYXRcbiAgICAgKi9cbiAgICBwdWJsaWMgYnl0ZUNvdW50KGltYWdlOiBEYXRhVXJsKSB7XG4gICAgICAgIHJldHVybiBJbWFnZUNvbXByZXNzLmJ5dGVDb3VudChpbWFnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb3JyZWN0IE9yaWVudGF0aW9uIHZhbHVlIGZyb20gaW1hZ2UgdGFnc1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXRPcmllbnRhdGlvbihmaWxlOiBGaWxlKTogUHJvbWlzZTxET0NfT1JJRU5UQVRJT04+IHtcbiAgICAgICAgcmV0dXJuIEltYWdlQ29tcHJlc3MuZ2V0T3JpZW50YXRpb24oZmlsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgcHJvbWlzZSB3aXRoIHRoZSBuZXcgaW1hZ2UgZGF0YSBhbmQgaW1hZ2Ugb3JpZW50YXRpb25cbiAgICAgKiBOb3RoaW5nIGhhcHBlbiBpZiBubyBmaWxlIGhhdmUgYmVlbiBzZWxlY3RlZFxuICAgICAqL1xuICAgIHB1YmxpYyB1cGxvYWRGaWxlKCk6IFByb21pc2U8VXBsb2FkUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIEltYWdlQ29tcHJlc3MudXBsb2FkRmlsZSh0aGlzLnJlbmRlciwgZmFsc2UpIGFzIFByb21pc2U8VXBsb2FkUmVzcG9uc2U+O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIHByb21pc2Ugd2l0aCBhbiBhcnJheSBvZiBpbWFnZSBkYXRhIGFuZCBpbWFnZSBvcmllbnRhdGlvblxuICAgICAqIE5vdGhpbmcgaGFwcGVuIGlmIG5vIGZpbGVzIGhhdmUgYmVlbiBzZWxlY3RlZFxuICAgICAqL1xuICAgIHB1YmxpYyB1cGxvYWRNdWx0aXBsZUZpbGVzKCk6IFByb21pc2U8VXBsb2FkUmVzcG9uc2VbXT4ge1xuICAgICAgICByZXR1cm4gSW1hZ2VDb21wcmVzcy51cGxvYWRGaWxlKHRoaXMucmVuZGVyLCB0cnVlKSBhcyBQcm9taXNlPFVwbG9hZFJlc3BvbnNlW10+O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIHByb21pc2Ugd2l0aCB0aGUgbmV3IGltYWdlIGRhdGEgYW5kIGltYWdlIG9yaWVudGF0aW9uXG4gICAgICogdGhlIHByb21pc2Ugd2lsbCByZWplY3QgaWYgbm8gZmlsZSBoYXZlIGJlZW4gc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgdXBsb2FkRmlsZU9yUmVqZWN0KCk6IFByb21pc2U8VXBsb2FkUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIEltYWdlQ29tcHJlc3MudXBsb2FkRmlsZSh0aGlzLnJlbmRlciwgZmFsc2UsIHRydWUpIGFzIFByb21pc2U8VXBsb2FkUmVzcG9uc2U+O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybiBhIHByb21pc2Ugd2l0aCBhbiBhcnJheSBvZiBpbWFnZSBkYXRhIGFuZCBpbWFnZSBvcmllbnRhdGlvblxuICAgICAqIHRoZSBwcm9taXNlIHdpbGwgcmVqZWN0IGlmIG5vIGZpbGVzIGhhdmUgYmVlbiBzZWxlY3RlZFxuICAgICAqL1xuICAgIHB1YmxpYyB1cGxvYWRNdWx0aXBsZUZpbGVzT3JSZWplY3QoKTogUHJvbWlzZTxVcGxvYWRSZXNwb25zZVtdPiB7XG4gICAgICAgIHJldHVybiBJbWFnZUNvbXByZXNzLnVwbG9hZEZpbGUodGhpcy5yZW5kZXIsIHRydWUsIHRydWUpIGFzIFByb21pc2U8VXBsb2FkUmVzcG9uc2VbXT47XG4gICAgfVxuXG4gICAgLyoqXG4gICAqIHBlcmZvcm0gYSBjb21wcmVzc2lvbiBmcm9tIHRoZSBnaXZlbiBEYXRhVXJsIChzdHJpbmcpLCBwcm92aWRlZCBieSB0aGUgdXBsb2FkRmlsZSwgb3IgdXBsb2FkTXVsdGlwbGVGaWxlcyBtZXRob2RcbiAgICpcbiAgICpcbiAgIHwgUGFyYW1ldGVyICAgfCBUeXBlICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgfCAtLS0tLS0tLS0tLSB8IC0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XG4gICB8IGltYWdlICAgICAgIHwgc3RyaW5nIHwgRGF0YVVybCAoc3RyaW5nKSByZXByZXNlbnRpbmcgdGhlIGltYWdlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgIHwgb3JpZW50YXRpb24gfCBudW1iZXIgfCBFWElGIE9yaWVudGF0aW9uIHZhbHVlIHVzaW5nIHRoZSBET0NfT1JJRU5UQVRJT04gZW51bSB2YWx1ZSAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgfCByYXRpbyAgICAgICB8IG51bWJlciB8IE1heGltdW0gc2NhbGUgZmFjdG9yIGFzIGEgcGVyY2VudGFnZSAob3B0aW9uYWwsIGRlZmF1bHQ6IDUwKSA8c3VwPlsxXSgjZm4xKTwvc3VwPiB8XG4gICB8IHF1YWxpdHkgICAgIHwgbnVtYmVyIHwgSlBFRyBxdWFsaXR5IGZhY3RvciBhcyBhIHBlcmNlbnRhZ2UgKG9wdGlvbmFsLCBkZWZhdWx0OiA1MCkgPHN1cD5bMl0oI2ZuMik8L3N1cD4gIHxcbiAgIHwgbWF4d2lkdGggICAgfCBudW1iZXIgfCBNYXhpbXVtIHdpZHRoIGluIHBpeGVscyBpZiB5b3UgbmVlZCB0byByZXNpemUgKG9wdGlvbmFsLCBkZWZhdWx0OiAwIC0gbm8gcmVzaXplKSAgfFxuICAgfCBtYXhoZWlnaHQgICB8IG51bWJlciB8IE1heGltdW0gaGVpZ2h0IGluIHBpeGVscyBpZiB5b3UgbmVlZCB0byByZXNpemUgKG9wdGlvbmFsLCBkZWZhdWx0OiAwIC0gbm8gcmVzaXplKSB8XG4gICAqL1xuICAgIHB1YmxpYyBjb21wcmVzc0ZpbGUoXG4gICAgICAgIGltYWdlOiBEYXRhVXJsLFxuICAgICAgICBvcmllbnRhdGlvbjogRE9DX09SSUVOVEFUSU9OLFxuICAgICAgICByYXRpbyA9IDUwLFxuICAgICAgICBxdWFsaXR5ID0gNTAsXG4gICAgICAgIG1heFdpZHRoID0gMCxcbiAgICAgICAgbWF4SGVpZ2h0ID0gMFxuICAgICk6IFByb21pc2U8RGF0YVVybD4ge1xuICAgICAgICByZXR1cm4gSW1hZ2VDb21wcmVzcy5jb21wcmVzcyhpbWFnZSwgb3JpZW50YXRpb24sIHRoaXMucmVuZGVyLCByYXRpbywgcXVhbGl0eSwgbWF4V2lkdGgsIG1heEhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9zdCBzaW1wbGUgZnVuY3Rpb24gdG8gdXNlIGhlcmUuXG4gICAgICogUGVyZm9ybSBhbiB1cGxvYWQgYW5kIHJldHVybiBhbiBpbWFnZSBkYXRhVXJsIChzdHJpbmcgZm9ybWF0KSB3aXRoIGEgbWF4aW11bSBzaXplLCBnaXZlbiBpbiAqTWVnYUJ5dGVzKlxuICAgICAqIElmIHRoZSBzaXplIGNhbid0IGJlIHJlYWNoZWQsIHRoZSBiZXN0IHRoYXQgY2FuIGJlIHJlYWNoZWQgd2lsbCBiZSByZXR1cm5lZCBpbiBwcm9taXNlICpyZWplY3Rpb24qXG4gICAgICogUHV0IGRlYnVnTW9kZSB0byB0cnVlIGlmIHlvdSBoYXZlIHNvbWUgdHJvdWJsZSB0byBwcmludCBzb21lIGhlbHAgdXNpbmcgY29uc29sZS5kZWJ1Z1xuICAgICAqL1xuICAgIHB1YmxpYyB1cGxvYWRBbmRHZXRJbWFnZVdpdGhNYXhTaXplKG1heFNpemVNYiA9IDEsIGRlYnVnTW9kZSA9IGZhbHNlLCByZWplY3RPbkNhbmNlbCA9IGZhbHNlKTogUHJvbWlzZTxEYXRhVXJsPiB7XG4gICAgICAgIHJldHVybiBJbWFnZUNvbXByZXNzLmdldEltYWdlTWF4U2l6ZShtYXhTaXplTWIsIGRlYnVnTW9kZSwgdGhpcy5yZW5kZXIsIHJlamVjdE9uQ2FuY2VsKVxuICAgICAgICAgICAgLnRoZW4odXBsb2FkUmVzcG9uc2UgPT4gdXBsb2FkUmVzcG9uc2UuaW1hZ2UpXG4gICAgICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZS5pbWFnZTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhbWUgYXMgYmVmb3JlLCBidXQgcmV0dXJuIG1vcmUgaW5mb3JtYXRpb25zIChmaWxlIG5hbWUuLi4pXG4gICAgICovXG4gICAgcHVibGljIHVwbG9hZEFuZEdldEltYWdlV2l0aE1heFNpemVBbmRNZXRhcyhtYXhTaXplTWIgPSAxLCBkZWJ1Z01vZGUgPSBmYWxzZSwgcmVqZWN0T25DYW5jZWwgPSBmYWxzZSk6IFByb21pc2U8VXBsb2FkUmVzcG9uc2U+IHtcbiAgICAgICAgcmV0dXJuIEltYWdlQ29tcHJlc3MuZ2V0SW1hZ2VNYXhTaXplKG1heFNpemVNYiwgZGVidWdNb2RlLCB0aGlzLnJlbmRlciwgcmVqZWN0T25DYW5jZWwpO1xuICAgIH1cbn1cbiJdfQ==