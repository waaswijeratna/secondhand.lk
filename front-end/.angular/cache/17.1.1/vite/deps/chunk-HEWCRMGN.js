import {
  ActivatedRoute,
  NavigationEnd,
  Router,
  RouterLink,
  RouterLinkActive,
  RouterModule,
  RouterOutlet
} from "./chunk-PN2LX5OB.js";
import {
  BlockScrollStrategy,
  FlexibleConnectedPositionStrategy,
  GlobalPositionStrategy,
  Overlay,
  OverlayContainer,
  OverlayModule,
  OverlayPositionBuilder,
  ScrollDispatcher,
  ScrollStrategyOptions,
  ScrollingModule,
  ViewportRuler
} from "./chunk-QTS5XRP6.js";
import {
  CdkPortal,
  CdkPortalOutlet,
  ComponentPortal,
  PortalInjector,
  PortalModule,
  TemplatePortal
} from "./chunk-HGCSL3KO.js";
import {
  DomSanitizer
} from "./chunk-SMQBOBCS.js";
import {
  animate,
  state,
  style,
  transition,
  trigger
} from "./chunk-WIGXMDCV.js";
import {
  DataSource,
  _DisposeViewRepeaterStrategy,
  _RecycleViewRepeaterStrategy,
  _VIEW_REPEATER_STRATEGY,
  _ViewRepeaterOperation,
  isDataSource
} from "./chunk-TY2LYSU5.js";
import {
  DefaultValueAccessor,
  FormsModule,
  NG_VALIDATORS,
  NG_VALUE_ACCESSOR,
  NgControlStatus,
  NgControlStatusGroup,
  NgForm,
  NgModel,
  Validators,
  ɵNgNoValidate
} from "./chunk-2RRGU55S.js";
import {
  ActiveDescendantKeyManager,
  BACKSPACE,
  BidiModule,
  DELETE,
  Directionality,
  ENTER,
  ESCAPE,
  FocusKeyManager,
  FocusMonitor,
  FocusTrap,
  FocusTrapFactory,
  InteractivityChecker,
  Platform,
  SPACE,
  coerceBooleanProperty
} from "./chunk-RKSOZWWK.js";
import {
  AsyncPipe,
  CommonModule,
  DOCUMENT,
  DatePipe,
  FormStyle,
  FormatWidth,
  Location,
  NgClass,
  NgForOf,
  NgIf,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgTemplateOutlet,
  TranslationWidth,
  getLocaleDayNames,
  getLocaleFirstDayOfWeek,
  getLocaleMonthNames,
  getLocaleTimeFormat,
  isPlatformBrowser
} from "./chunk-FMYXQAGX.js";
import {
  Attribute,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ComponentFactoryResolver$1,
  ContentChild,
  ContentChildren,
  Directive,
  ElementRef,
  EventEmitter,
  Host,
  HostBinding,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  InputFlags,
  IterableDiffers,
  LOCALE_ID,
  NgModule,
  NgZone,
  Optional,
  Output,
  PLATFORM_ID,
  Pipe,
  Renderer2,
  SimpleChange,
  SkipSelf,
  TemplateRef,
  Type,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  ViewEncapsulation$1,
  animationFrameScheduler,
  booleanAttribute,
  forkJoin,
  forwardRef,
  fromEvent,
  inject,
  isDevMode,
  isObservable,
  merge,
  setClassMetadata,
  ɵɵInheritDefinitionFeature,
  ɵɵInputTransformsFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵStandaloneFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassMapInterpolate1,
  ɵɵclassProp,
  ɵɵconditional,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵhostProperty,
  ɵɵinject,
  ɵɵinjectAttribute,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpropertyInterpolate,
  ɵɵpureFunction1,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵresolveWindow,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeUrl,
  ɵɵstyleProp,
  ɵɵsyntheticHostProperty,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵviewQuery
} from "./chunk-D5Z2BX4D.js";
import {
  BehaviorSubject,
  EMPTY,
  Observable,
  ReplaySubject,
  Subject,
  combineLatest,
  debounceTime,
  delay,
  distinctUntilChanged,
  filter,
  finalize,
  from,
  interval,
  map,
  observeOn,
  of,
  pairwise,
  publish,
  refCount,
  repeat,
  share,
  skip,
  startWith,
  switchMap,
  take,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  timer
} from "./chunk-IOPHKB2L.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-ASLTLD6L.js";

// node_modules/@angular/cdk/fesm2022/table.mjs
function CdkTable_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2);
  }
}
function CdkTable_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "thead", 0);
    ɵɵelementContainer(1, 1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "tbody", 0);
    ɵɵelementContainer(3, 2)(4, 3);
    ɵɵelementEnd();
    ɵɵelementStart(5, "tfoot", 0);
    ɵɵelementContainer(6, 4);
    ɵɵelementEnd();
  }
}
function CdkTable_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 1)(1, 2)(2, 3)(3, 4);
  }
}
var _c0 = [[["caption"]], [["colgroup"], ["col"]], "*"];
var _c1 = ["caption", "colgroup, col", "*"];
function CdkTextColumn_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("text-align", ctx_r0.justify);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.headerText, " ");
  }
}
function CdkTextColumn_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const data_r2 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("text-align", ctx_r1.justify);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.dataAccessor(data_r2, ctx_r1.name), " ");
  }
}
var CDK_TABLE = new InjectionToken("CDK_TABLE");
var TEXT_COLUMN_OPTIONS = new InjectionToken("text-column-options");
var _CdkCellDef = class _CdkCellDef {
  constructor(template) {
    this.template = template;
  }
};
_CdkCellDef.ɵfac = function CdkCellDef_Factory(t) {
  return new (t || _CdkCellDef)(ɵɵdirectiveInject(TemplateRef));
};
_CdkCellDef.ɵdir = ɵɵdefineDirective({
  type: _CdkCellDef,
  selectors: [["", "cdkCellDef", ""]],
  standalone: true
});
var CdkCellDef = _CdkCellDef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkCellDef, [{
    type: Directive,
    args: [{
      selector: "[cdkCellDef]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _CdkHeaderCellDef = class _CdkHeaderCellDef {
  constructor(template) {
    this.template = template;
  }
};
_CdkHeaderCellDef.ɵfac = function CdkHeaderCellDef_Factory(t) {
  return new (t || _CdkHeaderCellDef)(ɵɵdirectiveInject(TemplateRef));
};
_CdkHeaderCellDef.ɵdir = ɵɵdefineDirective({
  type: _CdkHeaderCellDef,
  selectors: [["", "cdkHeaderCellDef", ""]],
  standalone: true
});
var CdkHeaderCellDef = _CdkHeaderCellDef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkHeaderCellDef, [{
    type: Directive,
    args: [{
      selector: "[cdkHeaderCellDef]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _CdkFooterCellDef = class _CdkFooterCellDef {
  constructor(template) {
    this.template = template;
  }
};
_CdkFooterCellDef.ɵfac = function CdkFooterCellDef_Factory(t) {
  return new (t || _CdkFooterCellDef)(ɵɵdirectiveInject(TemplateRef));
};
_CdkFooterCellDef.ɵdir = ɵɵdefineDirective({
  type: _CdkFooterCellDef,
  selectors: [["", "cdkFooterCellDef", ""]],
  standalone: true
});
var CdkFooterCellDef = _CdkFooterCellDef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFooterCellDef, [{
    type: Directive,
    args: [{
      selector: "[cdkFooterCellDef]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _CdkColumnDef = class _CdkColumnDef {
  /** Unique name for this column. */
  get name() {
    return this._name;
  }
  set name(name) {
    this._setNameInput(name);
  }
  /** Whether the cell is sticky. */
  get sticky() {
    return this._sticky;
  }
  set sticky(value) {
    if (value !== this._sticky) {
      this._sticky = value;
      this._hasStickyChanged = true;
    }
  }
  /**
   * Whether this column should be sticky positioned on the end of the row. Should make sure
   * that it mimics the `CanStick` mixin such that `_hasStickyChanged` is set to true if the value
   * has been changed.
   */
  get stickyEnd() {
    return this._stickyEnd;
  }
  set stickyEnd(value) {
    if (value !== this._stickyEnd) {
      this._stickyEnd = value;
      this._hasStickyChanged = true;
    }
  }
  constructor(_table) {
    this._table = _table;
    this._hasStickyChanged = false;
    this._sticky = false;
    this._stickyEnd = false;
  }
  /** Whether the sticky state has changed. */
  hasStickyChanged() {
    const hasStickyChanged = this._hasStickyChanged;
    this.resetStickyChanged();
    return hasStickyChanged;
  }
  /** Resets the sticky changed state. */
  resetStickyChanged() {
    this._hasStickyChanged = false;
  }
  /**
   * Overridable method that sets the css classes that will be added to every cell in this
   * column.
   * In the future, columnCssClassName will change from type string[] to string and this
   * will set a single string value.
   * @docs-private
   */
  _updateColumnCssClassName() {
    this._columnCssClassName = [`cdk-column-${this.cssClassFriendlyName}`];
  }
  /**
   * This has been extracted to a util because of TS 4 and VE.
   * View Engine doesn't support property rename inheritance.
   * TS 4.0 doesn't allow properties to override accessors or vice-versa.
   * @docs-private
   */
  _setNameInput(value) {
    if (value) {
      this._name = value;
      this.cssClassFriendlyName = value.replace(/[^a-z0-9_-]/gi, "-");
      this._updateColumnCssClassName();
    }
  }
};
_CdkColumnDef.ɵfac = function CdkColumnDef_Factory(t) {
  return new (t || _CdkColumnDef)(ɵɵdirectiveInject(CDK_TABLE, 8));
};
_CdkColumnDef.ɵdir = ɵɵdefineDirective({
  type: _CdkColumnDef,
  selectors: [["", "cdkColumnDef", ""]],
  contentQueries: function CdkColumnDef_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CdkCellDef, 5);
      ɵɵcontentQuery(dirIndex, CdkHeaderCellDef, 5);
      ɵɵcontentQuery(dirIndex, CdkFooterCellDef, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cell = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerCell = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerCell = _t.first);
    }
  },
  inputs: {
    name: [InputFlags.None, "cdkColumnDef", "name"],
    sticky: [InputFlags.HasDecoratorInputTransform, "sticky", "sticky", booleanAttribute],
    stickyEnd: [InputFlags.HasDecoratorInputTransform, "stickyEnd", "stickyEnd", booleanAttribute]
  },
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: "MAT_SORT_HEADER_COLUMN_DEF",
    useExisting: _CdkColumnDef
  }]), ɵɵInputTransformsFeature]
});
var CdkColumnDef = _CdkColumnDef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkColumnDef, [{
    type: Directive,
    args: [{
      selector: "[cdkColumnDef]",
      providers: [{
        provide: "MAT_SORT_HEADER_COLUMN_DEF",
        useExisting: CdkColumnDef
      }],
      standalone: true
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CDK_TABLE]
    }, {
      type: Optional
    }]
  }], {
    name: [{
      type: Input,
      args: ["cdkColumnDef"]
    }],
    sticky: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    stickyEnd: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    cell: [{
      type: ContentChild,
      args: [CdkCellDef]
    }],
    headerCell: [{
      type: ContentChild,
      args: [CdkHeaderCellDef]
    }],
    footerCell: [{
      type: ContentChild,
      args: [CdkFooterCellDef]
    }]
  });
})();
var BaseCdkCell = class {
  constructor(columnDef, elementRef) {
    elementRef.nativeElement.classList.add(...columnDef._columnCssClassName);
  }
};
var _CdkHeaderCell = class _CdkHeaderCell extends BaseCdkCell {
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
  }
};
_CdkHeaderCell.ɵfac = function CdkHeaderCell_Factory(t) {
  return new (t || _CdkHeaderCell)(ɵɵdirectiveInject(CdkColumnDef), ɵɵdirectiveInject(ElementRef));
};
_CdkHeaderCell.ɵdir = ɵɵdefineDirective({
  type: _CdkHeaderCell,
  selectors: [["cdk-header-cell"], ["th", "cdk-header-cell", ""]],
  hostAttrs: ["role", "columnheader", 1, "cdk-header-cell"],
  standalone: true,
  features: [ɵɵInheritDefinitionFeature]
});
var CdkHeaderCell = _CdkHeaderCell;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkHeaderCell, [{
    type: Directive,
    args: [{
      selector: "cdk-header-cell, th[cdk-header-cell]",
      host: {
        "class": "cdk-header-cell",
        "role": "columnheader"
      },
      standalone: true
    }]
  }], () => [{
    type: CdkColumnDef
  }, {
    type: ElementRef
  }], null);
})();
var _CdkFooterCell = class _CdkFooterCell extends BaseCdkCell {
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    const role = columnDef._table?._getCellRole();
    if (role) {
      elementRef.nativeElement.setAttribute("role", role);
    }
  }
};
_CdkFooterCell.ɵfac = function CdkFooterCell_Factory(t) {
  return new (t || _CdkFooterCell)(ɵɵdirectiveInject(CdkColumnDef), ɵɵdirectiveInject(ElementRef));
};
_CdkFooterCell.ɵdir = ɵɵdefineDirective({
  type: _CdkFooterCell,
  selectors: [["cdk-footer-cell"], ["td", "cdk-footer-cell", ""]],
  hostAttrs: [1, "cdk-footer-cell"],
  standalone: true,
  features: [ɵɵInheritDefinitionFeature]
});
var CdkFooterCell = _CdkFooterCell;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFooterCell, [{
    type: Directive,
    args: [{
      selector: "cdk-footer-cell, td[cdk-footer-cell]",
      host: {
        "class": "cdk-footer-cell"
      },
      standalone: true
    }]
  }], () => [{
    type: CdkColumnDef
  }, {
    type: ElementRef
  }], null);
})();
var _CdkCell = class _CdkCell extends BaseCdkCell {
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    const role = columnDef._table?._getCellRole();
    if (role) {
      elementRef.nativeElement.setAttribute("role", role);
    }
  }
};
_CdkCell.ɵfac = function CdkCell_Factory(t) {
  return new (t || _CdkCell)(ɵɵdirectiveInject(CdkColumnDef), ɵɵdirectiveInject(ElementRef));
};
_CdkCell.ɵdir = ɵɵdefineDirective({
  type: _CdkCell,
  selectors: [["cdk-cell"], ["td", "cdk-cell", ""]],
  hostAttrs: [1, "cdk-cell"],
  standalone: true,
  features: [ɵɵInheritDefinitionFeature]
});
var CdkCell = _CdkCell;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkCell, [{
    type: Directive,
    args: [{
      selector: "cdk-cell, td[cdk-cell]",
      host: {
        "class": "cdk-cell"
      },
      standalone: true
    }]
  }], () => [{
    type: CdkColumnDef
  }, {
    type: ElementRef
  }], null);
})();
var _Schedule = class {
  constructor() {
    this.tasks = [];
    this.endTasks = [];
  }
};
var _COALESCED_STYLE_SCHEDULER = new InjectionToken("_COALESCED_STYLE_SCHEDULER");
var __CoalescedStyleScheduler = class __CoalescedStyleScheduler {
  constructor(_ngZone) {
    this._ngZone = _ngZone;
    this._currentSchedule = null;
    this._destroyed = new Subject();
  }
  /**
   * Schedules the specified task to run at the end of the current VM turn.
   */
  schedule(task) {
    this._createScheduleIfNeeded();
    this._currentSchedule.tasks.push(task);
  }
  /**
   * Schedules the specified task to run after other scheduled tasks at the end of the current
   * VM turn.
   */
  scheduleEnd(task) {
    this._createScheduleIfNeeded();
    this._currentSchedule.endTasks.push(task);
  }
  /** Prevent any further tasks from running. */
  ngOnDestroy() {
    this._destroyed.next();
    this._destroyed.complete();
  }
  _createScheduleIfNeeded() {
    if (this._currentSchedule) {
      return;
    }
    this._currentSchedule = new _Schedule();
    this._getScheduleObservable().pipe(takeUntil(this._destroyed)).subscribe(() => {
      while (this._currentSchedule.tasks.length || this._currentSchedule.endTasks.length) {
        const schedule = this._currentSchedule;
        this._currentSchedule = new _Schedule();
        for (const task of schedule.tasks) {
          task();
        }
        for (const task of schedule.endTasks) {
          task();
        }
      }
      this._currentSchedule = null;
    });
  }
  _getScheduleObservable() {
    return this._ngZone.isStable ? from(Promise.resolve(void 0)) : this._ngZone.onStable.pipe(take(1));
  }
};
__CoalescedStyleScheduler.ɵfac = function _CoalescedStyleScheduler_Factory(t) {
  return new (t || __CoalescedStyleScheduler)(ɵɵinject(NgZone));
};
__CoalescedStyleScheduler.ɵprov = ɵɵdefineInjectable({
  token: __CoalescedStyleScheduler,
  factory: __CoalescedStyleScheduler.ɵfac
});
var _CoalescedStyleScheduler = __CoalescedStyleScheduler;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_CoalescedStyleScheduler, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }], null);
})();
var CDK_ROW_TEMPLATE = `<ng-container cdkCellOutlet></ng-container>`;
var _BaseRowDef = class _BaseRowDef {
  constructor(template, _differs) {
    this.template = template;
    this._differs = _differs;
  }
  ngOnChanges(changes) {
    if (!this._columnsDiffer) {
      const columns = changes["columns"] && changes["columns"].currentValue || [];
      this._columnsDiffer = this._differs.find(columns).create();
      this._columnsDiffer.diff(columns);
    }
  }
  /**
   * Returns the difference between the current columns and the columns from the last diff, or null
   * if there is no difference.
   */
  getColumnsDiff() {
    return this._columnsDiffer.diff(this.columns);
  }
  /** Gets this row def's relevant cell template from the provided column def. */
  extractCellTemplate(column) {
    if (this instanceof CdkHeaderRowDef) {
      return column.headerCell.template;
    }
    if (this instanceof CdkFooterRowDef) {
      return column.footerCell.template;
    } else {
      return column.cell.template;
    }
  }
};
_BaseRowDef.ɵfac = function BaseRowDef_Factory(t) {
  return new (t || _BaseRowDef)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers));
};
_BaseRowDef.ɵdir = ɵɵdefineDirective({
  type: _BaseRowDef,
  features: [ɵɵNgOnChangesFeature]
});
var BaseRowDef = _BaseRowDef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseRowDef, [{
    type: Directive
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }], null);
})();
var _CdkHeaderRowDef = class _CdkHeaderRowDef extends BaseRowDef {
  /** Whether the row is sticky. */
  get sticky() {
    return this._sticky;
  }
  set sticky(value) {
    if (value !== this._sticky) {
      this._sticky = value;
      this._hasStickyChanged = true;
    }
  }
  constructor(template, _differs, _table) {
    super(template, _differs);
    this._table = _table;
    this._hasStickyChanged = false;
    this._sticky = false;
  }
  // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
  // Explicitly define it so that the method is called as part of the Angular lifecycle.
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
  }
  /** Whether the sticky state has changed. */
  hasStickyChanged() {
    const hasStickyChanged = this._hasStickyChanged;
    this.resetStickyChanged();
    return hasStickyChanged;
  }
  /** Resets the sticky changed state. */
  resetStickyChanged() {
    this._hasStickyChanged = false;
  }
};
_CdkHeaderRowDef.ɵfac = function CdkHeaderRowDef_Factory(t) {
  return new (t || _CdkHeaderRowDef)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(CDK_TABLE, 8));
};
_CdkHeaderRowDef.ɵdir = ɵɵdefineDirective({
  type: _CdkHeaderRowDef,
  selectors: [["", "cdkHeaderRowDef", ""]],
  inputs: {
    columns: [InputFlags.None, "cdkHeaderRowDef", "columns"],
    sticky: [InputFlags.HasDecoratorInputTransform, "cdkHeaderRowDefSticky", "sticky", booleanAttribute]
  },
  standalone: true,
  features: [ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
var CdkHeaderRowDef = _CdkHeaderRowDef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkHeaderRowDef, [{
    type: Directive,
    args: [{
      selector: "[cdkHeaderRowDef]",
      inputs: [{
        name: "columns",
        alias: "cdkHeaderRowDef"
      }],
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CDK_TABLE]
    }, {
      type: Optional
    }]
  }], {
    sticky: [{
      type: Input,
      args: [{
        alias: "cdkHeaderRowDefSticky",
        transform: booleanAttribute
      }]
    }]
  });
})();
var _CdkFooterRowDef = class _CdkFooterRowDef extends BaseRowDef {
  /** Whether the row is sticky. */
  get sticky() {
    return this._sticky;
  }
  set sticky(value) {
    if (value !== this._sticky) {
      this._sticky = value;
      this._hasStickyChanged = true;
    }
  }
  constructor(template, _differs, _table) {
    super(template, _differs);
    this._table = _table;
    this._hasStickyChanged = false;
    this._sticky = false;
  }
  // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.
  // Explicitly define it so that the method is called as part of the Angular lifecycle.
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
  }
  /** Whether the sticky state has changed. */
  hasStickyChanged() {
    const hasStickyChanged = this._hasStickyChanged;
    this.resetStickyChanged();
    return hasStickyChanged;
  }
  /** Resets the sticky changed state. */
  resetStickyChanged() {
    this._hasStickyChanged = false;
  }
};
_CdkFooterRowDef.ɵfac = function CdkFooterRowDef_Factory(t) {
  return new (t || _CdkFooterRowDef)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(CDK_TABLE, 8));
};
_CdkFooterRowDef.ɵdir = ɵɵdefineDirective({
  type: _CdkFooterRowDef,
  selectors: [["", "cdkFooterRowDef", ""]],
  inputs: {
    columns: [InputFlags.None, "cdkFooterRowDef", "columns"],
    sticky: [InputFlags.HasDecoratorInputTransform, "cdkFooterRowDefSticky", "sticky", booleanAttribute]
  },
  standalone: true,
  features: [ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
var CdkFooterRowDef = _CdkFooterRowDef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFooterRowDef, [{
    type: Directive,
    args: [{
      selector: "[cdkFooterRowDef]",
      inputs: [{
        name: "columns",
        alias: "cdkFooterRowDef"
      }],
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CDK_TABLE]
    }, {
      type: Optional
    }]
  }], {
    sticky: [{
      type: Input,
      args: [{
        alias: "cdkFooterRowDefSticky",
        transform: booleanAttribute
      }]
    }]
  });
})();
var _CdkRowDef = class _CdkRowDef extends BaseRowDef {
  // TODO(andrewseguin): Add an input for providing a switch function to determine
  //   if this template should be used.
  constructor(template, _differs, _table) {
    super(template, _differs);
    this._table = _table;
  }
};
_CdkRowDef.ɵfac = function CdkRowDef_Factory(t) {
  return new (t || _CdkRowDef)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(CDK_TABLE, 8));
};
_CdkRowDef.ɵdir = ɵɵdefineDirective({
  type: _CdkRowDef,
  selectors: [["", "cdkRowDef", ""]],
  inputs: {
    columns: [InputFlags.None, "cdkRowDefColumns", "columns"],
    when: [InputFlags.None, "cdkRowDefWhen", "when"]
  },
  standalone: true,
  features: [ɵɵInheritDefinitionFeature]
});
var CdkRowDef = _CdkRowDef;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkRowDef, [{
    type: Directive,
    args: [{
      selector: "[cdkRowDef]",
      inputs: [{
        name: "columns",
        alias: "cdkRowDefColumns"
      }, {
        name: "when",
        alias: "cdkRowDefWhen"
      }],
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CDK_TABLE]
    }, {
      type: Optional
    }]
  }], null);
})();
var _CdkCellOutlet = class _CdkCellOutlet {
  constructor(_viewContainer) {
    this._viewContainer = _viewContainer;
    _CdkCellOutlet.mostRecentCellOutlet = this;
  }
  ngOnDestroy() {
    if (_CdkCellOutlet.mostRecentCellOutlet === this) {
      _CdkCellOutlet.mostRecentCellOutlet = null;
    }
  }
};
_CdkCellOutlet.mostRecentCellOutlet = null;
_CdkCellOutlet.ɵfac = function CdkCellOutlet_Factory(t) {
  return new (t || _CdkCellOutlet)(ɵɵdirectiveInject(ViewContainerRef));
};
_CdkCellOutlet.ɵdir = ɵɵdefineDirective({
  type: _CdkCellOutlet,
  selectors: [["", "cdkCellOutlet", ""]],
  standalone: true
});
var CdkCellOutlet = _CdkCellOutlet;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkCellOutlet, [{
    type: Directive,
    args: [{
      selector: "[cdkCellOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }], null);
})();
var _CdkHeaderRow = class _CdkHeaderRow {
};
_CdkHeaderRow.ɵfac = function CdkHeaderRow_Factory(t) {
  return new (t || _CdkHeaderRow)();
};
_CdkHeaderRow.ɵcmp = ɵɵdefineComponent({
  type: _CdkHeaderRow,
  selectors: [["cdk-header-row"], ["tr", "cdk-header-row", ""]],
  hostAttrs: ["role", "row", 1, "cdk-header-row"],
  standalone: true,
  features: [ɵɵStandaloneFeature],
  decls: 1,
  vars: 0,
  consts: [["cdkCellOutlet", ""]],
  template: function CdkHeaderRow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [CdkCellOutlet],
  encapsulation: 2
});
var CdkHeaderRow = _CdkHeaderRow;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkHeaderRow, [{
    type: Component,
    args: [{
      selector: "cdk-header-row, tr[cdk-header-row]",
      template: CDK_ROW_TEMPLATE,
      host: {
        "class": "cdk-header-row",
        "role": "row"
      },
      // See note on CdkTable for explanation on why this uses the default change detection strategy.
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation$1.None,
      standalone: true,
      imports: [CdkCellOutlet]
    }]
  }], null, null);
})();
var _CdkFooterRow = class _CdkFooterRow {
};
_CdkFooterRow.ɵfac = function CdkFooterRow_Factory(t) {
  return new (t || _CdkFooterRow)();
};
_CdkFooterRow.ɵcmp = ɵɵdefineComponent({
  type: _CdkFooterRow,
  selectors: [["cdk-footer-row"], ["tr", "cdk-footer-row", ""]],
  hostAttrs: ["role", "row", 1, "cdk-footer-row"],
  standalone: true,
  features: [ɵɵStandaloneFeature],
  decls: 1,
  vars: 0,
  consts: [["cdkCellOutlet", ""]],
  template: function CdkFooterRow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [CdkCellOutlet],
  encapsulation: 2
});
var CdkFooterRow = _CdkFooterRow;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFooterRow, [{
    type: Component,
    args: [{
      selector: "cdk-footer-row, tr[cdk-footer-row]",
      template: CDK_ROW_TEMPLATE,
      host: {
        "class": "cdk-footer-row",
        "role": "row"
      },
      // See note on CdkTable for explanation on why this uses the default change detection strategy.
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation$1.None,
      standalone: true,
      imports: [CdkCellOutlet]
    }]
  }], null, null);
})();
var _CdkRow = class _CdkRow {
};
_CdkRow.ɵfac = function CdkRow_Factory(t) {
  return new (t || _CdkRow)();
};
_CdkRow.ɵcmp = ɵɵdefineComponent({
  type: _CdkRow,
  selectors: [["cdk-row"], ["tr", "cdk-row", ""]],
  hostAttrs: ["role", "row", 1, "cdk-row"],
  standalone: true,
  features: [ɵɵStandaloneFeature],
  decls: 1,
  vars: 0,
  consts: [["cdkCellOutlet", ""]],
  template: function CdkRow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [CdkCellOutlet],
  encapsulation: 2
});
var CdkRow = _CdkRow;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkRow, [{
    type: Component,
    args: [{
      selector: "cdk-row, tr[cdk-row]",
      template: CDK_ROW_TEMPLATE,
      host: {
        "class": "cdk-row",
        "role": "row"
      },
      // See note on CdkTable for explanation on why this uses the default change detection strategy.
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation$1.None,
      standalone: true,
      imports: [CdkCellOutlet]
    }]
  }], null, null);
})();
var _CdkNoDataRow = class _CdkNoDataRow {
  constructor(templateRef) {
    this.templateRef = templateRef;
    this._contentClassName = "cdk-no-data-row";
  }
};
_CdkNoDataRow.ɵfac = function CdkNoDataRow_Factory(t) {
  return new (t || _CdkNoDataRow)(ɵɵdirectiveInject(TemplateRef));
};
_CdkNoDataRow.ɵdir = ɵɵdefineDirective({
  type: _CdkNoDataRow,
  selectors: [["ng-template", "cdkNoDataRow", ""]],
  standalone: true
});
var CdkNoDataRow = _CdkNoDataRow;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkNoDataRow, [{
    type: Directive,
    args: [{
      selector: "ng-template[cdkNoDataRow]",
      standalone: true
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var STICKY_DIRECTIONS = ["top", "bottom", "left", "right"];
var StickyStyler = class {
  /**
   * @param _isNativeHtmlTable Whether the sticky logic should be based on a table
   *     that uses the native `<table>` element.
   * @param _stickCellCss The CSS class that will be applied to every row/cell that has
   *     sticky positioning applied.
   * @param direction The directionality context of the table (ltr/rtl); affects column positioning
   *     by reversing left/right positions.
   * @param _isBrowser Whether the table is currently being rendered on the server or the client.
   * @param _needsPositionStickyOnElement Whether we need to specify position: sticky on cells
   *     using inline styles. If false, it is assumed that position: sticky is included in
   *     the component stylesheet for _stickCellCss.
   * @param _positionListener A listener that is notified of changes to sticky rows/columns
   *     and their dimensions.
   */
  constructor(_isNativeHtmlTable, _stickCellCss, direction, _coalescedStyleScheduler, _isBrowser = true, _needsPositionStickyOnElement = true, _positionListener) {
    this._isNativeHtmlTable = _isNativeHtmlTable;
    this._stickCellCss = _stickCellCss;
    this.direction = direction;
    this._coalescedStyleScheduler = _coalescedStyleScheduler;
    this._isBrowser = _isBrowser;
    this._needsPositionStickyOnElement = _needsPositionStickyOnElement;
    this._positionListener = _positionListener;
    this._cachedCellWidths = [];
    this._borderCellCss = {
      "top": `${_stickCellCss}-border-elem-top`,
      "bottom": `${_stickCellCss}-border-elem-bottom`,
      "left": `${_stickCellCss}-border-elem-left`,
      "right": `${_stickCellCss}-border-elem-right`
    };
  }
  /**
   * Clears the sticky positioning styles from the row and its cells by resetting the `position`
   * style, setting the zIndex to 0, and unsetting each provided sticky direction.
   * @param rows The list of rows that should be cleared from sticking in the provided directions
   * @param stickyDirections The directions that should no longer be set as sticky on the rows.
   */
  clearStickyPositioning(rows, stickyDirections) {
    const elementsToClear = [];
    for (const row of rows) {
      if (row.nodeType !== row.ELEMENT_NODE) {
        continue;
      }
      elementsToClear.push(row);
      for (let i = 0; i < row.children.length; i++) {
        elementsToClear.push(row.children[i]);
      }
    }
    this._coalescedStyleScheduler.schedule(() => {
      for (const element of elementsToClear) {
        this._removeStickyStyle(element, stickyDirections);
      }
    });
  }
  /**
   * Applies sticky left and right positions to the cells of each row according to the sticky
   * states of the rendered column definitions.
   * @param rows The rows that should have its set of cells stuck according to the sticky states.
   * @param stickyStartStates A list of boolean states where each state represents whether the cell
   *     in this index position should be stuck to the start of the row.
   * @param stickyEndStates A list of boolean states where each state represents whether the cell
   *     in this index position should be stuck to the end of the row.
   * @param recalculateCellWidths Whether the sticky styler should recalculate the width of each
   *     column cell. If `false` cached widths will be used instead.
   */
  updateStickyColumns(rows, stickyStartStates, stickyEndStates, recalculateCellWidths = true) {
    if (!rows.length || !this._isBrowser || !(stickyStartStates.some((state2) => state2) || stickyEndStates.some((state2) => state2))) {
      if (this._positionListener) {
        this._positionListener.stickyColumnsUpdated({
          sizes: []
        });
        this._positionListener.stickyEndColumnsUpdated({
          sizes: []
        });
      }
      return;
    }
    this._coalescedStyleScheduler.schedule(() => {
      const firstRow = rows[0];
      const numCells = firstRow.children.length;
      const cellWidths = this._getCellWidths(firstRow, recalculateCellWidths);
      const startPositions = this._getStickyStartColumnPositions(cellWidths, stickyStartStates);
      const endPositions = this._getStickyEndColumnPositions(cellWidths, stickyEndStates);
      const lastStickyStart = stickyStartStates.lastIndexOf(true);
      const firstStickyEnd = stickyEndStates.indexOf(true);
      const isRtl = this.direction === "rtl";
      const start = isRtl ? "right" : "left";
      const end = isRtl ? "left" : "right";
      for (const row of rows) {
        for (let i = 0; i < numCells; i++) {
          const cell = row.children[i];
          if (stickyStartStates[i]) {
            this._addStickyStyle(cell, start, startPositions[i], i === lastStickyStart);
          }
          if (stickyEndStates[i]) {
            this._addStickyStyle(cell, end, endPositions[i], i === firstStickyEnd);
          }
        }
      }
      if (this._positionListener) {
        this._positionListener.stickyColumnsUpdated({
          sizes: lastStickyStart === -1 ? [] : cellWidths.slice(0, lastStickyStart + 1).map((width, index) => stickyStartStates[index] ? width : null)
        });
        this._positionListener.stickyEndColumnsUpdated({
          sizes: firstStickyEnd === -1 ? [] : cellWidths.slice(firstStickyEnd).map((width, index) => stickyEndStates[index + firstStickyEnd] ? width : null).reverse()
        });
      }
    });
  }
  /**
   * Applies sticky positioning to the row's cells if using the native table layout, and to the
   * row itself otherwise.
   * @param rowsToStick The list of rows that should be stuck according to their corresponding
   *     sticky state and to the provided top or bottom position.
   * @param stickyStates A list of boolean states where each state represents whether the row
   *     should be stuck in the particular top or bottom position.
   * @param position The position direction in which the row should be stuck if that row should be
   *     sticky.
   *
   */
  stickRows(rowsToStick, stickyStates, position) {
    if (!this._isBrowser) {
      return;
    }
    this._coalescedStyleScheduler.schedule(() => {
      const rows = position === "bottom" ? rowsToStick.slice().reverse() : rowsToStick;
      const states = position === "bottom" ? stickyStates.slice().reverse() : stickyStates;
      const stickyOffsets = [];
      const stickyCellHeights = [];
      const elementsToStick = [];
      for (let rowIndex = 0, stickyOffset = 0; rowIndex < rows.length; rowIndex++) {
        if (!states[rowIndex]) {
          continue;
        }
        stickyOffsets[rowIndex] = stickyOffset;
        const row = rows[rowIndex];
        elementsToStick[rowIndex] = this._isNativeHtmlTable ? Array.from(row.children) : [row];
        const height = row.getBoundingClientRect().height;
        stickyOffset += height;
        stickyCellHeights[rowIndex] = height;
      }
      const borderedRowIndex = states.lastIndexOf(true);
      for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
        if (!states[rowIndex]) {
          continue;
        }
        const offset = stickyOffsets[rowIndex];
        const isBorderedRowIndex = rowIndex === borderedRowIndex;
        for (const element of elementsToStick[rowIndex]) {
          this._addStickyStyle(element, position, offset, isBorderedRowIndex);
        }
      }
      if (position === "top") {
        this._positionListener?.stickyHeaderRowsUpdated({
          sizes: stickyCellHeights,
          offsets: stickyOffsets,
          elements: elementsToStick
        });
      } else {
        this._positionListener?.stickyFooterRowsUpdated({
          sizes: stickyCellHeights,
          offsets: stickyOffsets,
          elements: elementsToStick
        });
      }
    });
  }
  /**
   * When using the native table in Safari, sticky footer cells do not stick. The only way to stick
   * footer rows is to apply sticky styling to the tfoot container. This should only be done if
   * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from
   * the tfoot element.
   */
  updateStickyFooterContainer(tableElement, stickyStates) {
    if (!this._isNativeHtmlTable) {
      return;
    }
    this._coalescedStyleScheduler.schedule(() => {
      const tfoot = tableElement.querySelector("tfoot");
      if (tfoot) {
        if (stickyStates.some((state2) => !state2)) {
          this._removeStickyStyle(tfoot, ["bottom"]);
        } else {
          this._addStickyStyle(tfoot, "bottom", 0, false);
        }
      }
    });
  }
  /**
   * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating
   * the zIndex, removing each of the provided sticky directions, and removing the
   * sticky position if there are no more directions.
   */
  _removeStickyStyle(element, stickyDirections) {
    for (const dir of stickyDirections) {
      element.style[dir] = "";
      element.classList.remove(this._borderCellCss[dir]);
    }
    const hasDirection = STICKY_DIRECTIONS.some((dir) => stickyDirections.indexOf(dir) === -1 && element.style[dir]);
    if (hasDirection) {
      element.style.zIndex = this._getCalculatedZIndex(element);
    } else {
      element.style.zIndex = "";
      if (this._needsPositionStickyOnElement) {
        element.style.position = "";
      }
      element.classList.remove(this._stickCellCss);
    }
  }
  /**
   * Adds the sticky styling to the element by adding the sticky style class, changing position
   * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky
   * direction and value.
   */
  _addStickyStyle(element, dir, dirValue, isBorderElement) {
    element.classList.add(this._stickCellCss);
    if (isBorderElement) {
      element.classList.add(this._borderCellCss[dir]);
    }
    element.style[dir] = `${dirValue}px`;
    element.style.zIndex = this._getCalculatedZIndex(element);
    if (this._needsPositionStickyOnElement) {
      element.style.cssText += "position: -webkit-sticky; position: sticky; ";
    }
  }
  /**
   * Calculate what the z-index should be for the element, depending on what directions (top,
   * bottom, left, right) have been set. It should be true that elements with a top direction
   * should have the highest index since these are elements like a table header. If any of those
   * elements are also sticky in another direction, then they should appear above other elements
   * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements
   * (e.g. footer rows) should then be next in the ordering such that they are below the header
   * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)
   * should minimally increment so that they are above non-sticky elements but below top and bottom
   * elements.
   */
  _getCalculatedZIndex(element) {
    const zIndexIncrements = {
      top: 100,
      bottom: 10,
      left: 1,
      right: 1
    };
    let zIndex = 0;
    for (const dir of STICKY_DIRECTIONS) {
      if (element.style[dir]) {
        zIndex += zIndexIncrements[dir];
      }
    }
    return zIndex ? `${zIndex}` : "";
  }
  /** Gets the widths for each cell in the provided row. */
  _getCellWidths(row, recalculateCellWidths = true) {
    if (!recalculateCellWidths && this._cachedCellWidths.length) {
      return this._cachedCellWidths;
    }
    const cellWidths = [];
    const firstRowCells = row.children;
    for (let i = 0; i < firstRowCells.length; i++) {
      let cell = firstRowCells[i];
      cellWidths.push(cell.getBoundingClientRect().width);
    }
    this._cachedCellWidths = cellWidths;
    return cellWidths;
  }
  /**
   * Determines the left and right positions of each sticky column cell, which will be the
   * accumulation of all sticky column cell widths to the left and right, respectively.
   * Non-sticky cells do not need to have a value set since their positions will not be applied.
   */
  _getStickyStartColumnPositions(widths, stickyStates) {
    const positions = [];
    let nextPosition = 0;
    for (let i = 0; i < widths.length; i++) {
      if (stickyStates[i]) {
        positions[i] = nextPosition;
        nextPosition += widths[i];
      }
    }
    return positions;
  }
  /**
   * Determines the left and right positions of each sticky column cell, which will be the
   * accumulation of all sticky column cell widths to the left and right, respectively.
   * Non-sticky cells do not need to have a value set since their positions will not be applied.
   */
  _getStickyEndColumnPositions(widths, stickyStates) {
    const positions = [];
    let nextPosition = 0;
    for (let i = widths.length; i > 0; i--) {
      if (stickyStates[i]) {
        positions[i] = nextPosition;
        nextPosition += widths[i];
      }
    }
    return positions;
  }
};
function getTableUnknownColumnError(id) {
  return Error(`Could not find column with id "${id}".`);
}
function getTableDuplicateColumnNameError(name) {
  return Error(`Duplicate column definition name provided: "${name}".`);
}
function getTableMultipleDefaultRowDefsError() {
  return Error(`There can only be one default row without a when predicate function.`);
}
function getTableMissingMatchingRowDefError(data) {
  return Error(`Could not find a matching row definition for theprovided row data: ${JSON.stringify(data)}`);
}
function getTableMissingRowDefsError() {
  return Error("Missing definitions for header, footer, and row; cannot determine which columns should be rendered.");
}
function getTableUnknownDataSourceError() {
  return Error(`Provided data source did not match an array, Observable, or DataSource`);
}
function getTableTextColumnMissingParentTableError() {
  return Error(`Text column could not find a parent table for registration.`);
}
function getTableTextColumnMissingNameError() {
  return Error(`Table text column must have a name.`);
}
var STICKY_POSITIONING_LISTENER = new InjectionToken("CDK_SPL");
var _CdkRecycleRows = class _CdkRecycleRows {
};
_CdkRecycleRows.ɵfac = function CdkRecycleRows_Factory(t) {
  return new (t || _CdkRecycleRows)();
};
_CdkRecycleRows.ɵdir = ɵɵdefineDirective({
  type: _CdkRecycleRows,
  selectors: [["cdk-table", "recycleRows", ""], ["table", "cdk-table", "", "recycleRows", ""]],
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: _VIEW_REPEATER_STRATEGY,
    useClass: _RecycleViewRepeaterStrategy
  }])]
});
var CdkRecycleRows = _CdkRecycleRows;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkRecycleRows, [{
    type: Directive,
    args: [{
      selector: "cdk-table[recycleRows], table[cdk-table][recycleRows]",
      providers: [{
        provide: _VIEW_REPEATER_STRATEGY,
        useClass: _RecycleViewRepeaterStrategy
      }],
      standalone: true
    }]
  }], null, null);
})();
var _DataRowOutlet = class _DataRowOutlet {
  constructor(viewContainer, elementRef) {
    this.viewContainer = viewContainer;
    this.elementRef = elementRef;
    const table = inject(CDK_TABLE);
    table._rowOutlet = this;
    table._outletAssigned();
  }
};
_DataRowOutlet.ɵfac = function DataRowOutlet_Factory(t) {
  return new (t || _DataRowOutlet)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ElementRef));
};
_DataRowOutlet.ɵdir = ɵɵdefineDirective({
  type: _DataRowOutlet,
  selectors: [["", "rowOutlet", ""]],
  standalone: true
});
var DataRowOutlet = _DataRowOutlet;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DataRowOutlet, [{
    type: Directive,
    args: [{
      selector: "[rowOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: ElementRef
  }], null);
})();
var _HeaderRowOutlet = class _HeaderRowOutlet {
  constructor(viewContainer, elementRef) {
    this.viewContainer = viewContainer;
    this.elementRef = elementRef;
    const table = inject(CDK_TABLE);
    table._headerRowOutlet = this;
    table._outletAssigned();
  }
};
_HeaderRowOutlet.ɵfac = function HeaderRowOutlet_Factory(t) {
  return new (t || _HeaderRowOutlet)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ElementRef));
};
_HeaderRowOutlet.ɵdir = ɵɵdefineDirective({
  type: _HeaderRowOutlet,
  selectors: [["", "headerRowOutlet", ""]],
  standalone: true
});
var HeaderRowOutlet = _HeaderRowOutlet;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderRowOutlet, [{
    type: Directive,
    args: [{
      selector: "[headerRowOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: ElementRef
  }], null);
})();
var _FooterRowOutlet = class _FooterRowOutlet {
  constructor(viewContainer, elementRef) {
    this.viewContainer = viewContainer;
    this.elementRef = elementRef;
    const table = inject(CDK_TABLE);
    table._footerRowOutlet = this;
    table._outletAssigned();
  }
};
_FooterRowOutlet.ɵfac = function FooterRowOutlet_Factory(t) {
  return new (t || _FooterRowOutlet)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ElementRef));
};
_FooterRowOutlet.ɵdir = ɵɵdefineDirective({
  type: _FooterRowOutlet,
  selectors: [["", "footerRowOutlet", ""]],
  standalone: true
});
var FooterRowOutlet = _FooterRowOutlet;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterRowOutlet, [{
    type: Directive,
    args: [{
      selector: "[footerRowOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: ElementRef
  }], null);
})();
var _NoDataRowOutlet = class _NoDataRowOutlet {
  constructor(viewContainer, elementRef) {
    this.viewContainer = viewContainer;
    this.elementRef = elementRef;
    const table = inject(CDK_TABLE);
    table._noDataRowOutlet = this;
    table._outletAssigned();
  }
};
_NoDataRowOutlet.ɵfac = function NoDataRowOutlet_Factory(t) {
  return new (t || _NoDataRowOutlet)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ElementRef));
};
_NoDataRowOutlet.ɵdir = ɵɵdefineDirective({
  type: _NoDataRowOutlet,
  selectors: [["", "noDataRowOutlet", ""]],
  standalone: true
});
var NoDataRowOutlet = _NoDataRowOutlet;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoDataRowOutlet, [{
    type: Directive,
    args: [{
      selector: "[noDataRowOutlet]",
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: ElementRef
  }], null);
})();
var CDK_TABLE_TEMPLATE = (
  // Note that according to MDN, the `caption` element has to be projected as the **first**
  // element in the table. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption
  `
  <ng-content select="caption"/>
  <ng-content select="colgroup, col"/>

  <!--
    Unprojected content throws a hydration error so we need this to capture it.
    It gets removed on the client so it doesn't affect the layout.
  -->
  @if (_isServer) {
    <ng-content/>
  }

  @if (_isNativeHtmlTable) {
    <thead role="rowgroup">
      <ng-container headerRowOutlet/>
    </thead>
    <tbody role="rowgroup">
      <ng-container rowOutlet/>
      <ng-container noDataRowOutlet/>
    </tbody>
    <tfoot role="rowgroup">
      <ng-container footerRowOutlet/>
    </tfoot>
  } @else {
    <ng-container headerRowOutlet/>
    <ng-container rowOutlet/>
    <ng-container noDataRowOutlet/>
    <ng-container footerRowOutlet/>
  }
`
);
var _CdkTable = class _CdkTable {
  /** Aria role to apply to the table's cells based on the table's own role. */
  _getCellRole() {
    if (this._cellRoleInternal === void 0) {
      const role = this._elementRef.nativeElement.getAttribute("role");
      const cellRole = role === "grid" || role === "treegrid" ? "gridcell" : "cell";
      this._cellRoleInternal = this._isNativeHtmlTable && cellRole === "cell" ? null : cellRole;
    }
    return this._cellRoleInternal;
  }
  /**
   * Tracking function that will be used to check the differences in data changes. Used similarly
   * to `ngFor` `trackBy` function. Optimize row operations by identifying a row based on its data
   * relative to the function to know if a row should be added/removed/moved.
   * Accepts a function that takes two parameters, `index` and `item`.
   */
  get trackBy() {
    return this._trackByFn;
  }
  set trackBy(fn) {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && fn != null && typeof fn !== "function") {
      console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this._trackByFn = fn;
  }
  /**
   * The table's source of data, which can be provided in three ways (in order of complexity):
   *   - Simple data array (each object represents one table row)
   *   - Stream that emits a data array each time the array changes
   *   - `DataSource` object that implements the connect/disconnect interface.
   *
   * If a data array is provided, the table must be notified when the array's objects are
   * added, removed, or moved. This can be done by calling the `renderRows()` function which will
   * render the diff since the last table render. If the data array reference is changed, the table
   * will automatically trigger an update to the rows.
   *
   * When providing an Observable stream, the table will trigger an update automatically when the
   * stream emits a new array of data.
   *
   * Finally, when providing a `DataSource` object, the table will use the Observable stream
   * provided by the connect function and trigger updates when that stream emits new data array
   * values. During the table's ngOnDestroy or when the data source is removed from the table, the
   * table will call the DataSource's `disconnect` function (may be useful for cleaning up any
   * subscriptions registered during the connect process).
   */
  get dataSource() {
    return this._dataSource;
  }
  set dataSource(dataSource) {
    if (this._dataSource !== dataSource) {
      this._switchDataSource(dataSource);
    }
  }
  /**
   * Whether to allow multiple rows per data object by evaluating which rows evaluate their 'when'
   * predicate to true. If `multiTemplateDataRows` is false, which is the default value, then each
   * dataobject will render the first row that evaluates its when predicate to true, in the order
   * defined in the table, or otherwise the default row which does not have a when predicate.
   */
  get multiTemplateDataRows() {
    return this._multiTemplateDataRows;
  }
  set multiTemplateDataRows(value) {
    this._multiTemplateDataRows = value;
    if (this._rowOutlet && this._rowOutlet.viewContainer.length) {
      this._forceRenderDataRows();
      this.updateStickyColumnStyles();
    }
  }
  /**
   * Whether to use a fixed table layout. Enabling this option will enforce consistent column widths
   * and optimize rendering sticky styles for native tables. No-op for flex tables.
   */
  get fixedLayout() {
    return this._fixedLayout;
  }
  set fixedLayout(value) {
    this._fixedLayout = value;
    this._forceRecalculateCellWidths = true;
    this._stickyColumnStylesNeedReset = true;
  }
  constructor(_differs, _changeDetectorRef, _elementRef, role, _dir, _document, _platform, _viewRepeater, _coalescedStyleScheduler, _viewportRuler, _stickyPositioningListener, _ngZone) {
    this._differs = _differs;
    this._changeDetectorRef = _changeDetectorRef;
    this._elementRef = _elementRef;
    this._dir = _dir;
    this._platform = _platform;
    this._viewRepeater = _viewRepeater;
    this._coalescedStyleScheduler = _coalescedStyleScheduler;
    this._viewportRuler = _viewportRuler;
    this._stickyPositioningListener = _stickyPositioningListener;
    this._ngZone = _ngZone;
    this._onDestroy = new Subject();
    this._columnDefsByName = /* @__PURE__ */ new Map();
    this._customColumnDefs = /* @__PURE__ */ new Set();
    this._customRowDefs = /* @__PURE__ */ new Set();
    this._customHeaderRowDefs = /* @__PURE__ */ new Set();
    this._customFooterRowDefs = /* @__PURE__ */ new Set();
    this._headerRowDefChanged = true;
    this._footerRowDefChanged = true;
    this._stickyColumnStylesNeedReset = true;
    this._forceRecalculateCellWidths = true;
    this._cachedRenderRowsMap = /* @__PURE__ */ new Map();
    this.stickyCssClass = "cdk-table-sticky";
    this.needsPositionStickyOnElement = true;
    this._isShowingNoDataRow = false;
    this._hasAllOutlets = false;
    this._hasInitialized = false;
    this._cellRoleInternal = void 0;
    this._multiTemplateDataRows = false;
    this._fixedLayout = false;
    this.contentChanged = new EventEmitter();
    this.viewChange = new BehaviorSubject({
      start: 0,
      end: Number.MAX_VALUE
    });
    if (!role) {
      _elementRef.nativeElement.setAttribute("role", "table");
    }
    this._document = _document;
    this._isServer = !_platform.isBrowser;
    this._isNativeHtmlTable = _elementRef.nativeElement.nodeName === "TABLE";
  }
  ngOnInit() {
    this._setupStickyStyler();
    this._dataDiffer = this._differs.find([]).create((_i, dataRow) => {
      return this.trackBy ? this.trackBy(dataRow.dataIndex, dataRow.data) : dataRow;
    });
    this._viewportRuler.change().pipe(takeUntil(this._onDestroy)).subscribe(() => {
      this._forceRecalculateCellWidths = true;
    });
  }
  ngAfterContentInit() {
    this._hasInitialized = true;
  }
  ngAfterContentChecked() {
    if (this._canRender()) {
      this._render();
    }
  }
  ngOnDestroy() {
    [this._rowOutlet?.viewContainer, this._headerRowOutlet?.viewContainer, this._footerRowOutlet?.viewContainer, this._cachedRenderRowsMap, this._customColumnDefs, this._customRowDefs, this._customHeaderRowDefs, this._customFooterRowDefs, this._columnDefsByName].forEach((def) => {
      def?.clear();
    });
    this._headerRowDefs = [];
    this._footerRowDefs = [];
    this._defaultRowDef = null;
    this._onDestroy.next();
    this._onDestroy.complete();
    if (isDataSource(this.dataSource)) {
      this.dataSource.disconnect(this);
    }
  }
  /**
   * Renders rows based on the table's latest set of data, which was either provided directly as an
   * input or retrieved through an Observable stream (directly or from a DataSource).
   * Checks for differences in the data since the last diff to perform only the necessary
   * changes (add/remove/move rows).
   *
   * If the table's data source is a DataSource or Observable, this will be invoked automatically
   * each time the provided Observable stream emits a new data array. Otherwise if your data is
   * an array, this function will need to be called to render any changes.
   */
  renderRows() {
    this._renderRows = this._getAllRenderRows();
    const changes = this._dataDiffer.diff(this._renderRows);
    if (!changes) {
      this._updateNoDataRow();
      this.contentChanged.next();
      return;
    }
    const viewContainer = this._rowOutlet.viewContainer;
    this._viewRepeater.applyChanges(changes, viewContainer, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record.item, currentIndex), (record) => record.item.data, (change) => {
      if (change.operation === _ViewRepeaterOperation.INSERTED && change.context) {
        this._renderCellTemplateForItem(change.record.item.rowDef, change.context);
      }
    });
    this._updateRowIndexContext();
    changes.forEachIdentityChange((record) => {
      const rowView = viewContainer.get(record.currentIndex);
      rowView.context.$implicit = record.item.data;
    });
    this._updateNoDataRow();
    if (this._ngZone && NgZone.isInAngularZone()) {
      this._ngZone.onStable.pipe(take(1), takeUntil(this._onDestroy)).subscribe(() => {
        this.updateStickyColumnStyles();
      });
    } else {
      this.updateStickyColumnStyles();
    }
    this.contentChanged.next();
  }
  /** Adds a column definition that was not included as part of the content children. */
  addColumnDef(columnDef) {
    this._customColumnDefs.add(columnDef);
  }
  /** Removes a column definition that was not included as part of the content children. */
  removeColumnDef(columnDef) {
    this._customColumnDefs.delete(columnDef);
  }
  /** Adds a row definition that was not included as part of the content children. */
  addRowDef(rowDef) {
    this._customRowDefs.add(rowDef);
  }
  /** Removes a row definition that was not included as part of the content children. */
  removeRowDef(rowDef) {
    this._customRowDefs.delete(rowDef);
  }
  /** Adds a header row definition that was not included as part of the content children. */
  addHeaderRowDef(headerRowDef) {
    this._customHeaderRowDefs.add(headerRowDef);
    this._headerRowDefChanged = true;
  }
  /** Removes a header row definition that was not included as part of the content children. */
  removeHeaderRowDef(headerRowDef) {
    this._customHeaderRowDefs.delete(headerRowDef);
    this._headerRowDefChanged = true;
  }
  /** Adds a footer row definition that was not included as part of the content children. */
  addFooterRowDef(footerRowDef) {
    this._customFooterRowDefs.add(footerRowDef);
    this._footerRowDefChanged = true;
  }
  /** Removes a footer row definition that was not included as part of the content children. */
  removeFooterRowDef(footerRowDef) {
    this._customFooterRowDefs.delete(footerRowDef);
    this._footerRowDefChanged = true;
  }
  /** Sets a no data row definition that was not included as a part of the content children. */
  setNoDataRow(noDataRow) {
    this._customNoDataRow = noDataRow;
  }
  /**
   * Updates the header sticky styles. First resets all applied styles with respect to the cells
   * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is
   * automatically called when the header row changes its displayed set of columns, or if its
   * sticky input changes. May be called manually for cases where the cell content changes outside
   * of these events.
   */
  updateStickyHeaderRowStyles() {
    const headerRows = this._getRenderedRows(this._headerRowOutlet);
    if (this._isNativeHtmlTable) {
      const thead = closestTableSection(this._headerRowOutlet, "thead");
      if (thead) {
        thead.style.display = headerRows.length ? "" : "none";
      }
    }
    const stickyStates = this._headerRowDefs.map((def) => def.sticky);
    this._stickyStyler.clearStickyPositioning(headerRows, ["top"]);
    this._stickyStyler.stickRows(headerRows, stickyStates, "top");
    this._headerRowDefs.forEach((def) => def.resetStickyChanged());
  }
  /**
   * Updates the footer sticky styles. First resets all applied styles with respect to the cells
   * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is
   * automatically called when the footer row changes its displayed set of columns, or if its
   * sticky input changes. May be called manually for cases where the cell content changes outside
   * of these events.
   */
  updateStickyFooterRowStyles() {
    const footerRows = this._getRenderedRows(this._footerRowOutlet);
    if (this._isNativeHtmlTable) {
      const tfoot = closestTableSection(this._footerRowOutlet, "tfoot");
      if (tfoot) {
        tfoot.style.display = footerRows.length ? "" : "none";
      }
    }
    const stickyStates = this._footerRowDefs.map((def) => def.sticky);
    this._stickyStyler.clearStickyPositioning(footerRows, ["bottom"]);
    this._stickyStyler.stickRows(footerRows, stickyStates, "bottom");
    this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, stickyStates);
    this._footerRowDefs.forEach((def) => def.resetStickyChanged());
  }
  /**
   * Updates the column sticky styles. First resets all applied styles with respect to the cells
   * sticking to the left and right. Then sticky styles are added for the left and right according
   * to the column definitions for each cell in each row. This is automatically called when
   * the data source provides a new set of data or when a column definition changes its sticky
   * input. May be called manually for cases where the cell content changes outside of these events.
   */
  updateStickyColumnStyles() {
    const headerRows = this._getRenderedRows(this._headerRowOutlet);
    const dataRows = this._getRenderedRows(this._rowOutlet);
    const footerRows = this._getRenderedRows(this._footerRowOutlet);
    if (this._isNativeHtmlTable && !this._fixedLayout || this._stickyColumnStylesNeedReset) {
      this._stickyStyler.clearStickyPositioning([...headerRows, ...dataRows, ...footerRows], ["left", "right"]);
      this._stickyColumnStylesNeedReset = false;
    }
    headerRows.forEach((headerRow, i) => {
      this._addStickyColumnStyles([headerRow], this._headerRowDefs[i]);
    });
    this._rowDefs.forEach((rowDef) => {
      const rows = [];
      for (let i = 0; i < dataRows.length; i++) {
        if (this._renderRows[i].rowDef === rowDef) {
          rows.push(dataRows[i]);
        }
      }
      this._addStickyColumnStyles(rows, rowDef);
    });
    footerRows.forEach((footerRow, i) => {
      this._addStickyColumnStyles([footerRow], this._footerRowDefs[i]);
    });
    Array.from(this._columnDefsByName.values()).forEach((def) => def.resetStickyChanged());
  }
  /** Invoked whenever an outlet is created and has been assigned to the table. */
  _outletAssigned() {
    if (!this._hasAllOutlets && this._rowOutlet && this._headerRowOutlet && this._footerRowOutlet && this._noDataRowOutlet) {
      this._hasAllOutlets = true;
      if (this._canRender()) {
        this._render();
      }
    }
  }
  /** Whether the table has all the information to start rendering. */
  _canRender() {
    return this._hasAllOutlets && this._hasInitialized;
  }
  /** Renders the table if its state has changed. */
  _render() {
    this._cacheRowDefs();
    this._cacheColumnDefs();
    if (!this._headerRowDefs.length && !this._footerRowDefs.length && !this._rowDefs.length && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableMissingRowDefsError();
    }
    const columnsChanged = this._renderUpdatedColumns();
    const rowDefsChanged = columnsChanged || this._headerRowDefChanged || this._footerRowDefChanged;
    this._stickyColumnStylesNeedReset = this._stickyColumnStylesNeedReset || rowDefsChanged;
    this._forceRecalculateCellWidths = rowDefsChanged;
    if (this._headerRowDefChanged) {
      this._forceRenderHeaderRows();
      this._headerRowDefChanged = false;
    }
    if (this._footerRowDefChanged) {
      this._forceRenderFooterRows();
      this._footerRowDefChanged = false;
    }
    if (this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription) {
      this._observeRenderChanges();
    } else if (this._stickyColumnStylesNeedReset) {
      this.updateStickyColumnStyles();
    }
    this._checkStickyStates();
  }
  /**
   * Get the list of RenderRow objects to render according to the current list of data and defined
   * row definitions. If the previous list already contained a particular pair, it should be reused
   * so that the differ equates their references.
   */
  _getAllRenderRows() {
    const renderRows = [];
    const prevCachedRenderRows = this._cachedRenderRowsMap;
    this._cachedRenderRowsMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < this._data.length; i++) {
      let data = this._data[i];
      const renderRowsForData = this._getRenderRowsForData(data, i, prevCachedRenderRows.get(data));
      if (!this._cachedRenderRowsMap.has(data)) {
        this._cachedRenderRowsMap.set(data, /* @__PURE__ */ new WeakMap());
      }
      for (let j = 0; j < renderRowsForData.length; j++) {
        let renderRow = renderRowsForData[j];
        const cache = this._cachedRenderRowsMap.get(renderRow.data);
        if (cache.has(renderRow.rowDef)) {
          cache.get(renderRow.rowDef).push(renderRow);
        } else {
          cache.set(renderRow.rowDef, [renderRow]);
        }
        renderRows.push(renderRow);
      }
    }
    return renderRows;
  }
  /**
   * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that
   * should be rendered for this data. Reuses the cached RenderRow objects if they match the same
   * `(T, CdkRowDef)` pair.
   */
  _getRenderRowsForData(data, dataIndex, cache) {
    const rowDefs = this._getRowDefs(data, dataIndex);
    return rowDefs.map((rowDef) => {
      const cachedRenderRows = cache && cache.has(rowDef) ? cache.get(rowDef) : [];
      if (cachedRenderRows.length) {
        const dataRow = cachedRenderRows.shift();
        dataRow.dataIndex = dataIndex;
        return dataRow;
      } else {
        return {
          data,
          rowDef,
          dataIndex
        };
      }
    });
  }
  /** Update the map containing the content's column definitions. */
  _cacheColumnDefs() {
    this._columnDefsByName.clear();
    const columnDefs = mergeArrayAndSet(this._getOwnDefs(this._contentColumnDefs), this._customColumnDefs);
    columnDefs.forEach((columnDef) => {
      if (this._columnDefsByName.has(columnDef.name) && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw getTableDuplicateColumnNameError(columnDef.name);
      }
      this._columnDefsByName.set(columnDef.name, columnDef);
    });
  }
  /** Update the list of all available row definitions that can be used. */
  _cacheRowDefs() {
    this._headerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentHeaderRowDefs), this._customHeaderRowDefs);
    this._footerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentFooterRowDefs), this._customFooterRowDefs);
    this._rowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentRowDefs), this._customRowDefs);
    const defaultRowDefs = this._rowDefs.filter((def) => !def.when);
    if (!this.multiTemplateDataRows && defaultRowDefs.length > 1 && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableMultipleDefaultRowDefsError();
    }
    this._defaultRowDef = defaultRowDefs[0];
  }
  /**
   * Check if the header, data, or footer rows have changed what columns they want to display or
   * whether the sticky states have changed for the header or footer. If there is a diff, then
   * re-render that section.
   */
  _renderUpdatedColumns() {
    const columnsDiffReducer = (acc, def) => acc || !!def.getColumnsDiff();
    const dataColumnsChanged = this._rowDefs.reduce(columnsDiffReducer, false);
    if (dataColumnsChanged) {
      this._forceRenderDataRows();
    }
    const headerColumnsChanged = this._headerRowDefs.reduce(columnsDiffReducer, false);
    if (headerColumnsChanged) {
      this._forceRenderHeaderRows();
    }
    const footerColumnsChanged = this._footerRowDefs.reduce(columnsDiffReducer, false);
    if (footerColumnsChanged) {
      this._forceRenderFooterRows();
    }
    return dataColumnsChanged || headerColumnsChanged || footerColumnsChanged;
  }
  /**
   * Switch to the provided data source by resetting the data and unsubscribing from the current
   * render change subscription if one exists. If the data source is null, interpret this by
   * clearing the row outlet. Otherwise start listening for new data.
   */
  _switchDataSource(dataSource) {
    this._data = [];
    if (isDataSource(this.dataSource)) {
      this.dataSource.disconnect(this);
    }
    if (this._renderChangeSubscription) {
      this._renderChangeSubscription.unsubscribe();
      this._renderChangeSubscription = null;
    }
    if (!dataSource) {
      if (this._dataDiffer) {
        this._dataDiffer.diff([]);
      }
      if (this._rowOutlet) {
        this._rowOutlet.viewContainer.clear();
      }
    }
    this._dataSource = dataSource;
  }
  /** Set up a subscription for the data provided by the data source. */
  _observeRenderChanges() {
    if (!this.dataSource) {
      return;
    }
    let dataStream;
    if (isDataSource(this.dataSource)) {
      dataStream = this.dataSource.connect(this);
    } else if (isObservable(this.dataSource)) {
      dataStream = this.dataSource;
    } else if (Array.isArray(this.dataSource)) {
      dataStream = of(this.dataSource);
    }
    if (dataStream === void 0 && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableUnknownDataSourceError();
    }
    this._renderChangeSubscription = dataStream.pipe(takeUntil(this._onDestroy)).subscribe((data) => {
      this._data = data || [];
      this.renderRows();
    });
  }
  /**
   * Clears any existing content in the header row outlet and creates a new embedded view
   * in the outlet using the header row definition.
   */
  _forceRenderHeaderRows() {
    if (this._headerRowOutlet.viewContainer.length > 0) {
      this._headerRowOutlet.viewContainer.clear();
    }
    this._headerRowDefs.forEach((def, i) => this._renderRow(this._headerRowOutlet, def, i));
    this.updateStickyHeaderRowStyles();
  }
  /**
   * Clears any existing content in the footer row outlet and creates a new embedded view
   * in the outlet using the footer row definition.
   */
  _forceRenderFooterRows() {
    if (this._footerRowOutlet.viewContainer.length > 0) {
      this._footerRowOutlet.viewContainer.clear();
    }
    this._footerRowDefs.forEach((def, i) => this._renderRow(this._footerRowOutlet, def, i));
    this.updateStickyFooterRowStyles();
  }
  /** Adds the sticky column styles for the rows according to the columns' stick states. */
  _addStickyColumnStyles(rows, rowDef) {
    const columnDefs = Array.from(rowDef.columns || []).map((columnName) => {
      const columnDef = this._columnDefsByName.get(columnName);
      if (!columnDef && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw getTableUnknownColumnError(columnName);
      }
      return columnDef;
    });
    const stickyStartStates = columnDefs.map((columnDef) => columnDef.sticky);
    const stickyEndStates = columnDefs.map((columnDef) => columnDef.stickyEnd);
    this._stickyStyler.updateStickyColumns(rows, stickyStartStates, stickyEndStates, !this._fixedLayout || this._forceRecalculateCellWidths);
  }
  /** Gets the list of rows that have been rendered in the row outlet. */
  _getRenderedRows(rowOutlet) {
    const renderedRows = [];
    for (let i = 0; i < rowOutlet.viewContainer.length; i++) {
      const viewRef = rowOutlet.viewContainer.get(i);
      renderedRows.push(viewRef.rootNodes[0]);
    }
    return renderedRows;
  }
  /**
   * Get the matching row definitions that should be used for this row data. If there is only
   * one row definition, it is returned. Otherwise, find the row definitions that has a when
   * predicate that returns true with the data. If none return true, return the default row
   * definition.
   */
  _getRowDefs(data, dataIndex) {
    if (this._rowDefs.length == 1) {
      return [this._rowDefs[0]];
    }
    let rowDefs = [];
    if (this.multiTemplateDataRows) {
      rowDefs = this._rowDefs.filter((def) => !def.when || def.when(dataIndex, data));
    } else {
      let rowDef = this._rowDefs.find((def) => def.when && def.when(dataIndex, data)) || this._defaultRowDef;
      if (rowDef) {
        rowDefs.push(rowDef);
      }
    }
    if (!rowDefs.length && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableMissingMatchingRowDefError(data);
    }
    return rowDefs;
  }
  _getEmbeddedViewArgs(renderRow, index) {
    const rowDef = renderRow.rowDef;
    const context = {
      $implicit: renderRow.data
    };
    return {
      templateRef: rowDef.template,
      context,
      index
    };
  }
  /**
   * Creates a new row template in the outlet and fills it with the set of cell templates.
   * Optionally takes a context to provide to the row and cells, as well as an optional index
   * of where to place the new row template in the outlet.
   */
  _renderRow(outlet, rowDef, index, context = {}) {
    const view = outlet.viewContainer.createEmbeddedView(rowDef.template, context, index);
    this._renderCellTemplateForItem(rowDef, context);
    return view;
  }
  _renderCellTemplateForItem(rowDef, context) {
    for (let cellTemplate of this._getCellTemplates(rowDef)) {
      if (CdkCellOutlet.mostRecentCellOutlet) {
        CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cellTemplate, context);
      }
    }
    this._changeDetectorRef.markForCheck();
  }
  /**
   * Updates the index-related context for each row to reflect any changes in the index of the rows,
   * e.g. first/last/even/odd.
   */
  _updateRowIndexContext() {
    const viewContainer = this._rowOutlet.viewContainer;
    for (let renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {
      const viewRef = viewContainer.get(renderIndex);
      const context = viewRef.context;
      context.count = count;
      context.first = renderIndex === 0;
      context.last = renderIndex === count - 1;
      context.even = renderIndex % 2 === 0;
      context.odd = !context.even;
      if (this.multiTemplateDataRows) {
        context.dataIndex = this._renderRows[renderIndex].dataIndex;
        context.renderIndex = renderIndex;
      } else {
        context.index = this._renderRows[renderIndex].dataIndex;
      }
    }
  }
  /** Gets the column definitions for the provided row def. */
  _getCellTemplates(rowDef) {
    if (!rowDef || !rowDef.columns) {
      return [];
    }
    return Array.from(rowDef.columns, (columnId) => {
      const column = this._columnDefsByName.get(columnId);
      if (!column && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw getTableUnknownColumnError(columnId);
      }
      return rowDef.extractCellTemplate(column);
    });
  }
  /**
   * Forces a re-render of the data rows. Should be called in cases where there has been an input
   * change that affects the evaluation of which rows should be rendered, e.g. toggling
   * `multiTemplateDataRows` or adding/removing row definitions.
   */
  _forceRenderDataRows() {
    this._dataDiffer.diff([]);
    this._rowOutlet.viewContainer.clear();
    this.renderRows();
  }
  /**
   * Checks if there has been a change in sticky states since last check and applies the correct
   * sticky styles. Since checking resets the "dirty" state, this should only be performed once
   * during a change detection and after the inputs are settled (after content check).
   */
  _checkStickyStates() {
    const stickyCheckReducer = (acc, d) => {
      return acc || d.hasStickyChanged();
    };
    if (this._headerRowDefs.reduce(stickyCheckReducer, false)) {
      this.updateStickyHeaderRowStyles();
    }
    if (this._footerRowDefs.reduce(stickyCheckReducer, false)) {
      this.updateStickyFooterRowStyles();
    }
    if (Array.from(this._columnDefsByName.values()).reduce(stickyCheckReducer, false)) {
      this._stickyColumnStylesNeedReset = true;
      this.updateStickyColumnStyles();
    }
  }
  /**
   * Creates the sticky styler that will be used for sticky rows and columns. Listens
   * for directionality changes and provides the latest direction to the styler. Re-applies column
   * stickiness when directionality changes.
   */
  _setupStickyStyler() {
    const direction = this._dir ? this._dir.value : "ltr";
    this._stickyStyler = new StickyStyler(this._isNativeHtmlTable, this.stickyCssClass, direction, this._coalescedStyleScheduler, this._platform.isBrowser, this.needsPositionStickyOnElement, this._stickyPositioningListener);
    (this._dir ? this._dir.change : of()).pipe(takeUntil(this._onDestroy)).subscribe((value) => {
      this._stickyStyler.direction = value;
      this.updateStickyColumnStyles();
    });
  }
  /** Filters definitions that belong to this table from a QueryList. */
  _getOwnDefs(items) {
    return items.filter((item) => !item._table || item._table === this);
  }
  /** Creates or removes the no data row, depending on whether any data is being shown. */
  _updateNoDataRow() {
    const noDataRow = this._customNoDataRow || this._noDataRow;
    if (!noDataRow) {
      return;
    }
    const shouldShow = this._rowOutlet.viewContainer.length === 0;
    if (shouldShow === this._isShowingNoDataRow) {
      return;
    }
    const container = this._noDataRowOutlet.viewContainer;
    if (shouldShow) {
      const view = container.createEmbeddedView(noDataRow.templateRef);
      const rootNode = view.rootNodes[0];
      if (view.rootNodes.length === 1 && rootNode?.nodeType === this._document.ELEMENT_NODE) {
        rootNode.setAttribute("role", "row");
        rootNode.classList.add(noDataRow._contentClassName);
      }
    } else {
      container.clear();
    }
    this._isShowingNoDataRow = shouldShow;
    this._changeDetectorRef.markForCheck();
  }
};
_CdkTable.ɵfac = function CdkTable_Factory(t) {
  return new (t || _CdkTable)(ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵinjectAttribute("role"), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(Platform), ɵɵdirectiveInject(_VIEW_REPEATER_STRATEGY), ɵɵdirectiveInject(_COALESCED_STYLE_SCHEDULER), ɵɵdirectiveInject(ViewportRuler), ɵɵdirectiveInject(STICKY_POSITIONING_LISTENER, 12), ɵɵdirectiveInject(NgZone, 8));
};
_CdkTable.ɵcmp = ɵɵdefineComponent({
  type: _CdkTable,
  selectors: [["cdk-table"], ["table", "cdk-table", ""]],
  contentQueries: function CdkTable_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CdkNoDataRow, 5);
      ɵɵcontentQuery(dirIndex, CdkColumnDef, 5);
      ɵɵcontentQuery(dirIndex, CdkRowDef, 5);
      ɵɵcontentQuery(dirIndex, CdkHeaderRowDef, 5);
      ɵɵcontentQuery(dirIndex, CdkFooterRowDef, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._noDataRow = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._contentColumnDefs = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._contentRowDefs = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._contentHeaderRowDefs = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._contentFooterRowDefs = _t);
    }
  },
  hostAttrs: [1, "cdk-table"],
  hostVars: 2,
  hostBindings: function CdkTable_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cdk-table-fixed-layout", ctx.fixedLayout);
    }
  },
  inputs: {
    trackBy: "trackBy",
    dataSource: "dataSource",
    multiTemplateDataRows: [InputFlags.HasDecoratorInputTransform, "multiTemplateDataRows", "multiTemplateDataRows", booleanAttribute],
    fixedLayout: [InputFlags.HasDecoratorInputTransform, "fixedLayout", "fixedLayout", booleanAttribute]
  },
  outputs: {
    contentChanged: "contentChanged"
  },
  exportAs: ["cdkTable"],
  standalone: true,
  features: [ɵɵProvidersFeature([
    {
      provide: CDK_TABLE,
      useExisting: _CdkTable
    },
    {
      provide: _VIEW_REPEATER_STRATEGY,
      useClass: _DisposeViewRepeaterStrategy
    },
    {
      provide: _COALESCED_STYLE_SCHEDULER,
      useClass: _CoalescedStyleScheduler
    },
    // Prevent nested tables from seeing this table's StickyPositioningListener.
    {
      provide: STICKY_POSITIONING_LISTENER,
      useValue: null
    }
  ]), ɵɵInputTransformsFeature, ɵɵStandaloneFeature],
  ngContentSelectors: _c1,
  decls: 5,
  vars: 2,
  consts: [["role", "rowgroup"], ["headerRowOutlet", ""], ["rowOutlet", ""], ["noDataRowOutlet", ""], ["footerRowOutlet", ""]],
  template: function CdkTable_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c0);
      ɵɵprojection(0);
      ɵɵprojection(1, 1);
      ɵɵtemplate(2, CdkTable_Conditional_2_Template, 1, 0)(3, CdkTable_Conditional_3_Template, 7, 0)(4, CdkTable_Conditional_4_Template, 4, 0);
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵconditional(2, ctx._isServer ? 2 : -1);
      ɵɵadvance();
      ɵɵconditional(3, ctx._isNativeHtmlTable ? 3 : 4);
    }
  },
  dependencies: [HeaderRowOutlet, DataRowOutlet, NoDataRowOutlet, FooterRowOutlet],
  styles: [".cdk-table-fixed-layout{table-layout:fixed}"],
  encapsulation: 2
});
var CdkTable = _CdkTable;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTable, [{
    type: Component,
    args: [{
      selector: "cdk-table, table[cdk-table]",
      exportAs: "cdkTable",
      template: CDK_TABLE_TEMPLATE,
      host: {
        "class": "cdk-table",
        "[class.cdk-table-fixed-layout]": "fixedLayout"
      },
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.Default,
      providers: [
        {
          provide: CDK_TABLE,
          useExisting: CdkTable
        },
        {
          provide: _VIEW_REPEATER_STRATEGY,
          useClass: _DisposeViewRepeaterStrategy
        },
        {
          provide: _COALESCED_STYLE_SCHEDULER,
          useClass: _CoalescedStyleScheduler
        },
        // Prevent nested tables from seeing this table's StickyPositioningListener.
        {
          provide: STICKY_POSITIONING_LISTENER,
          useValue: null
        }
      ],
      standalone: true,
      imports: [HeaderRowOutlet, DataRowOutlet, NoDataRowOutlet, FooterRowOutlet],
      styles: [".cdk-table-fixed-layout{table-layout:fixed}"]
    }]
  }], () => [{
    type: IterableDiffers
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["role"]
    }]
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Platform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [_VIEW_REPEATER_STRATEGY]
    }]
  }, {
    type: _CoalescedStyleScheduler,
    decorators: [{
      type: Inject,
      args: [_COALESCED_STYLE_SCHEDULER]
    }]
  }, {
    type: ViewportRuler
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: SkipSelf
    }, {
      type: Inject,
      args: [STICKY_POSITIONING_LISTENER]
    }]
  }, {
    type: NgZone,
    decorators: [{
      type: Optional
    }]
  }], {
    trackBy: [{
      type: Input
    }],
    dataSource: [{
      type: Input
    }],
    multiTemplateDataRows: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    fixedLayout: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    contentChanged: [{
      type: Output
    }],
    _contentColumnDefs: [{
      type: ContentChildren,
      args: [CdkColumnDef, {
        descendants: true
      }]
    }],
    _contentRowDefs: [{
      type: ContentChildren,
      args: [CdkRowDef, {
        descendants: true
      }]
    }],
    _contentHeaderRowDefs: [{
      type: ContentChildren,
      args: [CdkHeaderRowDef, {
        descendants: true
      }]
    }],
    _contentFooterRowDefs: [{
      type: ContentChildren,
      args: [CdkFooterRowDef, {
        descendants: true
      }]
    }],
    _noDataRow: [{
      type: ContentChild,
      args: [CdkNoDataRow]
    }]
  });
})();
function mergeArrayAndSet(array, set) {
  return array.concat(Array.from(set));
}
function closestTableSection(outlet, section) {
  const uppercaseSection = section.toUpperCase();
  let current = outlet.viewContainer.element.nativeElement;
  while (current) {
    const nodeName = current.nodeType === 1 ? current.nodeName : null;
    if (nodeName === uppercaseSection) {
      return current;
    } else if (nodeName === "TABLE") {
      break;
    }
    current = current.parentNode;
  }
  return null;
}
var _CdkTextColumn = class _CdkTextColumn {
  /** Column name that should be used to reference this column. */
  get name() {
    return this._name;
  }
  set name(name) {
    this._name = name;
    this._syncColumnDefName();
  }
  constructor(_table, _options) {
    this._table = _table;
    this._options = _options;
    this.justify = "start";
    this._options = _options || {};
  }
  ngOnInit() {
    this._syncColumnDefName();
    if (this.headerText === void 0) {
      this.headerText = this._createDefaultHeaderText();
    }
    if (!this.dataAccessor) {
      this.dataAccessor = this._options.defaultDataAccessor || ((data, name) => data[name]);
    }
    if (this._table) {
      this.columnDef.cell = this.cell;
      this.columnDef.headerCell = this.headerCell;
      this._table.addColumnDef(this.columnDef);
    } else if (typeof ngDevMode === "undefined" || ngDevMode) {
      throw getTableTextColumnMissingParentTableError();
    }
  }
  ngOnDestroy() {
    if (this._table) {
      this._table.removeColumnDef(this.columnDef);
    }
  }
  /**
   * Creates a default header text. Use the options' header text transformation function if one
   * has been provided. Otherwise simply capitalize the column name.
   */
  _createDefaultHeaderText() {
    const name = this.name;
    if (!name && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTableTextColumnMissingNameError();
    }
    if (this._options && this._options.defaultHeaderTextTransform) {
      return this._options.defaultHeaderTextTransform(name);
    }
    return name[0].toUpperCase() + name.slice(1);
  }
  /** Synchronizes the column definition name with the text column name. */
  _syncColumnDefName() {
    if (this.columnDef) {
      this.columnDef.name = this.name;
    }
  }
};
_CdkTextColumn.ɵfac = function CdkTextColumn_Factory(t) {
  return new (t || _CdkTextColumn)(ɵɵdirectiveInject(CdkTable, 8), ɵɵdirectiveInject(TEXT_COLUMN_OPTIONS, 8));
};
_CdkTextColumn.ɵcmp = ɵɵdefineComponent({
  type: _CdkTextColumn,
  selectors: [["cdk-text-column"]],
  viewQuery: function CdkTextColumn_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(CdkColumnDef, 7);
      ɵɵviewQuery(CdkCellDef, 7);
      ɵɵviewQuery(CdkHeaderCellDef, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnDef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cell = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerCell = _t.first);
    }
  },
  inputs: {
    name: "name",
    headerText: "headerText",
    dataAccessor: "dataAccessor",
    justify: "justify"
  },
  standalone: true,
  features: [ɵɵStandaloneFeature],
  decls: 3,
  vars: 0,
  consts: [["cdkColumnDef", ""], ["cdk-header-cell", "", 3, "text-align", 4, "cdkHeaderCellDef"], ["cdk-cell", "", 3, "text-align", 4, "cdkCellDef"], ["cdk-header-cell", ""], ["cdk-cell", ""]],
  template: function CdkTextColumn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainerStart(0, 0);
      ɵɵtemplate(1, CdkTextColumn_th_1_Template, 2, 3, "th", 1)(2, CdkTextColumn_td_2_Template, 2, 3, "td", 2);
      ɵɵelementContainerEnd();
    }
  },
  dependencies: [CdkColumnDef, CdkHeaderCellDef, CdkHeaderCell, CdkCellDef, CdkCell],
  encapsulation: 2
});
var CdkTextColumn = _CdkTextColumn;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTextColumn, [{
    type: Component,
    args: [{
      selector: "cdk-text-column",
      template: `
    <ng-container cdkColumnDef>
      <th cdk-header-cell *cdkHeaderCellDef [style.text-align]="justify">
        {{headerText}}
      </th>
      <td cdk-cell *cdkCellDef="let data" [style.text-align]="justify">
        {{dataAccessor(data, name)}}
      </td>
    </ng-container>
  `,
      encapsulation: ViewEncapsulation$1.None,
      // Change detection is intentionally not set to OnPush. This component's template will be provided
      // to the table to be inserted into its view. This is problematic when change detection runs since
      // the bindings in this template will be evaluated _after_ the table's view is evaluated, which
      // mean's the template in the table's view will not have the updated value (and in fact will cause
      // an ExpressionChangedAfterItHasBeenCheckedError).
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default,
      standalone: true,
      imports: [CdkColumnDef, CdkHeaderCellDef, CdkHeaderCell, CdkCellDef, CdkCell]
    }]
  }], () => [{
    type: CdkTable,
    decorators: [{
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [TEXT_COLUMN_OPTIONS]
    }]
  }], {
    name: [{
      type: Input
    }],
    headerText: [{
      type: Input
    }],
    dataAccessor: [{
      type: Input
    }],
    justify: [{
      type: Input
    }],
    columnDef: [{
      type: ViewChild,
      args: [CdkColumnDef, {
        static: true
      }]
    }],
    cell: [{
      type: ViewChild,
      args: [CdkCellDef, {
        static: true
      }]
    }],
    headerCell: [{
      type: ViewChild,
      args: [CdkHeaderCellDef, {
        static: true
      }]
    }]
  });
})();
var EXPORTED_DECLARATIONS = [CdkTable, CdkRowDef, CdkCellDef, CdkCellOutlet, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, CdkCell, CdkRow, CdkHeaderCell, CdkFooterCell, CdkHeaderRow, CdkHeaderRowDef, CdkFooterRow, CdkFooterRowDef, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CdkTextColumn, CdkNoDataRow, CdkRecycleRows, NoDataRowOutlet];
var _CdkTableModule = class _CdkTableModule {
};
_CdkTableModule.ɵfac = function CdkTableModule_Factory(t) {
  return new (t || _CdkTableModule)();
};
_CdkTableModule.ɵmod = ɵɵdefineNgModule({
  type: _CdkTableModule,
  imports: [ScrollingModule, CdkTable, CdkRowDef, CdkCellDef, CdkCellOutlet, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, CdkCell, CdkRow, CdkHeaderCell, CdkFooterCell, CdkHeaderRow, CdkHeaderRowDef, CdkFooterRow, CdkFooterRowDef, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CdkTextColumn, CdkNoDataRow, CdkRecycleRows, NoDataRowOutlet],
  exports: [CdkTable, CdkRowDef, CdkCellDef, CdkCellOutlet, CdkHeaderCellDef, CdkFooterCellDef, CdkColumnDef, CdkCell, CdkRow, CdkHeaderCell, CdkFooterCell, CdkHeaderRow, CdkHeaderRowDef, CdkFooterRow, CdkFooterRowDef, DataRowOutlet, HeaderRowOutlet, FooterRowOutlet, CdkTextColumn, CdkNoDataRow, CdkRecycleRows, NoDataRowOutlet]
});
_CdkTableModule.ɵinj = ɵɵdefineInjector({
  imports: [ScrollingModule]
});
var CdkTableModule = _CdkTableModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTableModule, [{
    type: NgModule,
    args: [{
      exports: EXPORTED_DECLARATIONS,
      imports: [ScrollingModule, ...EXPORTED_DECLARATIONS]
    }]
  }], null, null);
})();

// node_modules/@nebular/theme/fesm2022/nebular-theme.mjs
function NbOverlayContainerComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.content);
  }
}
function NbOverlayContainerComponent_ng_template_1_Template(rf, ctx) {
}
var _c02 = ["*"];
var _c12 = [[["nb-card-header"]], [["nb-card-body"]], "*", [["nb-card-footer"]]];
var _c2 = ["nb-card-header", "nb-card-body", "*", "nb-card-footer"];
function NbRevealCardComponent_a_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 2);
    ɵɵlistener("click", function NbRevealCardComponent_a_3_Template_a_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggle());
    });
    ɵɵelement(1, "nb-icon", 3);
    ɵɵelementEnd();
  }
}
var _c3 = [[["nb-card-front"]], [["nb-card-back"]]];
var _c4 = ["nb-card-front", "nb-card-back"];
function NbFlipCardComponent_a_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 4);
    ɵɵlistener("click", function NbFlipCardComponent_a_3_Template_a_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.toggle());
    });
    ɵɵelement(1, "nb-icon", 5);
    ɵɵelementEnd();
  }
}
function NbFlipCardComponent_a_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 4);
    ɵɵlistener("click", function NbFlipCardComponent_a_6_Template_a_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.toggle());
    });
    ɵɵelement(1, "nb-icon", 5);
    ɵɵelementEnd();
  }
}
var _c5 = [[["nb-card"]]];
var _c6 = ["nb-card"];
var _c7 = ["nbButton", ""];
function NbCalendarPickerRowComponent_ng_template_0_Template(rf, ctx) {
}
function NbCalendarPickerComponent_nb_calendar_picker_row_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-calendar-picker-row", 1);
    ɵɵlistener("select", function NbCalendarPickerComponent_nb_calendar_picker_row_0_Template_nb_calendar_picker_row_select_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.select.emit($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r1 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("row", row_r1)("visibleDate", ctx_r0.visibleDate)("selectedValue", ctx_r0.selectedValue)("component", ctx_r0.cellComponent)("min", ctx_r0.min)("max", ctx_r0.max)("filter", ctx_r0.filter)("size", ctx_r0.size);
  }
}
function NbCalendarDaysNamesComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const day_r1 = ctx.$implicit;
    ɵɵclassProp("holiday", day_r1.isHoliday);
    ɵɵadvance();
    ɵɵtextInterpolate(day_r1.name);
  }
}
function NbCalendarWeekNumberComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const weekNumber_r1 = ctx.$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(weekNumber_r1);
  }
}
var _c8 = "\n\n\n\n\n[_nghost-%COMP%]{display:flex;flex-direction:column}";
function NbCalendarDayPickerComponent_nb_calendar_week_numbers_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-calendar-week-numbers", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("weeks", ctx_r0.weeks)("size", ctx_r0.size)("weekNumberSymbol", ctx_r0.weekNumberSymbol);
  }
}
function NbBaseCalendarComponent_nb_card_header_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-card-header", 5)(1, "nb-calendar-view-mode", 6);
    ɵɵlistener("changeMode", function NbBaseCalendarComponent_nb_card_header_1_Template_nb_calendar_view_mode_changeMode_1_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.onChangeViewMode());
    });
    ɵɵelementEnd();
    ɵɵelementStart(2, "nb-calendar-pageable-navigation", 7);
    ɵɵlistener("prev", function NbBaseCalendarComponent_nb_card_header_1_Template_nb_calendar_pageable_navigation_prev_2_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r6 = ɵɵnextContext();
      return ɵɵresetView(ctx_r6.navigatePrev());
    })("next", function NbBaseCalendarComponent_nb_card_header_1_Template_nb_calendar_pageable_navigation_next_2_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r7 = ɵɵnextContext();
      return ɵɵresetView(ctx_r7.navigateNext());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("date", ctx_r0.visibleDate)("viewMode", ctx_r0.activeViewMode);
  }
}
function NbBaseCalendarComponent_nb_calendar_day_picker_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-calendar-day-picker", 8);
    ɵɵlistener("dateChange", function NbBaseCalendarComponent_nb_calendar_day_picker_3_Template_nb_calendar_day_picker_dateChange_0_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r8 = ɵɵnextContext();
      return ɵɵresetView(ctx_r8.dateChange.emit($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("boundingMonths", ctx_r1.boundingMonth)("cellComponent", ctx_r1.dayCellComponent)("min", ctx_r1.min)("max", ctx_r1.max)("filter", ctx_r1.filter)("visibleDate", ctx_r1.visibleDate)("size", ctx_r1.size)("date", ctx_r1.date)("showWeekNumber", ctx_r1.showWeekNumber)("firstDayOfWeek", ctx_r1.firstDayOfWeek)("weekNumberSymbol", ctx_r1.weekNumberSymbol);
  }
}
function NbBaseCalendarComponent_nb_calendar_year_picker_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-calendar-year-picker", 9);
    ɵɵlistener("yearChange", function NbBaseCalendarComponent_nb_calendar_year_picker_4_Template_nb_calendar_year_picker_yearChange_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r10 = ɵɵnextContext();
      ctx_r10.setVisibleDate($event);
      return ɵɵresetView(ctx_r10.setViewMode(ctx_r10.ViewMode.MONTH));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("cellComponent", ctx_r2.yearCellComponent)("date", ctx_r2.date)("min", ctx_r2.min)("max", ctx_r2.max)("filter", ctx_r2.filter)("size", ctx_r2.size)("year", ctx_r2.visibleDate);
  }
}
function NbBaseCalendarComponent_nb_calendar_month_picker_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-calendar-month-picker", 10);
    ɵɵlistener("monthChange", function NbBaseCalendarComponent_nb_calendar_month_picker_5_Template_nb_calendar_month_picker_monthChange_0_listener($event) {
      ɵɵrestoreView(_r13);
      const ctx_r12 = ɵɵnextContext();
      ctx_r12.setVisibleDate($event);
      return ɵɵresetView(ctx_r12.setViewMode(ctx_r12.ViewMode.DATE));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("cellComponent", ctx_r3.monthCellComponent)("min", ctx_r3.min)("max", ctx_r3.max)("filter", ctx_r3.filter)("size", ctx_r3.size)("month", ctx_r3.visibleDate)("date", ctx_r3.date);
  }
}
function NbCalendarActionsComponent_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 2);
    ɵɵlistener("click", function NbCalendarActionsComponent_button_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.setCurrentTime.emit());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.currentTimeText, "");
  }
}
var _c9 = [[["nb-list-item"]]];
var _c10 = ["nb-list-item"];
var _c11 = ["valueContainer"];
function NbTimePickerComponent_nb_card_0_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 8);
    ɵɵtext(2, "Time");
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_3_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r8 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r8.secondsText);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_3_div_5_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r10 = ɵɵnextContext(4);
    ɵɵtextInterpolate(ctx_r10.ampmText);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_3_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵtemplate(1, NbTimePickerComponent_nb_card_0_ng_template_3_div_5_ng_template_1_Template, 1, 1, "ng-template", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r9 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r9.showAmPmLabel);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
    ɵɵelementStart(2, "div", 8);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, NbTimePickerComponent_nb_card_0_ng_template_3_div_4_Template, 2, 1, "div", 9)(5, NbTimePickerComponent_nb_card_0_ng_template_3_div_5_Template, 2, 1, "div", 9);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.hoursText);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r2.minutesText);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.withSeconds);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.twelveHoursFormat);
  }
}
function NbTimePickerComponent_nb_card_0_ng_container_6_nb_list_item_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-list-item", 13)(1, "nb-timepicker-cell", 14);
    ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_container_6_nb_list_item_2_Template_nb_timepicker_cell_select_1_listener() {
      const restoredCtx = ɵɵrestoreView(_r14);
      const item_r12 = restoredCtx.$implicit;
      const ctx_r13 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r13.selectFullTime(item_r12));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r12 = ctx.$implicit;
    const ctx_r11 = ɵɵnextContext(3);
    ɵɵclassProp("selected", ctx_r11.isSelectedFullTimeValue(item_r12));
    ɵɵadvance();
    ɵɵproperty("value", ctx_r11.getFullTimeString(item_r12))("selected", ctx_r11.isSelectedFullTimeValue(item_r12));
  }
}
function NbTimePickerComponent_nb_card_0_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "nb-list", 11);
    ɵɵtemplate(2, NbTimePickerComponent_nb_card_0_ng_container_6_nb_list_item_2_Template, 2, 4, "nb-list-item", 12);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r4.fullTimeOptions)("ngForTrackBy", ctx_r4.trackBySingleColumnValue.bind(ctx_r4));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r21 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-list-item", 13)(1, "nb-timepicker-cell", 14);
    ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_1_Template_nb_timepicker_cell_select_1_listener() {
      const restoredCtx = ɵɵrestoreView(_r21);
      const item_r19 = restoredCtx.$implicit;
      const ctx_r20 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r20.setHour(item_r19.value));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r19 = ctx.$implicit;
    const ctx_r15 = ɵɵnextContext(3);
    ɵɵclassProp("selected", ctx_r15.isSelectedHour(item_r19.value));
    ɵɵadvance();
    ɵɵproperty("value", item_r19.text)("selected", ctx_r15.isSelectedHour(item_r19.value));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r24 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-list-item", 13)(1, "nb-timepicker-cell", 14);
    ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_3_Template_nb_timepicker_cell_select_1_listener() {
      const restoredCtx = ɵɵrestoreView(_r24);
      const item_r22 = restoredCtx.$implicit;
      const ctx_r23 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r23.setMinute(item_r22.value));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r22 = ctx.$implicit;
    const ctx_r16 = ɵɵnextContext(3);
    ɵɵclassProp("selected", ctx_r16.isSelectedMinute(item_r22.value));
    ɵɵadvance();
    ɵɵproperty("value", item_r22.text)("selected", ctx_r16.isSelectedMinute(item_r22.value));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_nb_list_item_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r28 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-list-item", 13)(1, "nb-timepicker-cell", 14);
    ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_nb_list_item_1_Template_nb_timepicker_cell_select_1_listener() {
      const restoredCtx = ɵɵrestoreView(_r28);
      const item_r26 = restoredCtx.$implicit;
      const ctx_r27 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r27.setSecond(item_r26.value));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const item_r26 = ctx.$implicit;
    const ctx_r25 = ɵɵnextContext(4);
    ɵɵclassProp("selected", ctx_r25.isSelectedSecond(item_r26.value));
    ɵɵadvance();
    ɵɵproperty("value", item_r26.text)("selected", ctx_r25.isSelectedSecond(item_r26.value));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-list", 11);
    ɵɵtemplate(1, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_nb_list_item_1_Template, 2, 4, "nb-list-item", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r17 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r17.secondsColumnOptions)("ngForTrackBy", ctx_r17.trackByTimeValues);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_nb_list_item_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r32 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-list-item", 17)(1, "nb-timepicker-cell", 14);
    ɵɵlistener("select", function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_nb_list_item_1_Template_nb_timepicker_cell_select_1_listener() {
      const restoredCtx = ɵɵrestoreView(_r32);
      const dayPeriod_r30 = restoredCtx.$implicit;
      const ctx_r31 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r31.changeDayPeriod(dayPeriod_r30));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const dayPeriod_r30 = ctx.$implicit;
    const ctx_r29 = ɵɵnextContext(4);
    ɵɵclassProp("selected", ctx_r29.isSelectedDayPeriod(dayPeriod_r30));
    ɵɵadvance();
    ɵɵproperty("value", dayPeriod_r30)("selected", ctx_r29.isSelectedDayPeriod(dayPeriod_r30));
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-list", 11);
    ɵɵtemplate(1, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_nb_list_item_1_Template, 2, 4, "nb-list-item", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r18 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r18.dayPeriodColumnOptions)("ngForTrackBy", ctx_r18.trackByDayPeriod);
  }
}
function NbTimePickerComponent_nb_card_0_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-list", 11);
    ɵɵtemplate(1, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_1_Template, 2, 4, "nb-list-item", 12);
    ɵɵelementEnd();
    ɵɵelementStart(2, "nb-list", 11);
    ɵɵtemplate(3, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_item_3_Template, 2, 4, "nb-list-item", 12);
    ɵɵelementEnd();
    ɵɵtemplate(4, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_4_Template, 2, 2, "nb-list", 15)(5, NbTimePickerComponent_nb_card_0_ng_template_7_nb_list_5_Template, 2, 2, "nb-list", 15);
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r5.hoursColumnOptions)("ngForTrackBy", ctx_r5.trackByTimeValues);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r5.minutesColumnOptions)("ngForTrackBy", ctx_r5.trackByTimeValues);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5.showSeconds());
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5.twelveHoursFormat);
  }
}
function NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r34 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-card-footer", 18)(1, "nb-calendar-actions", 19);
    ɵɵlistener("setCurrentTime", function NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template_nb_calendar_actions_setCurrentTime_1_listener() {
      ɵɵrestoreView(_r34);
      const ctx_r33 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r33.setCurrentTime());
    })("saveValue", function NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template_nb_calendar_actions_saveValue_1_listener() {
      ɵɵrestoreView(_r34);
      const ctx_r35 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r35.saveValue());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r7 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("applyButtonText", ctx_r7.applyButtonText)("currentTimeButtonText", ctx_r7.currentTimeButtonText);
  }
}
function NbTimePickerComponent_nb_card_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-card", 1)(1, "nb-card-header", 2);
    ɵɵtemplate(2, NbTimePickerComponent_nb_card_0_ng_container_2_Template, 3, 0, "ng-container", 3)(3, NbTimePickerComponent_nb_card_0_ng_template_3_Template, 6, 4, "ng-template", null, 4, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 5);
    ɵɵtemplate(6, NbTimePickerComponent_nb_card_0_ng_container_6_Template, 3, 2, "ng-container", 3)(7, NbTimePickerComponent_nb_card_0_ng_template_7_Template, 6, 6, "ng-template", null, 6, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
    ɵɵtemplate(9, NbTimePickerComponent_nb_card_0_nb_card_footer_9_Template, 2, 2, "nb-card-footer", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const _r3 = ɵɵreference(4);
    const _r6 = ɵɵreference(8);
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("supports-scrollbar-theming", !ctx_r0.isFirefox());
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.singleColumn)("ngIfElse", _r3);
    ɵɵadvance(4);
    ɵɵproperty("ngIf", ctx_r0.singleColumn)("ngIfElse", _r6);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r0.showFooter);
  }
}
var _c122 = ["layoutTopDynamicArea"];
var _c13 = ["scrollableContainer"];
var _c14 = ["layoutContainer"];
var _c15 = [[["nb-layout-header", 3, "subheader", ""]], [["nb-sidebar"]], [["nb-layout-header", "subheader", ""]], [["nb-layout-column"]], [["nb-layout-footer"]]];
var _c16 = ["nb-layout-header:not([subheader])", "nb-sidebar", "nb-layout-header[subheader]", "nb-layout-column", "nb-layout-footer"];
var _c17 = ["nbMenuItem", ""];
function NbMenuItemComponent_span_0_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r8 = ɵɵnextContext(2);
    ɵɵproperty("config", ctx_r8.menuItem.icon);
  }
}
function NbMenuItemComponent_span_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtemplate(1, NbMenuItemComponent_span_0_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.menuItem.icon);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.menuItem.title, "\n");
  }
}
function NbMenuItemComponent_a_1_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r9 = ɵɵnextContext(2);
    ɵɵproperty("config", ctx_r9.menuItem.icon);
  }
}
function NbMenuItemComponent_a_1_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 11);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const _r7 = ɵɵreference(7);
    ɵɵproperty("ngTemplateOutlet", _r7);
  }
}
function NbMenuItemComponent_a_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 8);
    ɵɵlistener("mouseenter", function NbMenuItemComponent_a_1_Template_a_mouseenter_0_listener() {
      ɵɵrestoreView(_r12);
      const ctx_r11 = ɵɵnextContext();
      return ɵɵresetView(ctx_r11.onHoverItem(ctx_r11.menuItem));
    })("click", function NbMenuItemComponent_a_1_Template_a_click_0_listener() {
      ɵɵrestoreView(_r12);
      const ctx_r13 = ɵɵnextContext();
      return ɵɵresetView(ctx_r13.onItemClick(ctx_r13.menuItem));
    });
    ɵɵtemplate(1, NbMenuItemComponent_a_1_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵɵelementStart(2, "span", 9);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, NbMenuItemComponent_a_1_ng_container_4_Template, 1, 1, "ng-container", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("active", ctx_r1.menuItem.selected);
    ɵɵproperty("routerLink", ctx_r1.menuItem.link)("queryParams", ctx_r1.menuItem.queryParams)("fragment", ctx_r1.menuItem.fragment)("queryParamsHandling", ctx_r1.menuItem.queryParamsHandling)("preserveFragment", ctx_r1.menuItem.preserveFragment)("skipLocationChange", ctx_r1.menuItem.skipLocationChange);
    ɵɵattribute("target", ctx_r1.menuItem.target)("title", ctx_r1.menuItem.title)("role", ctx_r1.menuItem.ariaRole);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.menuItem.icon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.menuItem.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.badge);
  }
}
function NbMenuItemComponent_a_2_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r14 = ɵɵnextContext(2);
    ɵɵproperty("config", ctx_r14.menuItem.icon);
  }
}
function NbMenuItemComponent_a_2_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 11);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const _r7 = ɵɵreference(7);
    ɵɵproperty("ngTemplateOutlet", _r7);
  }
}
function NbMenuItemComponent_a_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 12);
    ɵɵlistener("mouseenter", function NbMenuItemComponent_a_2_Template_a_mouseenter_0_listener() {
      ɵɵrestoreView(_r17);
      const ctx_r16 = ɵɵnextContext();
      return ɵɵresetView(ctx_r16.onHoverItem(ctx_r16.menuItem));
    })("click", function NbMenuItemComponent_a_2_Template_a_click_0_listener() {
      ɵɵrestoreView(_r17);
      const ctx_r18 = ɵɵnextContext();
      return ɵɵresetView(ctx_r18.onSelectItem(ctx_r18.menuItem));
    });
    ɵɵtemplate(1, NbMenuItemComponent_a_2_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵɵelementStart(2, "span", 9);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, NbMenuItemComponent_a_2_ng_container_4_Template, 1, 1, "ng-container", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("active", ctx_r2.menuItem.selected);
    ɵɵattribute("href", ctx_r2.menuItem.url, ɵɵsanitizeUrl)("target", ctx_r2.menuItem.target)("title", ctx_r2.menuItem.title)("role", ctx_r2.menuItem.ariaRole);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.menuItem.icon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r2.menuItem.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.badge);
  }
}
function NbMenuItemComponent_a_3_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r19 = ɵɵnextContext(2);
    ɵɵproperty("config", ctx_r19.menuItem.icon);
  }
}
function NbMenuItemComponent_a_3_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 11);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const _r7 = ɵɵreference(7);
    ɵɵproperty("ngTemplateOutlet", _r7);
  }
}
function NbMenuItemComponent_a_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r22 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 12);
    ɵɵlistener("mouseenter", function NbMenuItemComponent_a_3_Template_a_mouseenter_0_listener() {
      ɵɵrestoreView(_r22);
      const ctx_r21 = ɵɵnextContext();
      return ɵɵresetView(ctx_r21.onHoverItem(ctx_r21.menuItem));
    })("click", function NbMenuItemComponent_a_3_Template_a_click_0_listener($event) {
      ɵɵrestoreView(_r22);
      const ctx_r23 = ɵɵnextContext();
      $event.preventDefault();
      return ɵɵresetView(ctx_r23.onItemClick(ctx_r23.menuItem));
    });
    ɵɵtemplate(1, NbMenuItemComponent_a_3_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵɵelementStart(2, "span", 9);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, NbMenuItemComponent_a_3_ng_container_4_Template, 1, 1, "ng-container", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵclassProp("active", ctx_r3.menuItem.selected);
    ɵɵattribute("target", ctx_r3.menuItem.target)("title", ctx_r3.menuItem.title)("role", ctx_r3.menuItem.ariaRole);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r3.menuItem.icon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r3.menuItem.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r3.badge);
  }
}
function NbMenuItemComponent_a_4_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r24 = ɵɵnextContext(2);
    ɵɵproperty("config", ctx_r24.menuItem.icon);
  }
}
function NbMenuItemComponent_a_4_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 11);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const _r7 = ɵɵreference(7);
    ɵɵproperty("ngTemplateOutlet", _r7);
  }
}
function NbMenuItemComponent_a_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r27 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "a", 13);
    ɵɵlistener("click", function NbMenuItemComponent_a_4_Template_a_click_0_listener($event) {
      ɵɵrestoreView(_r27);
      const ctx_r26 = ɵɵnextContext();
      $event.preventDefault();
      return ɵɵresetView(ctx_r26.onToggleSubMenu(ctx_r26.menuItem));
    })("mouseenter", function NbMenuItemComponent_a_4_Template_a_mouseenter_0_listener() {
      ɵɵrestoreView(_r27);
      const ctx_r28 = ɵɵnextContext();
      return ɵɵresetView(ctx_r28.onHoverItem(ctx_r28.menuItem));
    });
    ɵɵtemplate(1, NbMenuItemComponent_a_4_nb_icon_1_Template, 1, 1, "nb-icon", 6);
    ɵɵelementStart(2, "span", 9);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, NbMenuItemComponent_a_4_ng_container_4_Template, 1, 1, "ng-container", 10);
    ɵɵelement(5, "nb-icon", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    let tmp_3_0;
    ɵɵclassProp("active", ctx_r4.menuItem.selected);
    ɵɵattribute("target", ctx_r4.menuItem.target)("title", ctx_r4.menuItem.title)("aria-expanded", (tmp_3_0 = ctx_r4.menuItem.expanded) !== null && tmp_3_0 !== void 0 ? tmp_3_0 : false)("role", ctx_r4.menuItem.ariaRole);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.menuItem.icon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r4.menuItem.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.badge);
    ɵɵadvance();
    ɵɵproperty("icon", ctx_r4.getExpandStateIcon());
  }
}
function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r33 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 18);
    ɵɵlistener("hoverItem", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_hoverItem_0_listener($event) {
      ɵɵrestoreView(_r33);
      const ctx_r32 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r32.onHoverItem($event));
    })("toggleSubMenu", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_toggleSubMenu_0_listener($event) {
      ɵɵrestoreView(_r33);
      const ctx_r34 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r34.onToggleSubMenu($event));
    })("selectItem", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_selectItem_0_listener($event) {
      ɵɵrestoreView(_r33);
      const ctx_r35 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r35.onSelectItem($event));
    })("itemClick", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_itemClick_0_listener($event) {
      ɵɵrestoreView(_r33);
      const ctx_r36 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r36.onItemClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r30 = ɵɵnextContext().$implicit;
    ɵɵclassProp("menu-group", item_r30.group);
    ɵɵproperty("menuItem", item_r30)("badge", item_r30.badge);
  }
}
function NbMenuItemComponent_ul_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbMenuItemComponent_ul_5_ng_container_1_li_1_Template, 1, 4, "li", 17);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r30 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", !item_r30.hidden);
  }
}
function NbMenuItemComponent_ul_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "ul", 15);
    ɵɵtemplate(1, NbMenuItemComponent_ul_5_ng_container_1_Template, 2, 1, "ng-container", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassProp("collapsed", !(ctx_r5.menuItem.children && ctx_r5.menuItem.expanded))("expanded", ctx_r5.menuItem.expanded);
    ɵɵproperty("@toggle", ctx_r5.toggleState);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r5.menuItem.children);
  }
}
function NbMenuItemComponent_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-badge", 19);
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext();
    ɵɵproperty("text", ctx_r6.badge.text)("dotMode", ctx_r6.badge.dotMode)("status", ctx_r6.badge.status);
  }
}
function NbMenuComponent_ng_container_1_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 3);
    ɵɵlistener("hoverItem", function NbMenuComponent_ng_container_1_li_1_Template_li_hoverItem_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.onHoverItem($event));
    })("toggleSubMenu", function NbMenuComponent_ng_container_1_li_1_Template_li_toggleSubMenu_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r5 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r5.onToggleSubMenu($event));
    })("selectItem", function NbMenuComponent_ng_container_1_li_1_Template_li_selectItem_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r6 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r6.onSelectItem($event));
    })("itemClick", function NbMenuComponent_ng_container_1_li_1_Template_li_itemClick_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r7 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r7.onItemClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r1 = ɵɵnextContext().$implicit;
    ɵɵclassProp("menu-group", item_r1.group);
    ɵɵproperty("menuItem", item_r1)("badge", item_r1.badge);
  }
}
function NbMenuComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbMenuComponent_ng_container_1_li_1_Template, 1, 4, "li", 2);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", !item_r1.hidden);
  }
}
function NbRouteTabsetComponent_ng_container_1_li_1_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 8);
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext(2).$implicit;
    ɵɵproperty("config", tab_r1.icon);
  }
}
function NbRouteTabsetComponent_ng_container_1_li_1_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext(2).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(tab_r1.title);
  }
}
function NbRouteTabsetComponent_ng_container_1_li_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 4)(1, "a", 5);
    ɵɵtemplate(2, NbRouteTabsetComponent_ng_container_1_li_1_nb_icon_2_Template, 1, 1, "nb-icon", 6)(3, NbRouteTabsetComponent_ng_container_1_li_1_span_3_Template, 2, 1, "span", 7);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext().$implicit;
    ɵɵclassProp("responsive", tab_r1.responsive);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", tab_r1.icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", tab_r1.title);
  }
}
function NbRouteTabsetComponent_ng_container_1_ng_template_2_nb_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 8);
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext(2).$implicit;
    ɵɵproperty("config", tab_r1.icon);
  }
}
function NbRouteTabsetComponent_ng_container_1_ng_template_2_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext(2).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(tab_r1.title);
  }
}
function NbRouteTabsetComponent_ng_container_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 10);
    ɵɵpipe(1, "nbMergeConfigs");
    ɵɵelementStart(2, "a", 11);
    ɵɵlistener("click", function NbRouteTabsetComponent_ng_container_1_ng_template_2_Template_a_click_2_listener() {
      ɵɵrestoreView(_r16);
      const tab_r1 = ɵɵnextContext().$implicit;
      const ctx_r14 = ɵɵnextContext();
      return ɵɵresetView(ctx_r14.selectTab(tab_r1));
    });
    ɵɵtemplate(3, NbRouteTabsetComponent_ng_container_1_ng_template_2_nb_icon_3_Template, 1, 1, "nb-icon", 6)(4, NbRouteTabsetComponent_ng_container_1_ng_template_2_span_4_Template, 2, 1, "span", 7);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext().$implicit;
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("routerLinkActiveOptions", ɵɵpipeBind2(1, 13, ctx_r3.activeLinkOptions, tab_r1.activeLinkOptions));
    ɵɵadvance(2);
    ɵɵclassProp("responsive", tab_r1.responsive);
    ɵɵproperty("routerLink", tab_r1.route)("queryParams", tab_r1.queryParams)("queryParamsHandling", tab_r1.queryParamsHandling)("fragment", tab_r1.fragment)("preserveFragment", tab_r1.preserveFragment)("skipLocationChange", tab_r1.skipLocationChange)("replaceUrl", tab_r1.replaceUrl)("state", tab_r1.state);
    ɵɵadvance();
    ɵɵproperty("ngIf", tab_r1.icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", tab_r1.title);
  }
}
function NbRouteTabsetComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbRouteTabsetComponent_ng_container_1_li_1_Template, 4, 4, "li", 2)(2, NbRouteTabsetComponent_ng_container_1_ng_template_2_Template, 5, 16, "ng-template", null, 3, ɵɵtemplateRefExtractor);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const tab_r1 = ctx.$implicit;
    const _r4 = ɵɵreference(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", tab_r1.disabled)("ngIfElse", _r4);
  }
}
var _c18 = [[["nb-sidebar-header"]], "*", [["nb-sidebar-footer"]]];
var _c19 = ["nb-sidebar-header", "*", "nb-sidebar-footer"];
function NbTabComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.tabContentDirective.templateRef);
  }
}
function NbTabComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function NbTabsetComponent_li_1_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 8);
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext().$implicit;
    ɵɵproperty("config", tab_r1.tabIcon);
  }
}
function NbTabsetComponent_li_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 9);
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngTemplateOutlet", tab_r1.tabTitleDirective.templateRef);
  }
}
function NbTabsetComponent_li_1_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(tab_r1.tabTitle);
  }
}
function NbTabsetComponent_li_1_nb_badge_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-badge", 11);
  }
  if (rf & 2) {
    const tab_r1 = ɵɵnextContext().$implicit;
    ɵɵproperty("text", tab_r1.badgeText)("dotMode", tab_r1.badgeDot)("status", tab_r1.badgeStatus)("position", tab_r1.badgePosition);
  }
}
function NbTabsetComponent_li_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li", 2);
    ɵɵlistener("click", function NbTabsetComponent_li_1_Template_li_click_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r12);
      const tab_r1 = restoredCtx.$implicit;
      const ctx_r11 = ɵɵnextContext();
      return ɵɵresetView(ctx_r11.selectTab(tab_r1));
    })("keyup.space", function NbTabsetComponent_li_1_Template_li_keyup_space_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r12);
      const tab_r1 = restoredCtx.$implicit;
      const ctx_r13 = ɵɵnextContext();
      return ɵɵresetView(ctx_r13.selectTab(tab_r1));
    })("keyup.enter", function NbTabsetComponent_li_1_Template_li_keyup_enter_0_listener() {
      const restoredCtx = ɵɵrestoreView(_r12);
      const tab_r1 = restoredCtx.$implicit;
      const ctx_r14 = ɵɵnextContext();
      return ɵɵresetView(ctx_r14.selectTab(tab_r1));
    });
    ɵɵelementStart(1, "a", 3);
    ɵɵlistener("click", function NbTabsetComponent_li_1_Template_a_click_1_listener($event) {
      return $event.preventDefault();
    });
    ɵɵtemplate(2, NbTabsetComponent_li_1_nb_icon_2_Template, 1, 1, "nb-icon", 4)(3, NbTabsetComponent_li_1_ng_container_3_Template, 1, 1, "ng-container", 5)(4, NbTabsetComponent_li_1_ng_template_4_Template, 2, 1, "ng-template", null, 6, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
    ɵɵtemplate(6, NbTabsetComponent_li_1_nb_badge_6_Template, 1, 4, "nb-badge", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tab_r1 = ctx.$implicit;
    const _r5 = ɵɵreference(5);
    ɵɵclassProp("responsive", tab_r1.responsive)("active", tab_r1.active)("disabled", tab_r1.disabled);
    ɵɵattribute("tabindex", tab_r1.disabled ? -1 : 0)("data-tab-id", tab_r1.tabId);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", tab_r1.tabIcon);
    ɵɵadvance();
    ɵɵproperty("ngIf", tab_r1.tabTitleDirective)("ngIfElse", _r5);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", tab_r1.badgeText || tab_r1.badgeDot);
  }
}
var _c20 = [[["nb-tab"]]];
var _c21 = ["nb-tab"];
function NbUserComponent_div_1_nb_badge_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-badge", 8);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("text", ctx_r4.badgeText)("status", ctx_r4.badgeStatus)("position", ctx_r4.badgePosition);
  }
}
function NbUserComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtemplate(1, NbUserComponent_div_1_nb_badge_1_Template, 1, 3, "nb-badge", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("background-image", ctx_r0.imageBackgroundStyle);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.badgeText);
  }
}
function NbUserComponent_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r5.getInitials(), " ");
  }
}
function NbUserComponent_div_2_nb_badge_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-badge", 8);
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext(2);
    ɵɵproperty("text", ctx_r6.badgeText)("status", ctx_r6.badgeStatus)("position", ctx_r6.badgePosition);
  }
}
function NbUserComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 9);
    ɵɵtemplate(1, NbUserComponent_div_2_ng_container_1_Template, 2, 1, "ng-container", 10)(2, NbUserComponent_div_2_nb_badge_2_Template, 1, 3, "nb-badge", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("background-color", ctx_r1.color);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.showInitials);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.badgeText);
  }
}
function NbUserComponent_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.name);
  }
}
function NbUserComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.title);
  }
}
function NbActionComponent_ng_container_0_a_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 6);
    ɵɵelement(1, "nb-icon", 7);
    ɵɵelementContainer(2, 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    const _r4 = ɵɵreference(4);
    ɵɵproperty("routerLink", ctx_r5.link)("title", ctx_r5.title);
    ɵɵadvance();
    ɵɵproperty("config", ctx_r5.icon);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r4);
  }
}
function NbActionComponent_ng_container_0_a_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 9);
    ɵɵelement(1, "nb-icon", 7);
    ɵɵelementContainer(2, 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext(2);
    const _r4 = ɵɵreference(4);
    ɵɵproperty("href", ctx_r6.href, ɵɵsanitizeUrl)("title", ctx_r6.title);
    ɵɵadvance();
    ɵɵproperty("config", ctx_r6.icon);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r4);
  }
}
function NbActionComponent_ng_container_0_a_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 10);
    ɵɵlistener("click", function NbActionComponent_ng_container_0_a_3_Template_a_click_0_listener($event) {
      return $event.preventDefault();
    });
    ɵɵelement(1, "nb-icon", 7);
    ɵɵelementContainer(2, 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r7 = ɵɵnextContext(2);
    const _r4 = ɵɵreference(4);
    ɵɵproperty("title", ctx_r7.title);
    ɵɵadvance();
    ɵɵproperty("config", ctx_r7.icon);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r4);
  }
}
function NbActionComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbActionComponent_ng_container_0_a_1_Template, 3, 4, "a", 3)(2, NbActionComponent_ng_container_0_a_2_Template, 3, 4, "a", 4)(3, NbActionComponent_ng_container_0_a_3_Template, 3, 3, "a", 5);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.link);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.href && !ctx_r0.link);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.href && !ctx_r0.link);
  }
}
function NbActionComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
    ɵɵelementContainer(1, 8);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const _r4 = ɵɵreference(4);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", _r4);
  }
}
function NbActionComponent_ng_template_3_nb_badge_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-badge", 12);
  }
  if (rf & 2) {
    const ctx_r9 = ɵɵnextContext(2);
    ɵɵproperty("text", ctx_r9.badgeText)("dotMode", ctx_r9.badgeDot)("status", ctx_r9.badgeStatus)("position", ctx_r9.badgePosition);
  }
}
function NbActionComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, NbActionComponent_ng_template_3_nb_badge_0_Template, 1, 4, "nb-badge", 11);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r3.badgeText || ctx_r3.badgeDot);
  }
}
var _c22 = [[["nb-action"]]];
var _c23 = ["nb-action"];
var _c24 = ["searchInput"];
var _c25 = ["searchButton"];
function NbSearchComponent_nb_search_field_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-search-field", 4);
    ɵɵlistener("search", function NbSearchComponent_nb_search_field_3_Template_nb_search_field_search_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.search($event));
    })("searchInput", function NbSearchComponent_nb_search_field_3_Template_nb_search_field_searchInput_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.emitInput($event));
    })("close", function NbSearchComponent_nb_search_field_3_Template_nb_search_field_close_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.emitDeactivate());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("show", ctx_r1.showSearchField)("type", ctx_r1.type)("placeholder", ctx_r1.placeholder)("hint", ctx_r1.hint);
  }
}
function NbCheckboxComponent_nb_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 6);
  }
}
function NbCheckboxComponent_nb_icon_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
}
function NbProgressBarComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1("", ctx_r0.value, "%");
  }
}
function NbAlertComponent_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 1);
    ɵɵlistener("click", function NbAlertComponent_button_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClose());
    });
    ɵɵelementStart(1, "span", 2);
    ɵɵtext(2, "×");
    ɵɵelementEnd()();
  }
}
function NbChatFormComponent_div_0_ng_container_1_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div")(1, "span", 8);
    ɵɵlistener("click", function NbChatFormComponent_div_0_ng_container_1_div_1_Template_span_click_1_listener() {
      ɵɵrestoreView(_r8);
      const file_r3 = ɵɵnextContext().$implicit;
      const ctx_r6 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r6.removeFile(file_r3));
    });
    ɵɵtext(2, "×");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const file_r3 = ɵɵnextContext().$implicit;
    ɵɵstyleProp("background-image", file_r3.urlStyle);
  }
}
function NbChatFormComponent_div_0_ng_container_1_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div");
    ɵɵelement(1, "nb-icon", 9);
    ɵɵelementStart(2, "span", 8);
    ɵɵlistener("click", function NbChatFormComponent_div_0_ng_container_1_div_2_Template_span_click_2_listener() {
      ɵɵrestoreView(_r12);
      const file_r3 = ɵɵnextContext().$implicit;
      const ctx_r10 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r10.removeFile(file_r3));
    });
    ɵɵtext(3, "×");
    ɵɵelementEnd()();
  }
}
function NbChatFormComponent_div_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbChatFormComponent_div_0_ng_container_1_div_1_Template, 3, 2, "div", 6)(2, NbChatFormComponent_div_0_ng_container_1_div_2_Template, 4, 0, "div", 7);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const file_r3 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", file_r3.urlStyle);
    ɵɵadvance();
    ɵɵproperty("ngIf", !file_r3.urlStyle);
  }
}
function NbChatFormComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtemplate(1, NbChatFormComponent_div_0_ng_container_1_Template, 3, 2, "ng-container", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.droppedFiles);
  }
}
function NbChatFormComponent_button_3_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 13);
  }
  if (rf & 2) {
    const ctx_r13 = ɵɵnextContext(2);
    ɵɵproperty("icon", ctx_r13.buttonIcon);
  }
}
function NbChatFormComponent_button_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r14 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r14.buttonTitle);
  }
}
function NbChatFormComponent_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 10);
    ɵɵlistener("click", function NbChatFormComponent_button_3_Template_button_click_0_listener() {
      ɵɵrestoreView(_r17);
      const ctx_r16 = ɵɵnextContext();
      return ɵɵresetView(ctx_r16.sendMessage());
    });
    ɵɵtemplate(1, NbChatFormComponent_button_3_nb_icon_1_Template, 1, 1, "nb-icon", 11)(2, NbChatFormComponent_button_3_ng_template_2_Template, 1, 1, "ng-template", null, 12, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const _r15 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("with-icon", !ctx_r1.buttonTitle);
    ɵɵproperty("status", ctx_r1.getButtonStatus());
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.buttonTitle)("ngIfElse", _r15);
  }
}
function NbChatMessageTextComponent_p_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 2);
    ɵɵtext(1);
    ɵɵelementStart(2, "time");
    ɵɵtext(3);
    ɵɵpipe(4, "date");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1("", ctx_r0.sender, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind2(4, 2, ctx_r0.date, ctx_r0.dateFormat));
  }
}
function NbChatMessageTextComponent_p_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.message);
  }
}
function NbChatMessageFileComponent_ng_container_2_a_2_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const file_r3 = ɵɵnextContext().$implicit;
    ɵɵproperty("icon", file_r3.icon);
  }
}
function NbChatMessageFileComponent_ng_container_2_a_2_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const file_r3 = ɵɵnextContext().$implicit;
    ɵɵstyleProp("background-image", file_r3.urlStyle);
  }
}
function NbChatMessageFileComponent_ng_container_2_a_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "a", 4);
    ɵɵtemplate(1, NbChatMessageFileComponent_ng_container_2_a_2_nb_icon_1_Template, 1, 1, "nb-icon", 5)(2, NbChatMessageFileComponent_ng_container_2_a_2_div_2_Template, 1, 2, "div", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const file_r3 = ctx.$implicit;
    ɵɵproperty("href", file_r3.url, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵproperty("ngIf", !file_r3.urlStyle && file_r3.icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", file_r3.urlStyle);
  }
}
function NbChatMessageFileComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 2);
    ɵɵtemplate(2, NbChatMessageFileComponent_ng_container_2_a_2_Template, 3, 3, "a", 3);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r0.readyFiles);
  }
}
function NbChatMessageFileComponent_ng_container_3_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 7);
  }
  if (rf & 2) {
    const ctx_r8 = ɵɵnextContext(2);
    ɵɵproperty("icon", ctx_r8.readyFiles[0].icon);
  }
}
function NbChatMessageFileComponent_ng_container_3_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r9 = ɵɵnextContext(2);
    ɵɵstyleProp("background-image", ctx_r9.readyFiles[0].urlStyle);
  }
}
function NbChatMessageFileComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "a", 4);
    ɵɵtemplate(2, NbChatMessageFileComponent_ng_container_3_nb_icon_2_Template, 1, 1, "nb-icon", 5)(3, NbChatMessageFileComponent_ng_container_3_div_3_Template, 1, 2, "div", 6);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("href", ctx_r1.readyFiles[0].url, ɵɵsanitizeUrl);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.readyFiles[0].urlStyle && ctx_r1.readyFiles[0].icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.readyFiles[0].urlStyle);
  }
}
function NbChatMessageQuoteComponent_p_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 3);
    ɵɵtext(1);
    ɵɵelementStart(2, "time");
    ɵɵtext(3);
    ɵɵpipe(4, "date");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1("", ctx_r0.sender, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate(ɵɵpipeBind2(4, 2, ctx_r0.date, ctx_r0.dateFormat));
  }
}
var _c26 = (a0) => [a0];
function NbChatAvatarComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.initials, " ");
  }
}
function NbChatMessageComponent_nb_chat_avatar_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-chat-avatar", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("initials", ctx_r0.getInitials())("avatarStyle", ctx_r0.avatarStyle);
  }
}
function NbChatMessageComponent_ng_container_2_nb_chat_message_file_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-chat-message-file", 10);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("sender", ctx_r4.sender)("date", ctx_r4.date)("dateFormat", ctx_r4.dateFormat)("message", ctx_r4.message)("files", ctx_r4.files);
  }
}
function NbChatMessageComponent_ng_container_2_nb_chat_message_quote_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-chat-message-quote", 11);
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵproperty("sender", ctx_r5.sender)("date", ctx_r5.date)("dateFormat", ctx_r5.dateFormat)("message", ctx_r5.message)("quote", ctx_r5.quote);
  }
}
function NbChatMessageComponent_ng_container_2_nb_chat_message_map_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-chat-message-map", 12);
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext(2);
    ɵɵproperty("sender", ctx_r6.sender)("date", ctx_r6.date)("message", ctx_r6.message)("latitude", ctx_r6.latitude)("longitude", ctx_r6.longitude);
  }
}
function NbChatMessageComponent_ng_container_2_nb_chat_message_text_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-chat-message-text", 13);
  }
  if (rf & 2) {
    const ctx_r7 = ɵɵnextContext(2);
    ɵɵproperty("sender", ctx_r7.sender)("date", ctx_r7.date)("dateFormat", ctx_r7.dateFormat)("message", ctx_r7.message);
  }
}
function NbChatMessageComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 5);
    ɵɵtemplate(1, NbChatMessageComponent_ng_container_2_nb_chat_message_file_1_Template, 1, 5, "nb-chat-message-file", 6)(2, NbChatMessageComponent_ng_container_2_nb_chat_message_quote_2_Template, 1, 5, "nb-chat-message-quote", 7)(3, NbChatMessageComponent_ng_container_2_nb_chat_message_map_3_Template, 1, 5, "nb-chat-message-map", 8)(4, NbChatMessageComponent_ng_container_2_nb_chat_message_text_4_Template, 1, 4, "nb-chat-message-text", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngSwitch", ctx_r1.type);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "file");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "quote");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "map");
  }
}
function NbChatMessageComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-chat-message-text", 13);
    ɵɵelementStart(1, "div");
    ɵɵelementContainer(2, 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("sender", ctx_r2.sender)("date", ctx_r2.date)("dateFormat", ctx_r2.dateFormat)("message", ctx_r2.message);
    ɵɵadvance();
    ɵɵclassProp("nb-custom-message", ctx_r2._areDefaultStylesEnabled())("nb-custom-message-no-space", ctx_r2._addNoSpaceClass)("nb-custom-message-reply", ctx_r2._addReplyClass)("nb-custom-message-not-reply", ctx_r2._addNotReplyClass)("nb-custom-message-full-width", !ctx_r2._areDefaultStylesEnabled());
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r2._getTemplate())("ngTemplateOutletContext", ctx_r2._getTemplateContext());
  }
}
var _c27 = ["scrollable"];
var _c28 = (a0) => ({
  $implicit: a0
});
function NbChatComponent_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.titleTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c28, ctx_r0.titleTemplate.context));
  }
}
function NbChatComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵtextInterpolate1(" ", ctx_r1.title, " ");
  }
}
function NbChatComponent_p_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "p", 9);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r4.noMessagesPlaceholder);
  }
}
var _c29 = [[["nb-chat-message"]], [["nb-chat-form"]]];
var _c30 = ["nb-chat-message", "nb-chat-form"];
function NbSpinnerComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.message);
  }
}
function NbStepComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function NbStepperComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function NbStepperComponent_ng_container_2_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 6);
  }
  if (rf & 2) {
    const index_r3 = ɵɵnextContext().index;
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassProp("connector-past", index_r3 <= ctx_r5.selectedIndex);
  }
}
function NbStepperComponent_ng_container_2_div_2_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const index_r3 = ɵɵnextContext(2).index;
    ɵɵadvance();
    ɵɵtextInterpolate(index_r3 + 1);
  }
}
function NbStepperComponent_ng_container_2_div_2_nb_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 12);
  }
}
function NbStepperComponent_ng_container_2_div_2_ng_container_5_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function NbStepperComponent_ng_container_2_div_2_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbStepperComponent_ng_container_2_div_2_ng_container_5_ng_container_1_Template, 1, 0, "ng-container", 13);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const step_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r10 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r10.getStepTemplate(step_r2));
  }
}
function NbStepperComponent_ng_container_2_div_2_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const step_r2 = ɵɵnextContext(2).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(step_r2.label);
  }
}
function NbStepperComponent_ng_container_2_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 7);
    ɵɵlistener("click", function NbStepperComponent_ng_container_2_div_2_Template_div_click_0_listener() {
      ɵɵrestoreView(_r18);
      const step_r2 = ɵɵnextContext().$implicit;
      const ctx_r16 = ɵɵnextContext();
      return ɵɵresetView(ctx_r16.changeStep(step_r2));
    });
    ɵɵelementStart(1, "div", 8);
    ɵɵtemplate(2, NbStepperComponent_ng_container_2_div_2_span_2_Template, 2, 1, "span", 9)(3, NbStepperComponent_ng_container_2_div_2_nb_icon_3_Template, 1, 0, "nb-icon", 10);
    ɵɵelementEnd();
    ɵɵelementStart(4, "div", 11);
    ɵɵtemplate(5, NbStepperComponent_ng_container_2_div_2_ng_container_5_Template, 2, 1, "ng-container", 9)(6, NbStepperComponent_ng_container_2_div_2_span_6_Template, 2, 1, "span", 9);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const step_r2 = ɵɵnextContext().$implicit;
    const ctx_r6 = ɵɵnextContext();
    ɵɵclassProp("selected", ctx_r6.isStepSelected(step_r2))("completed", !ctx_r6.isStepSelected(step_r2) && step_r2.completed)("noninteractive", ctx_r6.disableStepNavigation);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !step_r2.completed || ctx_r6.isStepSelected(step_r2));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r6.isStepSelected(step_r2) && step_r2.completed);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", step_r2.isLabelTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !step_r2.isLabelTemplate);
  }
}
function NbStepperComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbStepperComponent_ng_container_2_div_1_Template, 1, 2, "div", 4)(2, NbStepperComponent_ng_container_2_div_2_Template, 7, 10, "div", 5);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const step_r2 = ctx.$implicit;
    const first_r4 = ctx.first;
    ɵɵadvance();
    ɵɵproperty("ngIf", !first_r4 && !step_r2.hidden);
    ɵɵadvance();
    ɵɵproperty("ngIf", !step_r2.hidden);
  }
}
var _c31 = [[["nb-step"]]];
var _c32 = ["nb-step"];
var _c33 = [[["nb-accordion-item"]]];
var _c34 = ["nb-accordion-item"];
var _c35 = [[["nb-accordion-item-header"]], [["nb-accordion-item-body"]]];
var _c36 = ["nb-accordion-item-header", "nb-accordion-item-body"];
var _c37 = (a0) => ({
  value: a0
});
function NbAccordionItemHeaderComponent_nb_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("@expansionIndicator", ctx_r0.state);
  }
}
var _c38 = [[["nb-accordion-item-title"]], [["nb-accordion-item-description"]], "*"];
var _c39 = ["nb-accordion-item-title", "nb-accordion-item-description", "*"];
function NbDialogContainerComponent_ng_template_0_Template(rf, ctx) {
}
function NbToastComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵelement(1, "nb-icon", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("config", ctx_r0.icon);
  }
}
function NbToastrContainerComponent_nb_toast_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-toast", 1);
  }
  if (rf & 2) {
    const toast_r1 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("@fadeIn", ctx_r0.fadeIn)("toast", toast_r1);
  }
}
function NbTooltipComponent_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("config", ctx_r0.context.icon);
  }
}
function NbTooltipComponent_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.content);
  }
}
function NbOptionComponent_nb_checkbox_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-checkbox", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("checked", ctx_r0.selected)("disabled", ctx_r0.disabled);
  }
}
var _c40 = ["selectButton"];
function NbSelectComponent_ng_container_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵprojection(1);
    ɵɵelementContainerEnd();
  }
}
function NbSelectComponent_ng_container_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r6 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r6.selectionView);
  }
}
function NbSelectComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbSelectComponent_ng_container_3_ng_container_1_Template, 2, 0, "ng-container", 3)(2, NbSelectComponent_ng_container_3_ng_template_2_Template, 1, 1, "ng-template", null, 7, ɵɵtemplateRefExtractor);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const _r7 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.customLabel)("ngIfElse", _r7);
  }
}
function NbSelectComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵtextInterpolate(ctx_r2.placeholder);
  }
}
function NbSelectComponent_nb_option_list_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-option-list", 8);
    ɵɵprojection(1, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r4.optionsWidth, "px");
    ɵɵproperty("size", ctx_r4.size)("position", ctx_r4.overlayPosition)("ngClass", ctx_r4.optionsListClass);
  }
}
var _c41 = [[["nb-select-label"]], [["nb-option"], ["nb-option-group"]]];
var _c42 = ["nb-select-label", "nb-option, nb-option-group"];
var _c43 = [[["nb-option"], ["ng-container"]]];
var _c44 = ["nb-option, ng-container"];
function NbFormFieldComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵpipe(1, "async");
    ɵɵprojection(2, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpipeBind1(1, 1, ctx_r0.prefixClasses$));
  }
}
function NbFormFieldComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵpipe(1, "async");
    ɵɵprojection(2, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpipeBind1(1, 1, ctx_r1.suffixClasses$));
  }
}
var _c45 = ["*", [["", "nbPrefix", ""]], [["", "nbSuffix", ""]]];
var _c46 = ["*", "[nbPrefix]", "[nbSuffix]"];
var _c47 = ["optionsAutocompleteInput"];
function NbSelectWithAutocompleteComponent_ng_container_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵprojection(1);
    ɵɵelementContainerEnd();
  }
}
function NbSelectWithAutocompleteComponent_ng_container_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r7 = ɵɵnextContext(2);
    ɵɵtextInterpolate(ctx_r7.selectionView);
  }
}
function NbSelectWithAutocompleteComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbSelectWithAutocompleteComponent_ng_container_3_ng_container_1_Template, 2, 0, "ng-container", 3)(2, NbSelectWithAutocompleteComponent_ng_container_3_ng_template_2_Template, 1, 1, "ng-template", null, 11, ɵɵtemplateRefExtractor);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const _r8 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.customLabel)("ngIfElse", _r8);
  }
}
function NbSelectWithAutocompleteComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵtextInterpolate(ctx_r2.placeholder);
  }
}
function NbSelectWithAutocompleteComponent_nb_option_list_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-option-list", 12);
    ɵɵprojection(1, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r5.optionsWidth, "px");
    ɵɵproperty("size", ctx_r5.size)("position", ctx_r5.overlayPosition)("ngClass", ctx_r5.optionsListClass);
  }
}
function NbAutocompleteComponent_nb_option_list_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-option-list", 1);
    ɵɵprojection(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r0.optionsWidth, "px");
    ɵɵclassProp("empty", !(ctx_r0.options == null ? null : ctx_r0.options.length));
    ɵɵproperty("size", ctx_r0.size)("position", ctx_r0.overlayPosition)("id", ctx_r0.id)("ngClass", ctx_r0.optionsListClass);
  }
}
var _c48 = [[["nb-option"], ["nb-option-group"]]];
var _c49 = ["nb-option, nb-option-group"];
var _c50 = ["viewContainerRef"];
function NbWindowComponent_div_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function NbWindowComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtemplate(1, NbWindowComponent_div_2_ng_container_1_Template, 1, 0, "ng-container", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.config.titleTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c28, ctx_r0.config.titleTemplateContext));
  }
}
function NbWindowComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.config.title);
  }
}
function NbWindowComponent_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "button", 7);
    ɵɵlistener("click", function NbWindowComponent_ng_container_6_Template_button_click_1_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r9 = ɵɵnextContext();
      return ɵɵresetView(ctx_r9.minimize());
    });
    ɵɵelement(2, "nb-icon", 8);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
}
function NbWindowComponent_ng_container_7_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function NbWindowComponent_ng_container_7_button_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r13);
      const ctx_r12 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r12.maximize());
    });
    ɵɵelement(1, "nb-icon", 10);
    ɵɵelementEnd();
  }
}
function NbWindowComponent_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbWindowComponent_ng_container_7_button_1_Template, 2, 0, "button", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.isFullScreen);
  }
}
function NbWindowComponent_ng_container_8_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function NbWindowComponent_ng_container_8_button_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r16);
      const ctx_r15 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r15.maximizeOrFullScreen());
    });
    ɵɵelement(1, "nb-icon", 11);
    ɵɵelementEnd();
  }
}
function NbWindowComponent_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbWindowComponent_ng_container_8_button_1_Template, 2, 0, "button", 9);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5.minimized || ctx_r5.maximized);
  }
}
function NbWindowComponent_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r18 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "button", 7);
    ɵɵlistener("click", function NbWindowComponent_ng_container_9_Template_button_click_1_listener() {
      ɵɵrestoreView(_r18);
      const ctx_r17 = ɵɵnextContext();
      return ɵɵresetView(ctx_r17.close());
    });
    ɵɵelement(2, "nb-icon", 12);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
}
function NbWindowComponent_nb_card_body_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nb-card-body");
    ɵɵelement(1, "nb-overlay-container");
    ɵɵelementEnd();
  }
}
var _c51 = ["input"];
var _c52 = [[["nb-radio"]]];
var _c53 = ["nb-radio"];
function NbTagComponent_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nb-icon", 1);
    ɵɵlistener("click", function NbTagComponent_nb_icon_1_Template_nb_icon_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._remove());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMapInterpolate1("nb-tag-remove size-", ctx_r0.size, "");
  }
}
var _c54 = [[["nb-tag"], ["input", "nbTagInput", ""]]];
var _c55 = ["nb-tag, input[nbTagInput]"];
function NbSortIconComponent_ng_container_0_nb_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 3);
  }
}
function NbSortIconComponent_ng_container_0_nb_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 4);
  }
}
function NbSortIconComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, NbSortIconComponent_ng_container_0_nb_icon_1_Template, 1, 0, "nb-icon", 1)(2, NbSortIconComponent_ng_container_0_nb_icon_2_Template, 1, 0, "nb-icon", 2);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isAscending());
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.isDescending());
  }
}
var _c56 = ["nbSortHeader", ""];
function NbSortHeaderComponent_nb_sort_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-sort-icon", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("direction", ctx_r0.direction);
  }
}
function NbSortHeaderComponent_ng_template_3_Template(rf, ctx) {
}
var _c57 = ["nbTreeGrid", ""];
var _c58 = ["nbTreeGridRow", ""];
var _c59 = ["nbTreeGridHeaderRow", ""];
var _c60 = ["nbTreeGridFooterRow", ""];
function NbToggleComponent_nb_icon_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nb-icon", 6);
  }
}
var NB_THEME_OPTIONS = new InjectionToken("Nebular Theme Options");
var NB_MEDIA_BREAKPOINTS = new InjectionToken("Nebular Media Breakpoints");
var NB_BUILT_IN_JS_THEMES = new InjectionToken("Nebular Built-in JS Themes");
var NB_JS_THEMES = new InjectionToken("Nebular JS Themes");
var NB_WINDOW = new InjectionToken("Window");
var NB_DOCUMENT = new InjectionToken("Document");
var DEFAULT_MEDIA_BREAKPOINTS = [{
  name: "xs",
  width: 0
}, {
  name: "is",
  width: 400
}, {
  name: "sm",
  width: 576
}, {
  name: "md",
  width: 768
}, {
  name: "lg",
  width: 992
}, {
  name: "xl",
  width: 1200
}, {
  name: "xxl",
  width: 1400
}, {
  name: "xxxl",
  width: 1600
}];
var _NbMediaBreakpointsService = class _NbMediaBreakpointsService {
  constructor(breakpoints) {
    this.breakpoints = breakpoints;
    this.breakpointsMap = this.breakpoints.reduce((res, b) => {
      res[b.name] = b.width;
      return res;
    }, {});
  }
  /**
   * Returns a configured breakpoint by width
   * @param width number
   * @returns {Z|{name: string, width: number}}
   */
  getByWidth(width) {
    const unknown = {
      name: "unknown",
      width
    };
    const breakpoints = this.getBreakpoints();
    return breakpoints.find((point, index) => {
      const next = breakpoints[index + 1];
      return width >= point.width && (!next || width < next.width);
    }) || unknown;
  }
  /**
   * Returns a configured breakpoint by name
   * @param name string
   * @returns NbMediaBreakpoint
   */
  getByName(name) {
    const unknown = {
      name: "unknown",
      width: NaN
    };
    const breakpoints = this.getBreakpoints();
    return breakpoints.find((point) => name === point.name) || unknown;
  }
  /**
   * Returns a list of configured breakpoints for the theme
   * @returns NbMediaBreakpoint[]
   */
  getBreakpoints() {
    return this.breakpoints;
  }
  /**
   * Returns a map of configured breakpoints for the theme
   * @returns {[p: string]: number}
   */
  getBreakpointsMap() {
    return this.breakpointsMap;
  }
};
_NbMediaBreakpointsService.ɵfac = function NbMediaBreakpointsService_Factory(t) {
  return new (t || _NbMediaBreakpointsService)(ɵɵinject(NB_MEDIA_BREAKPOINTS));
};
_NbMediaBreakpointsService.ɵprov = ɵɵdefineInjectable({
  token: _NbMediaBreakpointsService,
  factory: _NbMediaBreakpointsService.ɵfac
});
var NbMediaBreakpointsService = _NbMediaBreakpointsService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMediaBreakpointsService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_MEDIA_BREAKPOINTS]
    }]
  }], null);
})();
var palette$3 = {
  primary: "#3366ff",
  success: "#00d68f",
  info: "#0095ff",
  warning: "#ffaa00",
  danger: "#ff3d71"
};
var DEFAULT_THEME = {
  name: "default",
  variables: {
    fontMain: "Open Sans, sans-serif",
    fontSecondary: "Raleway, sans-serif",
    bg: "#ffffff",
    bg2: "#f7f9fc",
    bg3: "#edf1f7",
    bg4: "#e4e9f2",
    border: "#ffffff",
    border2: "#f7f9fc",
    border3: "#edf1f7",
    border4: "#e4e9f2",
    border5: "#c5cee0",
    fg: "#8f9bb3",
    fgHeading: "#1a2138",
    fgText: "#1a2138",
    fgHighlight: palette$3.primary,
    layoutBg: "#f7f9fc",
    separator: "#edf1f7",
    primary: palette$3.primary,
    success: palette$3.success,
    info: palette$3.info,
    warning: palette$3.warning,
    danger: palette$3.danger,
    primaryLight: "#598bff",
    successLight: "#2ce69b",
    infoLight: "#42aaff",
    warningLight: "#ffc94d",
    dangerLight: "#ff708d"
  }
};
var palette$2 = {
  primary: "#a16eff",
  success: "#00d68f",
  info: "#0095ff",
  warning: "#ffaa00",
  danger: "#ff3d71"
};
var COSMIC_THEME = {
  name: "cosmic",
  variables: {
    fontMain: "Open Sans, sans-serif",
    fontSecondary: "Raleway, sans-serif",
    bg: "#323259",
    bg2: "#252547",
    bg3: "#1b1b38",
    bg4: "#13132b",
    border: "#323259",
    border2: "#252547",
    border3: "#1b1b38",
    border4: "#13132b",
    border5: "#13132b",
    fg: "#b4b4db",
    fgHeading: "#ffffff",
    fgText: "#ffffff",
    fgHighlight: palette$2.primary,
    layoutBg: "#151a30",
    separator: "#151a30",
    primary: palette$2.primary,
    success: palette$2.success,
    info: palette$2.info,
    warning: palette$2.warning,
    danger: palette$2.danger,
    primaryLight: "#b18aff",
    successLight: "#2ce69b",
    infoLight: "#42aaff",
    warningLight: "#ffc94d",
    dangerLight: "#ff708d"
  }
};
var palette$1 = {
  primary: "#73a1ff",
  success: "#5dcfe3",
  info: "#ba7fec",
  warning: "#ffa36b",
  danger: "#ff6b83"
};
var CORPORATE_THEME = {
  name: "corporate",
  base: "default",
  variables: {
    fontMain: "Open Sans, sans-serif",
    fontSecondary: "Raleway, sans-serif",
    bg: "#ffffff",
    bg2: "#f7f9fc",
    bg3: "#edf1f7",
    bg4: "#e4e9f2",
    border: "#ffffff",
    border2: "#f7f9fc",
    border3: "#edf1f7",
    border4: "#e4e9f2",
    border5: "#c5cee0",
    fg: "#8f9bb3",
    fgHeading: "#1a2138",
    fgText: "#1a2138",
    fgHighlight: palette$1.primary,
    layoutBg: "#f7f9fc",
    separator: "#edf1f7",
    primary: palette$1.primary,
    success: palette$1.success,
    info: palette$1.info,
    warning: palette$1.warning,
    danger: palette$1.danger,
    primaryLight: "#598bff",
    successLight: "#2ce69b",
    infoLight: "#42aaff",
    warningLight: "#ffc94d",
    dangerLight: "#ff708d"
  }
};
var palette = {
  primary: "#3366ff",
  success: "#00d68f",
  info: "#0095ff",
  warning: "#ffaa00",
  danger: "#ff3d71"
};
var DARK_THEME = {
  name: "dark",
  variables: {
    fontMain: "Open Sans, sans-serif",
    fontSecondary: "Raleway, sans-serif",
    bg: "#222b45",
    bg2: "#1a2138",
    bg3: "#151a30",
    bg4: "#101426",
    border: "#222b45",
    border2: "#1a2138",
    border3: "#151a30",
    border4: "#101426",
    border5: "#101426",
    fg: "#8f9bb3",
    fgHeading: "#ffffff",
    fgText: "#ffffff",
    fgHighlight: palette.primary,
    layoutBg: "#1b1b38",
    separator: "#1b1b38",
    primary: palette.primary,
    success: palette.success,
    info: palette.info,
    warning: palette.warning,
    danger: palette.danger,
    primaryLight: "#598bff",
    successLight: "#2ce69b",
    infoLight: "#42aaff",
    warningLight: "#ffc94d",
    dangerLight: "#ff708d"
  }
};
var BUILT_IN_THEMES = [DEFAULT_THEME, COSMIC_THEME, CORPORATE_THEME, DARK_THEME];
var _NbJSThemesRegistry = class _NbJSThemesRegistry {
  constructor(builtInThemes, newThemes = []) {
    this.themes = {};
    const themes = this.combineByNames(newThemes, builtInThemes);
    themes.forEach((theme) => {
      this.register(theme, theme.name, theme.base);
    });
  }
  /**
   * Registers a new JS theme
   * @param config any
   * @param themeName string
   * @param baseTheme string
   */
  register(config, themeName, baseTheme) {
    const base = this.has(baseTheme) ? this.get(baseTheme) : {};
    this.themes[themeName] = this.mergeDeep({}, base, config);
  }
  /**
   * Checks whether the theme is registered
   * @param themeName
   * @returns boolean
   */
  has(themeName) {
    return !!this.themes[themeName];
  }
  /**
   * Return a theme
   * @param themeName
   * @returns NbJSThemeOptions
   */
  get(themeName) {
    if (!this.themes[themeName]) {
      throw Error(`NbThemeConfig: no theme '${themeName}' found registered.`);
    }
    return JSON.parse(JSON.stringify(this.themes[themeName]));
  }
  combineByNames(newThemes, oldThemes) {
    if (newThemes) {
      const mergedThemes = [];
      newThemes.forEach((theme) => {
        const sameOld = oldThemes.find((tm) => tm.name === theme.name) || {};
        const mergedTheme = this.mergeDeep({}, sameOld, theme);
        mergedThemes.push(mergedTheme);
      });
      oldThemes.forEach((theme) => {
        if (!mergedThemes.find((tm) => tm.name === theme.name)) {
          mergedThemes.push(theme);
        }
      });
      return mergedThemes;
    }
    return oldThemes;
  }
  isObject(item) {
    return item && typeof item === "object" && !Array.isArray(item);
  }
  // TODO: move to helpers
  mergeDeep(target, ...sources) {
    if (!sources.length) {
      return target;
    }
    const source = sources.shift();
    if (this.isObject(target) && this.isObject(source)) {
      for (const key in source) {
        if (this.isObject(source[key])) {
          if (!target[key]) {
            Object.assign(target, {
              [key]: {}
            });
          }
          this.mergeDeep(target[key], source[key]);
        } else {
          Object.assign(target, {
            [key]: source[key]
          });
        }
      }
    }
    return this.mergeDeep(target, ...sources);
  }
};
_NbJSThemesRegistry.ɵfac = function NbJSThemesRegistry_Factory(t) {
  return new (t || _NbJSThemesRegistry)(ɵɵinject(NB_BUILT_IN_JS_THEMES), ɵɵinject(NB_JS_THEMES));
};
_NbJSThemesRegistry.ɵprov = ɵɵdefineInjectable({
  token: _NbJSThemesRegistry,
  factory: _NbJSThemesRegistry.ɵfac
});
var NbJSThemesRegistry = _NbJSThemesRegistry;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbJSThemesRegistry, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_BUILT_IN_JS_THEMES]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_JS_THEMES]
    }]
  }], null);
})();
var _NbThemeService = class _NbThemeService {
  constructor(options, breakpointService, jsThemesRegistry) {
    this.options = options;
    this.breakpointService = breakpointService;
    this.jsThemesRegistry = jsThemesRegistry;
    this.themeChanges$ = new ReplaySubject(1);
    this.appendLayoutClass$ = new Subject();
    this.removeLayoutClass$ = new Subject();
    this.changeWindowWidth$ = new ReplaySubject(2);
    if (options && options.name) {
      this.changeTheme(options.name);
    }
  }
  /**
   * Change current application theme
   * @param {string} name
   */
  changeTheme(name) {
    this.themeChanges$.next({
      name,
      previous: this.currentTheme
    });
    this.currentTheme = name;
  }
  changeWindowWidth(width) {
    this.changeWindowWidth$.next(width);
  }
  /**
   * Returns a theme object with variables (color/paddings/etc) on a theme change.
   * Once subscribed - returns current theme.
   *
   * @returns {Observable<NbJSThemeOptions>}
   */
  getJsTheme() {
    return this.onThemeChange().pipe(map((theme) => {
      return this.jsThemesRegistry.get(theme.name);
    }));
  }
  /**
   * Triggers media query breakpoint change
   * Returns a pair where the first item is previous media breakpoint and the second item is current breakpoit.
   * ```ts
   *  [{ name: 'xs', width: 0 }, { name: 'md', width: 768 }] // change from `xs` to `md`
   * ```
   * @returns {Observable<[NbMediaBreakpoint, NbMediaBreakpoint]>}
   */
  onMediaQueryChange() {
    return this.changeWindowWidth$.pipe(startWith(void 0), pairwise(), map(([prevWidth, width]) => {
      return [this.breakpointService.getByWidth(prevWidth), this.breakpointService.getByWidth(width)];
    }), filter(([prevPoint, point]) => {
      return prevPoint.name !== point.name;
    }), distinctUntilChanged(null, (params) => params[0].name + params[1].name), share());
  }
  /**
   * Triggered when current theme is changed
   * @returns {Observable<any>}
   */
  onThemeChange() {
    return this.themeChanges$.pipe(share());
  }
  /**
   * Append a class to nb-layout
   * @param {string} className
   */
  appendLayoutClass(className) {
    this.appendLayoutClass$.next(className);
  }
  /**
   * Triggered when a new class is added to nb-layout through `appendLayoutClass` method
   * @returns {Observable<any>}
   */
  onAppendLayoutClass() {
    return this.appendLayoutClass$.pipe(share());
  }
  /**
   * Removes a class from nb-layout
   * @param {string} className
   */
  removeLayoutClass(className) {
    this.removeLayoutClass$.next(className);
  }
  /**
   * Triggered when a class is removed from nb-layout through `removeLayoutClass` method
   * @returns {Observable<any>}
   */
  onRemoveLayoutClass() {
    return this.removeLayoutClass$.pipe(share());
  }
};
_NbThemeService.ɵfac = function NbThemeService_Factory(t) {
  return new (t || _NbThemeService)(ɵɵinject(NB_THEME_OPTIONS), ɵɵinject(NbMediaBreakpointsService), ɵɵinject(NbJSThemesRegistry));
};
_NbThemeService.ɵprov = ɵɵdefineInjectable({
  token: _NbThemeService,
  factory: _NbThemeService.ɵfac
});
var NbThemeService = _NbThemeService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbThemeService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_THEME_OPTIONS]
    }]
  }, {
    type: NbMediaBreakpointsService
  }, {
    type: NbJSThemesRegistry
  }], null);
})();
var _NbSpinnerService = class _NbSpinnerService {
  constructor(document) {
    this.document = document;
    this.loaders = [];
    this.selector = "nb-global-spinner";
  }
  /**
   * Appends new loader to the list of loader to be completed before
   * spinner will be hidden
   * @param method Promise<any>
   */
  registerLoader(method) {
    this.loaders.push(method);
  }
  /**
   * Clears the list of loader
   */
  clear() {
    this.loaders = [];
  }
  /**
   * Start the loader process, show spinnder and execute loaders
   */
  load() {
    this.showSpinner();
    this.executeAll();
  }
  executeAll(done = (values) => {
  }) {
    Promise.all(this.loaders).then((values) => {
      this.hideSpinner();
      done.call(null, values);
    }).catch((error) => {
      console.error(error);
    });
  }
  // TODO is there any better way of doing this?
  showSpinner() {
    const el = this.getSpinnerElement();
    if (el) {
      el.style["display"] = "block";
    }
  }
  hideSpinner() {
    const el = this.getSpinnerElement();
    if (el) {
      el.style["display"] = "none";
    }
  }
  getSpinnerElement() {
    return this.document.getElementById(this.selector);
  }
};
_NbSpinnerService.ɵfac = function NbSpinnerService_Factory(t) {
  return new (t || _NbSpinnerService)(ɵɵinject(NB_DOCUMENT));
};
_NbSpinnerService.ɵprov = ɵɵdefineInjectable({
  token: _NbSpinnerService,
  factory: _NbSpinnerService.ɵfac
});
var NbSpinnerService = _NbSpinnerService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSpinnerService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var NbLayoutDirection;
(function(NbLayoutDirection2) {
  NbLayoutDirection2["LTR"] = "ltr";
  NbLayoutDirection2["RTL"] = "rtl";
})(NbLayoutDirection || (NbLayoutDirection = {}));
var NB_LAYOUT_DIRECTION = new InjectionToken("Layout direction");
var _NbLayoutDirectionService = class _NbLayoutDirectionService {
  constructor(direction = NbLayoutDirection.LTR) {
    this.direction = direction;
    this.$directionChange = new ReplaySubject(1);
    this.setDirection(direction);
  }
  /**
   * Returns true if layout direction set to left to right.
   * @returns boolean.
   * */
  isLtr() {
    return this.direction === NbLayoutDirection.LTR;
  }
  /**
   * Returns true if layout direction set to right to left.
   * @returns boolean.
   * */
  isRtl() {
    return this.direction === NbLayoutDirection.RTL;
  }
  /**
   * Returns current layout direction.
   * @returns NbLayoutDirection.
   * */
  getDirection() {
    return this.direction;
  }
  /**
   * Sets layout direction
   * @param {NbLayoutDirection} direction
   */
  setDirection(direction) {
    this.direction = direction;
    this.$directionChange.next(direction);
  }
  /**
   * Triggered when direction was changed.
   * @returns Observable<NbLayoutDirection>.
   */
  onDirectionChange() {
    return this.$directionChange.pipe(share());
  }
};
_NbLayoutDirectionService.ɵfac = function NbLayoutDirectionService_Factory(t) {
  return new (t || _NbLayoutDirectionService)(ɵɵinject(NB_LAYOUT_DIRECTION, 8));
};
_NbLayoutDirectionService.ɵprov = ɵɵdefineInjectable({
  token: _NbLayoutDirectionService,
  factory: _NbLayoutDirectionService.ɵfac
});
var NbLayoutDirectionService = _NbLayoutDirectionService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutDirectionService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_LAYOUT_DIRECTION]
    }]
  }], null);
})();
var _NbLayoutScrollService = class _NbLayoutScrollService {
  constructor() {
    this.scrollPositionReq$ = new Subject();
    this.manualScroll$ = new Subject();
    this.scroll$ = new Subject();
    this.scrollable$ = new Subject();
  }
  /**
   * Returns scroll position
   *
   * @returns {Observable<NbScrollPosition>}
   */
  getPosition() {
    return new Observable((observer) => {
      const listener = new Subject();
      listener.subscribe(observer);
      this.scrollPositionReq$.next({
        listener
      });
      return () => listener.complete();
    });
  }
  /**
   * Sets scroll position
   *
   * @param {number} x
   * @param {number} y
   */
  scrollTo(x = null, y = null) {
    this.manualScroll$.next({
      x,
      y
    });
  }
  /**
   * Returns a stream of scroll events
   *
   * @returns {Observable<any>}
   */
  onScroll() {
    return this.scroll$.pipe(share());
  }
  /**
   * @private
   * @returns Observable<NbScrollPosition>.
   */
  onManualScroll() {
    return this.manualScroll$.pipe(share());
  }
  /**
   * @private
   * @returns {Subject<any>}
   */
  onGetPosition() {
    return this.scrollPositionReq$;
  }
  onScrollableChange() {
    return this.scrollable$.pipe(share());
  }
  /**
   * @private
   * @param {any} event
   */
  fireScrollChange(event) {
    this.scroll$.next(event);
  }
  scrollable(scrollable) {
    this.scrollable$.next(scrollable);
  }
};
_NbLayoutScrollService.ɵfac = function NbLayoutScrollService_Factory(t) {
  return new (t || _NbLayoutScrollService)();
};
_NbLayoutScrollService.ɵprov = ɵɵdefineInjectable({
  token: _NbLayoutScrollService,
  factory: _NbLayoutScrollService.ɵfac
});
var NbLayoutScrollService = _NbLayoutScrollService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutScrollService, [{
    type: Injectable
  }], null, null);
})();
var _NbLayoutRulerService = class _NbLayoutRulerService {
  constructor() {
    this.contentDimensionsReq$ = new Subject();
  }
  /**
   * Content dimensions
   * @returns {Observable<NbLayoutDimensions>}
   */
  getDimensions() {
    return new Observable((observer) => {
      const listener = new Subject();
      listener.subscribe(observer);
      this.contentDimensionsReq$.next({
        listener
      });
      return () => listener.complete();
    });
  }
  /**
   * @private
   * @returns {Subject<any>}
   */
  onGetDimensions() {
    return this.contentDimensionsReq$;
  }
};
_NbLayoutRulerService.ɵfac = function NbLayoutRulerService_Factory(t) {
  return new (t || _NbLayoutRulerService)();
};
_NbLayoutRulerService.ɵprov = ɵɵdefineInjectable({
  token: _NbLayoutRulerService,
  factory: _NbLayoutRulerService.ɵfac
});
var NbLayoutRulerService = _NbLayoutRulerService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutRulerService, [{
    type: Injectable
  }], null, null);
})();
var _NbSharedModule = class _NbSharedModule {
};
_NbSharedModule.ɵfac = function NbSharedModule_Factory(t) {
  return new (t || _NbSharedModule)();
};
_NbSharedModule.ɵmod = ɵɵdefineNgModule({
  type: _NbSharedModule,
  exports: [
    CommonModule,
    // TODO: probably we don't need FormsModule in SharedModule
    FormsModule,
    RouterModule
  ]
});
_NbSharedModule.ɵinj = ɵɵdefineInjector({
  imports: [
    CommonModule,
    // TODO: probably we don't need FormsModule in SharedModule
    FormsModule,
    RouterModule
  ]
});
var NbSharedModule = _NbSharedModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSharedModule, [{
    type: NgModule,
    args: [{
      exports: [
        CommonModule,
        // TODO: probably we don't need FormsModule in SharedModule
        FormsModule,
        RouterModule
      ]
    }]
  }], null, null);
})();
var NbFocusTrap = class extends FocusTrap {
  constructor(element, checker, ngZone, document, deferAnchors) {
    super(element, checker, ngZone, document, deferAnchors);
    this.element = element;
    this.checker = checker;
    this.ngZone = ngZone;
    this.document = document;
    this.savePreviouslyFocusedElement();
  }
  restoreFocus() {
    this.previouslyFocusedElement.focus();
    this.destroy();
  }
  blurPreviouslyFocusedElement() {
    this.previouslyFocusedElement.blur();
  }
  savePreviouslyFocusedElement() {
    this.previouslyFocusedElement = this.document.activeElement;
  }
};
var _NbFocusTrapFactoryService = class _NbFocusTrapFactoryService extends FocusTrapFactory {
  constructor(checker, ngZone, document) {
    super(checker, ngZone, document);
    this.checker = checker;
    this.ngZone = ngZone;
    this.document = document;
  }
  create(element, deferCaptureElements) {
    return new NbFocusTrap(element, this.checker, this.ngZone, this.document, deferCaptureElements);
  }
};
_NbFocusTrapFactoryService.ɵfac = function NbFocusTrapFactoryService_Factory(t) {
  return new (t || _NbFocusTrapFactoryService)(ɵɵinject(InteractivityChecker), ɵɵinject(NgZone), ɵɵinject(NB_DOCUMENT));
};
_NbFocusTrapFactoryService.ɵprov = ɵɵdefineInjectable({
  token: _NbFocusTrapFactoryService,
  factory: _NbFocusTrapFactoryService.ɵfac
});
var NbFocusTrapFactoryService = _NbFocusTrapFactoryService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFocusTrapFactoryService, [{
    type: Injectable
  }], () => [{
    type: InteractivityChecker
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var NbFocusKeyManager = class extends FocusKeyManager {
};
var NbFocusKeyManagerFactoryService = class {
  create(items) {
    return new NbFocusKeyManager(items);
  }
};
var NbActiveDescendantKeyManager = class extends ActiveDescendantKeyManager {
};
var NbActiveDescendantKeyManagerFactoryService = class {
  create(items) {
    return new NbActiveDescendantKeyManager(items);
  }
};
var NbKeyManagerActiveItemMode;
(function(NbKeyManagerActiveItemMode2) {
  NbKeyManagerActiveItemMode2[NbKeyManagerActiveItemMode2["RESET_ACTIVE"] = -1] = "RESET_ACTIVE";
  NbKeyManagerActiveItemMode2[NbKeyManagerActiveItemMode2["FIRST_ACTIVE"] = 0] = "FIRST_ACTIVE";
})(NbKeyManagerActiveItemMode || (NbKeyManagerActiveItemMode = {}));
var _NbFocusMonitor = class _NbFocusMonitor extends FocusMonitor {
};
_NbFocusMonitor.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbFocusMonitor_BaseFactory;
  return function NbFocusMonitor_Factory(t) {
    return (ɵNbFocusMonitor_BaseFactory || (ɵNbFocusMonitor_BaseFactory = ɵɵgetInheritedFactory(_NbFocusMonitor)))(t || _NbFocusMonitor);
  };
})();
_NbFocusMonitor.ɵprov = ɵɵdefineInjectable({
  token: _NbFocusMonitor,
  factory: _NbFocusMonitor.ɵfac
});
var NbFocusMonitor = _NbFocusMonitor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFocusMonitor, [{
    type: Injectable
  }], null, null);
})();
var _NbA11yModule = class _NbA11yModule {
  static forRoot() {
    return {
      ngModule: _NbA11yModule,
      providers: [NbFocusTrapFactoryService, NbFocusKeyManagerFactoryService, NbActiveDescendantKeyManagerFactoryService, {
        provide: NbFocusMonitor,
        useClass: FocusMonitor
      }]
    };
  }
};
_NbA11yModule.ɵfac = function NbA11yModule_Factory(t) {
  return new (t || _NbA11yModule)();
};
_NbA11yModule.ɵmod = ɵɵdefineNgModule({
  type: _NbA11yModule
});
_NbA11yModule.ɵinj = ɵɵdefineInjector({});
var NbA11yModule = _NbA11yModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbA11yModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var _NbPortalDirective = class _NbPortalDirective extends CdkPortal {
};
_NbPortalDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbPortalDirective_BaseFactory;
  return function NbPortalDirective_Factory(t) {
    return (ɵNbPortalDirective_BaseFactory || (ɵNbPortalDirective_BaseFactory = ɵɵgetInheritedFactory(_NbPortalDirective)))(t || _NbPortalDirective);
  };
})();
_NbPortalDirective.ɵdir = ɵɵdefineDirective({
  type: _NbPortalDirective,
  selectors: [["", "nbPortal", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
var NbPortalDirective = _NbPortalDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPortalDirective, [{
    type: Directive,
    args: [{
      selector: "[nbPortal]"
    }]
  }], null, null);
})();
var _NbPortalOutletDirective = class _NbPortalOutletDirective extends CdkPortalOutlet {
};
_NbPortalOutletDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbPortalOutletDirective_BaseFactory;
  return function NbPortalOutletDirective_Factory(t) {
    return (ɵNbPortalOutletDirective_BaseFactory || (ɵNbPortalOutletDirective_BaseFactory = ɵɵgetInheritedFactory(_NbPortalOutletDirective)))(t || _NbPortalOutletDirective);
  };
})();
_NbPortalOutletDirective.ɵdir = ɵɵdefineDirective({
  type: _NbPortalOutletDirective,
  selectors: [["", "nbPortalOutlet", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
var NbPortalOutletDirective = _NbPortalOutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPortalOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbPortalOutlet]"
    }]
  }], null, null);
})();
var NbComponentPortal = class extends ComponentPortal {
};
var _NbOverlay = class _NbOverlay extends Overlay {
};
_NbOverlay.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbOverlay_BaseFactory;
  return function NbOverlay_Factory(t) {
    return (ɵNbOverlay_BaseFactory || (ɵNbOverlay_BaseFactory = ɵɵgetInheritedFactory(_NbOverlay)))(t || _NbOverlay);
  };
})();
_NbOverlay.ɵprov = ɵɵdefineInjectable({
  token: _NbOverlay,
  factory: _NbOverlay.ɵfac
});
var NbOverlay = _NbOverlay;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlay, [{
    type: Injectable
  }], null, null);
})();
var _NbOverlayPositionBuilder = class _NbOverlayPositionBuilder extends OverlayPositionBuilder {
};
_NbOverlayPositionBuilder.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbOverlayPositionBuilder_BaseFactory;
  return function NbOverlayPositionBuilder_Factory(t) {
    return (ɵNbOverlayPositionBuilder_BaseFactory || (ɵNbOverlayPositionBuilder_BaseFactory = ɵɵgetInheritedFactory(_NbOverlayPositionBuilder)))(t || _NbOverlayPositionBuilder);
  };
})();
_NbOverlayPositionBuilder.ɵprov = ɵɵdefineInjectable({
  token: _NbOverlayPositionBuilder,
  factory: _NbOverlayPositionBuilder.ɵfac
});
var NbOverlayPositionBuilder = _NbOverlayPositionBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayPositionBuilder, [{
    type: Injectable
  }], null, null);
})();
var NbTemplatePortal = class extends TemplatePortal {
  constructor(template, viewContainerRef, context) {
    super(template, viewContainerRef, context);
  }
};
var _NbOverlayContainer = class _NbOverlayContainer extends OverlayContainer {
};
_NbOverlayContainer.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbOverlayContainer_BaseFactory;
  return function NbOverlayContainer_Factory(t) {
    return (ɵNbOverlayContainer_BaseFactory || (ɵNbOverlayContainer_BaseFactory = ɵɵgetInheritedFactory(_NbOverlayContainer)))(t || _NbOverlayContainer);
  };
})();
_NbOverlayContainer.ɵprov = ɵɵdefineInjectable({
  token: _NbOverlayContainer,
  factory: _NbOverlayContainer.ɵfac
});
var NbOverlayContainer = _NbOverlayContainer;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayContainer, [{
    type: Injectable
  }], null, null);
})();
var NbFlexibleConnectedPositionStrategy = class extends FlexibleConnectedPositionStrategy {
};
var NbPortalInjector = class extends PortalInjector {
};
var CDK_MODULES = [OverlayModule, PortalModule];
var _NbCdkMappingModule = class _NbCdkMappingModule {
  static forRoot() {
    return {
      ngModule: _NbCdkMappingModule,
      providers: [NbOverlay, NbOverlayPositionBuilder]
    };
  }
};
_NbCdkMappingModule.ɵfac = function NbCdkMappingModule_Factory(t) {
  return new (t || _NbCdkMappingModule)();
};
_NbCdkMappingModule.ɵmod = ɵɵdefineNgModule({
  type: _NbCdkMappingModule,
  declarations: [NbPortalDirective, NbPortalOutletDirective],
  imports: [OverlayModule, PortalModule],
  exports: [OverlayModule, PortalModule, NbPortalDirective, NbPortalOutletDirective]
});
_NbCdkMappingModule.ɵinj = ɵɵdefineInjector({
  imports: [CDK_MODULES, OverlayModule, PortalModule]
});
var NbCdkMappingModule = _NbCdkMappingModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCdkMappingModule, [{
    type: NgModule,
    args: [{
      imports: [...CDK_MODULES],
      exports: [...CDK_MODULES, NbPortalDirective, NbPortalOutletDirective],
      declarations: [NbPortalDirective, NbPortalOutletDirective]
    }]
  }], null, null);
})();
var NbGlobalLogicalPosition;
(function(NbGlobalLogicalPosition2) {
  NbGlobalLogicalPosition2["TOP_START"] = "top-start";
  NbGlobalLogicalPosition2["TOP_END"] = "top-end";
  NbGlobalLogicalPosition2["BOTTOM_START"] = "bottom-start";
  NbGlobalLogicalPosition2["BOTTOM_END"] = "bottom-end";
})(NbGlobalLogicalPosition || (NbGlobalLogicalPosition = {}));
var NbGlobalPhysicalPosition;
(function(NbGlobalPhysicalPosition2) {
  NbGlobalPhysicalPosition2["TOP_RIGHT"] = "top-right";
  NbGlobalPhysicalPosition2["TOP_LEFT"] = "top-left";
  NbGlobalPhysicalPosition2["BOTTOM_RIGHT"] = "bottom-right";
  NbGlobalPhysicalPosition2["BOTTOM_LEFT"] = "bottom-left";
})(NbGlobalPhysicalPosition || (NbGlobalPhysicalPosition = {}));
var _NbPositionHelper = class _NbPositionHelper {
  constructor(layoutDirection) {
    this.layoutDirection = layoutDirection;
  }
  toLogicalPosition(position) {
    if (Object.values(NbGlobalLogicalPosition).includes(position)) {
      return position;
    }
    if (this.layoutDirection.isLtr()) {
      return this.toLogicalPositionWhenLtr(position);
    } else {
      return this.toLogicalPositionWhenRtl(position);
    }
  }
  toPhysicalPosition(position) {
    if (Object.values(NbGlobalPhysicalPosition).includes(position)) {
      return position;
    }
    if (this.layoutDirection.isLtr()) {
      return this.toPhysicalPositionWhenLtr(position);
    } else {
      return this.toPhysicalPositionWhenRtl(position);
    }
  }
  isTopPosition(position) {
    const logicalPosition = this.toLogicalPosition(position);
    return logicalPosition === NbGlobalLogicalPosition.TOP_END || logicalPosition === NbGlobalLogicalPosition.TOP_START;
  }
  isRightPosition(position) {
    const physicalPosition = this.toPhysicalPosition(position);
    return physicalPosition === NbGlobalPhysicalPosition.TOP_RIGHT || physicalPosition === NbGlobalPhysicalPosition.BOTTOM_RIGHT;
  }
  toLogicalPositionWhenLtr(position) {
    switch (position) {
      case NbGlobalPhysicalPosition.TOP_RIGHT:
        return NbGlobalLogicalPosition.TOP_END;
      case NbGlobalPhysicalPosition.TOP_LEFT:
        return NbGlobalLogicalPosition.TOP_START;
      case NbGlobalPhysicalPosition.BOTTOM_RIGHT:
        return NbGlobalLogicalPosition.BOTTOM_END;
      case NbGlobalPhysicalPosition.BOTTOM_LEFT:
        return NbGlobalLogicalPosition.BOTTOM_START;
    }
  }
  toLogicalPositionWhenRtl(position) {
    switch (position) {
      case NbGlobalPhysicalPosition.TOP_RIGHT:
        return NbGlobalLogicalPosition.TOP_START;
      case NbGlobalPhysicalPosition.TOP_LEFT:
        return NbGlobalLogicalPosition.TOP_END;
      case NbGlobalPhysicalPosition.BOTTOM_RIGHT:
        return NbGlobalLogicalPosition.BOTTOM_START;
      case NbGlobalPhysicalPosition.BOTTOM_LEFT:
        return NbGlobalLogicalPosition.BOTTOM_END;
    }
  }
  toPhysicalPositionWhenLtr(position) {
    switch (position) {
      case NbGlobalLogicalPosition.TOP_START:
        return NbGlobalPhysicalPosition.TOP_LEFT;
      case NbGlobalLogicalPosition.TOP_END:
        return NbGlobalPhysicalPosition.TOP_RIGHT;
      case NbGlobalLogicalPosition.BOTTOM_START:
        return NbGlobalPhysicalPosition.BOTTOM_LEFT;
      case NbGlobalLogicalPosition.BOTTOM_END:
        return NbGlobalPhysicalPosition.BOTTOM_RIGHT;
    }
  }
  toPhysicalPositionWhenRtl(position) {
    switch (position) {
      case NbGlobalLogicalPosition.TOP_START:
        return NbGlobalPhysicalPosition.TOP_RIGHT;
      case NbGlobalLogicalPosition.TOP_END:
        return NbGlobalPhysicalPosition.TOP_LEFT;
      case NbGlobalLogicalPosition.BOTTOM_START:
        return NbGlobalPhysicalPosition.BOTTOM_RIGHT;
      case NbGlobalLogicalPosition.BOTTOM_END:
        return NbGlobalPhysicalPosition.BOTTOM_LEFT;
    }
  }
};
_NbPositionHelper.ɵfac = function NbPositionHelper_Factory(t) {
  return new (t || _NbPositionHelper)(ɵɵinject(NbLayoutDirectionService));
};
_NbPositionHelper.ɵprov = ɵɵdefineInjectable({
  token: _NbPositionHelper,
  factory: _NbPositionHelper.ɵfac
});
var NbPositionHelper = _NbPositionHelper;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPositionHelper, [{
    type: Injectable
  }], () => [{
    type: NbLayoutDirectionService
  }], null);
})();
var _NbPlatform = class _NbPlatform extends Platform {
};
_NbPlatform.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbPlatform_BaseFactory;
  return function NbPlatform_Factory(t) {
    return (ɵNbPlatform_BaseFactory || (ɵNbPlatform_BaseFactory = ɵɵgetInheritedFactory(_NbPlatform)))(t || _NbPlatform);
  };
})();
_NbPlatform.ɵprov = ɵɵdefineInjectable({
  token: _NbPlatform,
  factory: (t) => Platform.ɵfac(t),
  providedIn: "root"
});
var NbPlatform = _NbPlatform;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPlatform, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useClass: Platform
    }]
  }], null, null);
})();
var _NbViewportRulerAdapter = class _NbViewportRulerAdapter extends ViewportRuler {
  constructor(platform, ngZone, ruler, scroll, document) {
    super(platform, ngZone, document);
    this.ruler = ruler;
    this.scroll = scroll;
  }
  getViewportSize() {
    let res;
    this.ruler.getDimensions().pipe(map((dimensions) => ({
      width: dimensions.clientWidth,
      height: dimensions.clientHeight
    }))).subscribe((rect) => res = rect);
    return res;
  }
  getViewportScrollPosition() {
    let res;
    this.scroll.getPosition().pipe(map((position) => ({
      top: position.y,
      left: position.x
    }))).subscribe((position) => res = position);
    return res;
  }
};
_NbViewportRulerAdapter.ɵfac = function NbViewportRulerAdapter_Factory(t) {
  return new (t || _NbViewportRulerAdapter)(ɵɵinject(NbPlatform), ɵɵinject(NgZone), ɵɵinject(NbLayoutRulerService), ɵɵinject(NbLayoutScrollService), ɵɵinject(NB_DOCUMENT));
};
_NbViewportRulerAdapter.ɵprov = ɵɵdefineInjectable({
  token: _NbViewportRulerAdapter,
  factory: _NbViewportRulerAdapter.ɵfac
});
var NbViewportRulerAdapter = _NbViewportRulerAdapter;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbViewportRulerAdapter, [{
    type: Injectable
  }], () => [{
    type: NbPlatform
  }, {
    type: NgZone
  }, {
    type: NbLayoutRulerService
  }, {
    type: NbLayoutScrollService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
function throwLayoutNotFoundError() {
  throw new Error(`[NbOverlayContainerAdapter]: Layout not found.
  When using Nebular '<nb-layout>' is required and should wrap other nebular components.`);
}
var _NbOverlayContainerAdapter = class _NbOverlayContainerAdapter extends NbOverlayContainer {
  setContainer(container) {
    this.container = container;
  }
  clearContainer() {
    this.container = null;
    this._containerElement = null;
  }
  _createContainer() {
    this.checkContainer();
    const container = this._document.createElement("div");
    container.classList.add("cdk-overlay-container");
    this.container.appendChild(container);
    this._containerElement = container;
  }
  checkContainer() {
    if (!this.container) {
      throwLayoutNotFoundError();
    }
  }
};
_NbOverlayContainerAdapter.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbOverlayContainerAdapter_BaseFactory;
  return function NbOverlayContainerAdapter_Factory(t) {
    return (ɵNbOverlayContainerAdapter_BaseFactory || (ɵNbOverlayContainerAdapter_BaseFactory = ɵɵgetInheritedFactory(_NbOverlayContainerAdapter)))(t || _NbOverlayContainerAdapter);
  };
})();
_NbOverlayContainerAdapter.ɵprov = ɵɵdefineInjectable({
  token: _NbOverlayContainerAdapter,
  factory: _NbOverlayContainerAdapter.ɵfac
});
var NbOverlayContainerAdapter = _NbOverlayContainerAdapter;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayContainerAdapter, [{
    type: Injectable
  }], null, null);
})();
var NbAdjustment;
(function(NbAdjustment2) {
  NbAdjustment2["NOOP"] = "noop";
  NbAdjustment2["CLOCKWISE"] = "clockwise";
  NbAdjustment2["COUNTERCLOCKWISE"] = "counterclockwise";
  NbAdjustment2["VERTICAL"] = "vertical";
  NbAdjustment2["HORIZONTAL"] = "horizontal";
})(NbAdjustment || (NbAdjustment = {}));
var NbPosition;
(function(NbPosition2) {
  NbPosition2["TOP"] = "top";
  NbPosition2["BOTTOM"] = "bottom";
  NbPosition2["LEFT"] = "left";
  NbPosition2["RIGHT"] = "right";
  NbPosition2["START"] = "start";
  NbPosition2["END"] = "end";
  NbPosition2["TOP_END"] = "top-end";
  NbPosition2["TOP_START"] = "top-start";
  NbPosition2["BOTTOM_END"] = "bottom-end";
  NbPosition2["BOTTOM_START"] = "bottom-start";
  NbPosition2["END_TOP"] = "end-top";
  NbPosition2["END_BOTTOM"] = "end-bottom";
  NbPosition2["START_TOP"] = "start-top";
  NbPosition2["START_BOTTOM"] = "start-bottom";
})(NbPosition || (NbPosition = {}));
var POSITIONS = {
  [NbPosition.RIGHT](offset) {
    return {
      originX: "end",
      originY: "center",
      overlayX: "start",
      overlayY: "center",
      offsetX: offset
    };
  },
  [NbPosition.BOTTOM](offset) {
    return {
      originX: "center",
      originY: "bottom",
      overlayX: "center",
      overlayY: "top",
      offsetY: offset
    };
  },
  [NbPosition.LEFT](offset) {
    return {
      originX: "start",
      originY: "center",
      overlayX: "end",
      overlayY: "center",
      offsetX: -offset
    };
  },
  [NbPosition.TOP](offset) {
    return {
      originX: "center",
      originY: "top",
      overlayX: "center",
      overlayY: "bottom",
      offsetY: -offset
    };
  },
  [NbPosition.START](offset) {
    return this[NbPosition.LEFT](offset);
  },
  [NbPosition.END](offset) {
    return this[NbPosition.RIGHT](offset);
  },
  [NbPosition.END_TOP](offset) {
    return {
      originX: "end",
      originY: "bottom",
      overlayX: "start",
      overlayY: "bottom",
      offsetX: offset
    };
  },
  [NbPosition.END_BOTTOM](offset) {
    return {
      originX: "end",
      originY: "top",
      overlayX: "start",
      overlayY: "top",
      offsetX: offset
    };
  },
  [NbPosition.BOTTOM_START](offset) {
    return {
      originX: "end",
      originY: "bottom",
      overlayX: "end",
      overlayY: "top",
      offsetY: offset
    };
  },
  [NbPosition.BOTTOM_END](offset) {
    return {
      originX: "start",
      originY: "bottom",
      overlayX: "start",
      overlayY: "top",
      offsetY: offset
    };
  },
  [NbPosition.START_TOP](offset) {
    return {
      originX: "start",
      originY: "bottom",
      overlayX: "end",
      overlayY: "bottom",
      offsetX: -offset
    };
  },
  [NbPosition.START_BOTTOM](offset) {
    return {
      originX: "start",
      originY: "top",
      overlayX: "end",
      overlayY: "top",
      offsetX: -offset
    };
  },
  [NbPosition.TOP_START](offset) {
    return {
      originX: "end",
      originY: "top",
      overlayX: "end",
      overlayY: "bottom",
      offsetY: -offset
    };
  },
  [NbPosition.TOP_END](offset) {
    return {
      originX: "start",
      originY: "top",
      overlayX: "start",
      overlayY: "bottom",
      offsetY: -offset
    };
  }
};
var RTL_PHYSICAL_POSITIONS = __spreadProps(__spreadValues({}, POSITIONS), {
  [NbPosition.RIGHT](offset) {
    return {
      originX: "start",
      originY: "center",
      overlayX: "end",
      overlayY: "center",
      offsetX: offset
    };
  },
  [NbPosition.LEFT](offset) {
    return {
      originX: "end",
      originY: "center",
      overlayX: "start",
      overlayY: "center",
      offsetX: -offset
    };
  },
  [NbPosition.START](offset) {
    return this[NbPosition.RIGHT](offset);
  },
  [NbPosition.END](offset) {
    return this[NbPosition.LEFT](offset);
  }
});
var COUNTER_CLOCKWISE_POSITIONS = [NbPosition.TOP, NbPosition.TOP_END, NbPosition.TOP_START, NbPosition.START, NbPosition.START_TOP, NbPosition.START_BOTTOM, NbPosition.BOTTOM, NbPosition.BOTTOM_START, NbPosition.BOTTOM_END, NbPosition.END, NbPosition.END_BOTTOM, NbPosition.END_TOP];
var CLOCKWISE_POSITIONS = [NbPosition.TOP, NbPosition.TOP_START, NbPosition.TOP_END, NbPosition.END, NbPosition.END_TOP, NbPosition.END_BOTTOM, NbPosition.BOTTOM, NbPosition.BOTTOM_END, NbPosition.BOTTOM_START, NbPosition.START, NbPosition.START_BOTTOM, NbPosition.START_TOP];
var VERTICAL_POSITIONS = [NbPosition.BOTTOM, NbPosition.TOP];
var HORIZONTAL_POSITIONS = [NbPosition.START, NbPosition.END];
function comparePositions(p1, p2) {
  return p1.originX === p2.originX && p1.originY === p2.originY && p1.overlayX === p2.overlayX && p1.overlayY === p2.overlayY;
}
var NbAdjustableConnectedPositionStrategy = class extends NbFlexibleConnectedPositionStrategy {
  constructor() {
    super(...arguments);
    this._offset = 15;
    this.positionChange = this.positionChanges.pipe(map((positionChange) => positionChange.connectionPair), map((connectionPair) => {
      return this.appliedPositions.find(({
        connectedPosition
      }) => {
        return comparePositions(connectedPosition, connectionPair);
      }).key;
    }));
  }
  attach(overlayRef) {
    this.applyPositions();
    super.attach(overlayRef);
  }
  direction(direction) {
    this._direction = direction;
    return this;
  }
  apply() {
    this.applyPositions();
    super.apply();
  }
  position(position) {
    this._position = position;
    return this;
  }
  adjustment(adjustment) {
    this._adjustment = adjustment;
    return this;
  }
  offset(offset) {
    this._offset = offset;
    return this;
  }
  applyPositions() {
    const positions = this.createPositions();
    this.persistChosenPositions(positions);
    this.withPositions(this.appliedPositions.map(({
      connectedPosition
    }) => connectedPosition));
  }
  createPositions() {
    switch (this._adjustment) {
      case NbAdjustment.NOOP:
        return [this._position];
      case NbAdjustment.CLOCKWISE:
        return this.reorderPreferredPositions(CLOCKWISE_POSITIONS);
      case NbAdjustment.COUNTERCLOCKWISE:
        return this.reorderPreferredPositions(COUNTER_CLOCKWISE_POSITIONS);
      case NbAdjustment.HORIZONTAL:
        return this.reorderPreferredPositions(HORIZONTAL_POSITIONS);
      case NbAdjustment.VERTICAL:
        return this.reorderPreferredPositions(VERTICAL_POSITIONS);
    }
  }
  mapToLogicalPosition(position) {
    if (position === NbPosition.LEFT) {
      return this._direction === NbLayoutDirection.LTR ? NbPosition.START : NbPosition.END;
    }
    if (position === NbPosition.RIGHT) {
      return this._direction === NbLayoutDirection.LTR ? NbPosition.END : NbPosition.START;
    }
    return position;
  }
  persistChosenPositions(positions) {
    const positionGrid = this._direction === NbLayoutDirection.RTL ? RTL_PHYSICAL_POSITIONS : POSITIONS;
    this.appliedPositions = positions.map((position) => ({
      key: position,
      connectedPosition: positionGrid[position](this._offset)
    }));
  }
  reorderPreferredPositions(positions) {
    const startPosition = this.mapToLogicalPosition(this._position);
    const startPositionIndex = positions.indexOf(startPosition);
    const firstPart = positions.slice(startPositionIndex);
    const secondPart = positions.slice(0, startPositionIndex);
    return firstPart.concat(secondPart);
  }
};
var NbGlobalPositionStrategy = class extends GlobalPositionStrategy {
  position(position) {
    switch (position) {
      case NbGlobalLogicalPosition.TOP_START:
        return this.top().left();
      case NbGlobalLogicalPosition.TOP_END:
        return this.top().right();
      case NbGlobalLogicalPosition.BOTTOM_START:
        return this.bottom().left();
      case NbGlobalLogicalPosition.BOTTOM_END:
        return this.bottom().right();
    }
  }
};
var _NbPositionBuilderService = class _NbPositionBuilderService {
  constructor(document, viewportRuler, platform, positionBuilder, overlayContainer) {
    this.document = document;
    this.viewportRuler = viewportRuler;
    this.platform = platform;
    this.positionBuilder = positionBuilder;
    this.overlayContainer = overlayContainer;
  }
  global() {
    return new NbGlobalPositionStrategy();
  }
  connectedTo(elementRef) {
    return new NbAdjustableConnectedPositionStrategy(elementRef, this.viewportRuler, this.document, this.platform, this.overlayContainer).withFlexibleDimensions(false).withPush(false);
  }
};
_NbPositionBuilderService.ɵfac = function NbPositionBuilderService_Factory(t) {
  return new (t || _NbPositionBuilderService)(ɵɵinject(NB_DOCUMENT), ɵɵinject(NbViewportRulerAdapter), ɵɵinject(NbPlatform), ɵɵinject(NbOverlayPositionBuilder), ɵɵinject(NbOverlayContainerAdapter));
};
_NbPositionBuilderService.ɵprov = ɵɵdefineInjectable({
  token: _NbPositionBuilderService,
  factory: _NbPositionBuilderService.ɵfac
});
var NbPositionBuilderService = _NbPositionBuilderService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPositionBuilderService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: NbPlatform
  }, {
    type: NbOverlayPositionBuilder
  }, {
    type: NbOverlayContainerAdapter
  }], null);
})();
var _NbPositionedContainerComponent = class _NbPositionedContainerComponent {
  get top() {
    return this.position === NbPosition.TOP;
  }
  get topStart() {
    return this.position === NbPosition.TOP_START;
  }
  get topEnd() {
    return this.position === NbPosition.TOP_END;
  }
  get right() {
    return this.position === NbPosition.RIGHT || this.position === NbPosition.END;
  }
  get endTop() {
    return this.position === NbPosition.END_TOP;
  }
  get endBottom() {
    return this.position === NbPosition.END_BOTTOM;
  }
  get bottom() {
    return this.position === NbPosition.BOTTOM;
  }
  get bottomStart() {
    return this.position === NbPosition.BOTTOM_START;
  }
  get bottomEnd() {
    return this.position === NbPosition.BOTTOM_END;
  }
  get left() {
    return this.position === NbPosition.LEFT || this.position === NbPosition.START;
  }
  get startTop() {
    return this.position === NbPosition.START_TOP;
  }
  get startBottom() {
    return this.position === NbPosition.START_BOTTOM;
  }
};
_NbPositionedContainerComponent.ɵfac = function NbPositionedContainerComponent_Factory(t) {
  return new (t || _NbPositionedContainerComponent)();
};
_NbPositionedContainerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbPositionedContainerComponent,
  selectors: [["ng-component"]],
  hostVars: 24,
  hostBindings: function NbPositionedContainerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("nb-overlay-top", ctx.top)("nb-overlay-top-start", ctx.topStart)("nb-overlay-top-end", ctx.topEnd)("nb-overlay-right", ctx.right)("nb-overlay-end-top", ctx.endTop)("nb-overlay-end-bottom", ctx.endBottom)("nb-overlay-bottom", ctx.bottom)("nb-overlay-bottom-start", ctx.bottomStart)("nb-overlay-bottom-end", ctx.bottomEnd)("nb-overlay-left", ctx.left)("nb-overlay-start-top", ctx.startTop)("nb-overlay-start-bottom", ctx.startBottom);
    }
  },
  inputs: {
    position: "position"
  },
  decls: 0,
  vars: 0,
  template: function NbPositionedContainerComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
var NbPositionedContainerComponent = _NbPositionedContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPositionedContainerComponent, [{
    type: Component,
    args: [{
      template: ""
    }]
  }], null, {
    position: [{
      type: Input
    }],
    top: [{
      type: HostBinding,
      args: ["class.nb-overlay-top"]
    }],
    topStart: [{
      type: HostBinding,
      args: ["class.nb-overlay-top-start"]
    }],
    topEnd: [{
      type: HostBinding,
      args: ["class.nb-overlay-top-end"]
    }],
    right: [{
      type: HostBinding,
      args: ["class.nb-overlay-right"]
    }],
    endTop: [{
      type: HostBinding,
      args: ["class.nb-overlay-end-top"]
    }],
    endBottom: [{
      type: HostBinding,
      args: ["class.nb-overlay-end-bottom"]
    }],
    bottom: [{
      type: HostBinding,
      args: ["class.nb-overlay-bottom"]
    }],
    bottomStart: [{
      type: HostBinding,
      args: ["class.nb-overlay-bottom-start"]
    }],
    bottomEnd: [{
      type: HostBinding,
      args: ["class.nb-overlay-bottom-end"]
    }],
    left: [{
      type: HostBinding,
      args: ["class.nb-overlay-left"]
    }],
    startTop: [{
      type: HostBinding,
      args: ["class.nb-overlay-start-top"]
    }],
    startBottom: [{
      type: HostBinding,
      args: ["class.nb-overlay-start-bottom"]
    }]
  });
})();
var _NbOverlayContainerComponent = class _NbOverlayContainerComponent {
  constructor(vcr, injector, changeDetectorRef) {
    this.vcr = vcr;
    this.injector = injector;
    this.changeDetectorRef = changeDetectorRef;
    this.isAttached = false;
  }
  get isStringContent() {
    return !!this.content;
  }
  attachComponentPortal(portal, context) {
    portal.injector = this.createChildInjector(portal.componentFactoryResolver);
    const componentRef = this.portalOutlet.attachComponentPortal(portal);
    if (context) {
      Object.assign(componentRef.instance, context);
    }
    componentRef.changeDetectorRef.markForCheck();
    componentRef.changeDetectorRef.detectChanges();
    this.isAttached = true;
    return componentRef;
  }
  attachTemplatePortal(portal) {
    const templateRef = this.portalOutlet.attachTemplatePortal(portal);
    templateRef.detectChanges();
    this.isAttached = true;
    return templateRef;
  }
  attachStringContent(content) {
    this.content = content;
    this.changeDetectorRef.markForCheck();
    this.changeDetectorRef.detectChanges();
    this.isAttached = true;
  }
  detach() {
    if (this.portalOutlet.hasAttached()) {
      this.portalOutlet.detach();
    }
    this.attachStringContent(null);
    this.isAttached = false;
  }
  createChildInjector(cfr) {
    return new NbPortalInjector(this.injector, new WeakMap([[ComponentFactoryResolver$1, cfr]]));
  }
};
_NbOverlayContainerComponent.ɵfac = function NbOverlayContainerComponent_Factory(t) {
  return new (t || _NbOverlayContainerComponent)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbOverlayContainerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbOverlayContainerComponent,
  selectors: [["nb-overlay-container"]],
  viewQuery: function NbOverlayContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbPortalOutletDirective, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);
    }
  },
  decls: 2,
  vars: 1,
  consts: [["class", "primitive-overlay", 4, "ngIf"], ["nbPortalOutlet", ""], [1, "primitive-overlay"]],
  template: function NbOverlayContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbOverlayContainerComponent_div_0_Template, 2, 1, "div", 0)(1, NbOverlayContainerComponent_ng_template_1_Template, 0, 0, "ng-template", 1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.isStringContent);
    }
  },
  dependencies: [NbPortalOutletDirective, NgIf],
  encapsulation: 2
});
var NbOverlayContainerComponent = _NbOverlayContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-overlay-container",
      template: `
    <div *ngIf="isStringContent" class="primitive-overlay">{{ content }}</div>
    <ng-template nbPortalOutlet></ng-template>
  `
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: Injector
  }, {
    type: ChangeDetectorRef
  }], {
    portalOutlet: [{
      type: ViewChild,
      args: [NbPortalOutletDirective, {
        static: true
      }]
    }]
  });
})();
function patch(container, containerContext) {
  Object.assign(container.instance, containerContext);
  container.changeDetectorRef.detectChanges();
  return container;
}
function createContainer(ref, container, context, componentFactoryResolver) {
  const containerRef = ref.attach(new NbComponentPortal(container, null, null, componentFactoryResolver));
  patch(containerRef, context);
  return containerRef;
}
var _NbOverlayService = class _NbOverlayService {
  constructor(overlay, layoutDirection) {
    this.overlay = overlay;
    this.layoutDirection = layoutDirection;
  }
  get scrollStrategies() {
    return this.overlay.scrollStrategies;
  }
  create(config) {
    const overlayRef = this.overlay.create(config);
    this.layoutDirection.onDirectionChange().subscribe((dir) => overlayRef.setDirection(dir));
    return overlayRef;
  }
};
_NbOverlayService.ɵfac = function NbOverlayService_Factory(t) {
  return new (t || _NbOverlayService)(ɵɵinject(NbOverlay), ɵɵinject(NbLayoutDirectionService));
};
_NbOverlayService.ɵprov = ɵɵdefineInjectable({
  token: _NbOverlayService,
  factory: _NbOverlayService.ɵfac
});
var NbOverlayService = _NbOverlayService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayService, [{
    type: Injectable
  }], () => [{
    type: NbOverlay
  }, {
    type: NbLayoutDirectionService
  }], null);
})();
var _NbScrollDispatcherAdapter = class _NbScrollDispatcherAdapter extends ScrollDispatcher {
  constructor(ngZone, platform, scrollService, document) {
    super(ngZone, platform, document);
    this.scrollService = scrollService;
  }
  scrolled(auditTimeInMs) {
    return merge(super.scrolled(auditTimeInMs), this.scrollService.onScroll());
  }
};
_NbScrollDispatcherAdapter.ɵfac = function NbScrollDispatcherAdapter_Factory(t) {
  return new (t || _NbScrollDispatcherAdapter)(ɵɵinject(NgZone), ɵɵinject(NbPlatform), ɵɵinject(NbLayoutScrollService), ɵɵinject(NB_DOCUMENT));
};
_NbScrollDispatcherAdapter.ɵprov = ɵɵdefineInjectable({
  token: _NbScrollDispatcherAdapter,
  factory: _NbScrollDispatcherAdapter.ɵfac
});
var NbScrollDispatcherAdapter = _NbScrollDispatcherAdapter;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbScrollDispatcherAdapter, [{
    type: Injectable
  }], () => [{
    type: NgZone
  }, {
    type: NbPlatform
  }, {
    type: NbLayoutScrollService
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var _NbBlockScrollStrategyAdapter = class _NbBlockScrollStrategyAdapter extends BlockScrollStrategy {
  constructor(document, viewportRuler, scrollService) {
    super(viewportRuler, document);
    this.scrollService = scrollService;
  }
  enable() {
    super.enable();
    this.scrollService.scrollable(false);
  }
  disable() {
    super.disable();
    this.scrollService.scrollable(true);
  }
};
_NbBlockScrollStrategyAdapter.ɵfac = function NbBlockScrollStrategyAdapter_Factory(t) {
  return new (t || _NbBlockScrollStrategyAdapter)(ɵɵinject(NB_DOCUMENT), ɵɵinject(NbViewportRulerAdapter), ɵɵinject(NbLayoutScrollService));
};
_NbBlockScrollStrategyAdapter.ɵprov = ɵɵdefineInjectable({
  token: _NbBlockScrollStrategyAdapter,
  factory: _NbBlockScrollStrategyAdapter.ɵfac
});
var NbBlockScrollStrategyAdapter = _NbBlockScrollStrategyAdapter;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBlockScrollStrategyAdapter, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: NbLayoutScrollService
  }], null);
})();
var _NbScrollStrategyOptions = class _NbScrollStrategyOptions extends ScrollStrategyOptions {
  constructor(scrollService, scrollDispatcher, viewportRuler, ngZone, document) {
    super(scrollDispatcher, viewportRuler, ngZone, document);
    this.scrollService = scrollService;
    this.scrollDispatcher = scrollDispatcher;
    this.viewportRuler = viewportRuler;
    this.ngZone = ngZone;
    this.document = document;
    this.block = () => new NbBlockScrollStrategyAdapter(this.document, this.viewportRuler, this.scrollService);
  }
};
_NbScrollStrategyOptions.ɵfac = function NbScrollStrategyOptions_Factory(t) {
  return new (t || _NbScrollStrategyOptions)(ɵɵinject(NbLayoutScrollService), ɵɵinject(ScrollDispatcher), ɵɵinject(NbViewportRulerAdapter), ɵɵinject(NgZone), ɵɵinject(NB_DOCUMENT));
};
_NbScrollStrategyOptions.ɵprov = ɵɵdefineInjectable({
  token: _NbScrollStrategyOptions,
  factory: _NbScrollStrategyOptions.ɵfac
});
var NbScrollStrategyOptions = _NbScrollStrategyOptions;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbScrollStrategyOptions, [{
    type: Injectable
  }], () => [{
    type: NbLayoutScrollService
  }, {
    type: ScrollDispatcher
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var _NbCdkAdapterModule = class _NbCdkAdapterModule {
  static forRoot() {
    return {
      ngModule: _NbCdkAdapterModule,
      providers: [NbViewportRulerAdapter, NbOverlayContainerAdapter, NbBlockScrollStrategyAdapter, NbScrollDispatcherAdapter, NbScrollStrategyOptions, {
        provide: OverlayContainer,
        useExisting: NbOverlayContainerAdapter
      }, {
        provide: NbOverlayContainer,
        useExisting: NbOverlayContainerAdapter
      }, {
        provide: ScrollDispatcher,
        useExisting: NbScrollDispatcherAdapter
      }, {
        provide: ScrollStrategyOptions,
        useExisting: NbScrollStrategyOptions
      }]
    };
  }
};
_NbCdkAdapterModule.ɵfac = function NbCdkAdapterModule_Factory(t) {
  return new (t || _NbCdkAdapterModule)();
};
_NbCdkAdapterModule.ɵmod = ɵɵdefineNgModule({
  type: _NbCdkAdapterModule
});
_NbCdkAdapterModule.ɵinj = ɵɵdefineInjector({});
var NbCdkAdapterModule = _NbCdkAdapterModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCdkAdapterModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var NbTrigger;
(function(NbTrigger2) {
  NbTrigger2["NOOP"] = "noop";
  NbTrigger2["CLICK"] = "click";
  NbTrigger2["HOVER"] = "hover";
  NbTrigger2["HINT"] = "hint";
  NbTrigger2["FOCUS"] = "focus";
})(NbTrigger || (NbTrigger = {}));
var NbTriggerStrategyBase = class {
  destroy() {
    this.destroyed$.next();
  }
  isNotOnHostOrContainer(element) {
    return !this.isOnHost(element) && !this.isOnContainer(element);
  }
  isOnHostOrContainer(element) {
    return this.isOnHost(element) || this.isOnContainer(element);
  }
  isOnHost(element) {
    return this.host.contains(element);
  }
  isOnContainer(element) {
    return this.container() && this.container().location.nativeElement.contains(element);
  }
  constructor(document, host, container) {
    this.document = document;
    this.host = host;
    this.container = container;
    this.destroyed$ = new Subject();
  }
};
var NbClickTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.click$ = fromEvent(this.document, "click").pipe(map((event) => [!this.container() && this.isOnHost(event.target), event]), share(), takeUntil(this.destroyed$));
    this.show$ = this.click$.pipe(filter(([shouldShow]) => shouldShow), map(([, event]) => event), takeUntil(this.destroyed$));
    this.hide$ = this.click$.pipe(filter(([shouldShow, event]) => !shouldShow && !this.isOnContainer(event.target)), map(([, event]) => event), takeUntil(this.destroyed$));
  }
};
var NbHoverTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.show$ = fromEvent(this.host, "mouseenter").pipe(
      filter(() => !this.container()),
      // this `delay & takeUntil & repeat` operators combination is a synonym for `conditional debounce`
      // meaning that if one event occurs in some time after the initial one we won't react to it
      delay(100),
      // eslint-disable-next-line rxjs/no-unsafe-takeuntil
      takeUntil(fromEvent(this.host, "mouseleave")),
      repeat(),
      takeUntil(this.destroyed$)
    );
    this.hide$ = fromEvent(this.host, "mouseleave").pipe(switchMap(() => fromEvent(this.document, "mousemove").pipe(debounceTime(100), takeWhile(() => !!this.container()), filter((event) => this.isNotOnHostOrContainer(event.target)))), takeUntil(this.destroyed$));
  }
};
var NbHintTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.show$ = fromEvent(this.host, "mouseenter").pipe(
      // this `delay & takeUntil & repeat` operators combination is a synonym for `conditional debounce`
      // meaning that if one event occurs in some time after the initial one we won't react to it
      delay(100),
      // eslint-disable-next-line rxjs/no-unsafe-takeuntil
      takeUntil(fromEvent(this.host, "mouseleave")),
      repeat(),
      takeUntil(this.destroyed$)
    );
    this.hide$ = fromEvent(this.host, "mouseleave").pipe(takeUntil(this.destroyed$));
  }
};
var NbFocusTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.focusOut$ = fromEvent(this.host, "focusout").pipe(switchMap(() => fromEvent(this.document, "focusin").pipe(takeWhile(() => !!this.container()), filter((event) => this.isNotOnHostOrContainer(event.target)))), takeUntil(this.destroyed$));
    this.clickIn$ = fromEvent(this.host, "click").pipe(filter(() => !this.container()), takeUntil(this.destroyed$));
    this.clickOut$ = fromEvent(this.document, "click").pipe(
      filter(() => !!this.container()),
      /**
       * Event target of `click` could be different from `activeElement`.
       * If during click you return focus to the host, it won't be opened.
       */
      filter((event) => {
        if (this.isNotOnHostOrContainer(event.target)) {
          return this.isNotOnHostOrContainer(this.document.activeElement);
        }
        return false;
      }),
      takeUntil(this.destroyed$)
    );
    this.tabKeyPress$ = fromEvent(this.document, "keydown").pipe(filter((event) => event.keyCode === 9), filter(() => !!this.container()), takeUntil(this.destroyed$));
    this.show$ = merge(fromEvent(this.host, "focusin"), this.clickIn$).pipe(
      filter(() => !this.container()),
      debounceTime(100),
      // eslint-disable-next-line rxjs/no-unsafe-takeuntil
      takeUntil(fromEvent(this.host, "focusout")),
      repeat(),
      takeUntil(this.destroyed$)
    );
    this.hide$ = merge(this.focusOut$, this.tabKeyPress$, this.clickOut$).pipe(takeUntil(this.destroyed$));
  }
};
var NbNoopTriggerStrategy = class extends NbTriggerStrategyBase {
  constructor() {
    super(...arguments);
    this.show$ = EMPTY;
    this.hide$ = EMPTY;
  }
};
var _NbTriggerStrategyBuilderService = class _NbTriggerStrategyBuilderService {
  constructor(_document) {
    this._document = _document;
  }
  trigger(trigger2) {
    this._trigger = trigger2;
    return this;
  }
  host(host) {
    this._host = host;
    return this;
  }
  container(container) {
    this._container = container;
    return this;
  }
  build() {
    switch (this._trigger) {
      case NbTrigger.CLICK:
        return new NbClickTriggerStrategy(this._document, this._host, this._container);
      case NbTrigger.HINT:
        return new NbHintTriggerStrategy(this._document, this._host, this._container);
      case NbTrigger.HOVER:
        return new NbHoverTriggerStrategy(this._document, this._host, this._container);
      case NbTrigger.FOCUS:
        return new NbFocusTriggerStrategy(this._document, this._host, this._container);
      case NbTrigger.NOOP:
        return new NbNoopTriggerStrategy(this._document, this._host, this._container);
      default:
        throw new Error("Trigger have to be provided");
    }
  }
};
_NbTriggerStrategyBuilderService.ɵfac = function NbTriggerStrategyBuilderService_Factory(t) {
  return new (t || _NbTriggerStrategyBuilderService)(ɵɵinject(NB_DOCUMENT));
};
_NbTriggerStrategyBuilderService.ɵprov = ɵɵdefineInjectable({
  token: _NbTriggerStrategyBuilderService,
  factory: _NbTriggerStrategyBuilderService.ɵfac
});
var NbTriggerStrategyBuilderService = _NbTriggerStrategyBuilderService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTriggerStrategyBuilderService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var _NbOverlayModule = class _NbOverlayModule {
  static forRoot() {
    return {
      ngModule: _NbOverlayModule,
      providers: [NbPositionBuilderService, NbTriggerStrategyBuilderService, NbOverlayService, NbPositionHelper, ...NbCdkMappingModule.forRoot().providers, ...NbCdkAdapterModule.forRoot().providers, ...NbA11yModule.forRoot().providers]
    };
  }
};
_NbOverlayModule.ɵfac = function NbOverlayModule_Factory(t) {
  return new (t || _NbOverlayModule)();
};
_NbOverlayModule.ɵmod = ɵɵdefineNgModule({
  type: _NbOverlayModule,
  declarations: [NbPositionedContainerComponent, NbOverlayContainerComponent],
  imports: [NbCdkMappingModule, NbSharedModule],
  exports: [NbCdkMappingModule, NbCdkAdapterModule, NbOverlayContainerComponent]
});
_NbOverlayModule.ɵinj = ɵɵdefineInjector({
  imports: [NbCdkMappingModule, NbSharedModule, NbCdkMappingModule, NbCdkAdapterModule]
});
var NbOverlayModule = _NbOverlayModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOverlayModule, [{
    type: NgModule,
    args: [{
      imports: [NbCdkMappingModule, NbSharedModule],
      declarations: [NbPositionedContainerComponent, NbOverlayContainerComponent],
      exports: [NbCdkMappingModule, NbCdkAdapterModule, NbOverlayContainerComponent]
    }]
  }], null, null);
})();
var _NbStatusService = class _NbStatusService {
  constructor() {
    this.coreStatuses = ["basic", "primary", "info", "warning", "danger", "control"];
  }
  isCoreStatus(status) {
    return this.coreStatuses.includes(status);
  }
  isCustomStatus(status) {
    if (this.isValidStatusString(status)) {
      return !this.isCoreStatus(status);
    }
    return false;
  }
  getStatusClass(status) {
    if (this.isValidStatusString(status)) {
      return `status-${status}`;
    }
    return void 0;
  }
  isValidStatusString(status) {
    return typeof status === "string" && status.length > 0;
  }
};
_NbStatusService.ɵfac = function NbStatusService_Factory(t) {
  return new (t || _NbStatusService)();
};
_NbStatusService.ɵprov = ɵɵdefineInjectable({
  token: _NbStatusService,
  factory: _NbStatusService.ɵfac
});
var NbStatusService = _NbStatusService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStatusService, [{
    type: Injectable
  }], null, null);
})();
function windowFactory(platformId) {
  if (isPlatformBrowser(platformId)) {
    return window;
  }
  return void 0;
}
var _NbThemeModule = class _NbThemeModule {
  // TODO: check the options (throw exception?)
  /**
   * Main Theme Module
   *
   * @param nbThemeOptions {NbThemeOptions} Main theme options
   * @param nbJSThemes {NbJSThemeOptions[]} List of JS Themes, will be merged with default themes
   * @param nbMediaBreakpoints {NbMediaBreakpoint} Available media breakpoints
   * @param layoutDirection {NbLayoutDirection} Layout direction
   *
   * @returns {ModuleWithProviders}
   */
  static forRoot(nbThemeOptions = {
    name: "default"
  }, nbJSThemes, nbMediaBreakpoints, layoutDirection) {
    return {
      ngModule: _NbThemeModule,
      providers: [{
        provide: NB_THEME_OPTIONS,
        useValue: nbThemeOptions || {}
      }, {
        provide: NB_BUILT_IN_JS_THEMES,
        useValue: BUILT_IN_THEMES
      }, {
        provide: NB_JS_THEMES,
        useValue: nbJSThemes || []
      }, {
        provide: NB_MEDIA_BREAKPOINTS,
        useValue: nbMediaBreakpoints || DEFAULT_MEDIA_BREAKPOINTS
      }, {
        provide: NB_DOCUMENT,
        useExisting: DOCUMENT
      }, {
        provide: NB_WINDOW,
        useFactory: windowFactory,
        deps: [PLATFORM_ID]
      }, NbJSThemesRegistry, NbThemeService, NbMediaBreakpointsService, NbSpinnerService, {
        provide: NB_LAYOUT_DIRECTION,
        useValue: layoutDirection || NbLayoutDirection.LTR
      }, NbLayoutDirectionService, NbLayoutScrollService, NbLayoutRulerService, ...NbOverlayModule.forRoot().providers, NbStatusService]
    };
  }
};
_NbThemeModule.ɵfac = function NbThemeModule_Factory(t) {
  return new (t || _NbThemeModule)();
};
_NbThemeModule.ɵmod = ɵɵdefineNgModule({
  type: _NbThemeModule,
  imports: [CommonModule]
});
_NbThemeModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
var NbThemeModule = _NbThemeModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbThemeModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      exports: []
    }]
  }], null, null);
})();
var NbColorHelper = class _NbColorHelper {
  static shade(color, weight) {
    return _NbColorHelper.mix("#000000", color, weight);
  }
  static tint(color, weight) {
    return _NbColorHelper.mix("#ffffff", color, weight);
  }
  static mix(color1, color2, weight) {
    const d2h = (d) => d.toString(16);
    const h2d = (h) => parseInt(h, 16);
    let result = "#";
    for (let i = 1; i < 7; i += 2) {
      const firstPart = h2d(color1.substr(i, 2));
      const secondPart = h2d(color2.substr(i, 2));
      const resultPart = d2h(Math.floor(secondPart + (firstPart - secondPart) * (weight / 100)));
      result += ("0" + resultPart).slice(-2);
    }
    return result;
  }
  static hexToRgbA(hex, alpha) {
    let c;
    if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
      c = hex.substring(1).split("");
      if (c.length === 3) {
        c = [c[0], c[0], c[1], c[1], c[2], c[2]];
      }
      c = "0x" + c.join("");
      return "rgba(" + [c >> 16 & 255, c >> 8 & 255, c & 255].join(",") + "," + alpha + ")";
    }
    throw new Error("Bad Hex");
  }
};
var NbIconPackType;
(function(NbIconPackType2) {
  NbIconPackType2["SVG"] = "svg";
  NbIconPackType2["FONT"] = "font";
})(NbIconPackType || (NbIconPackType = {}));
var NbFontIcon = class {
  constructor(name, content, params = {}) {
    this.name = name;
    this.content = content;
    this.params = params;
  }
  getClasses(options) {
    const classes = [];
    if (this.params.packClass) {
      classes.push(this.params.packClass);
    }
    const name = this.params.iconClassPrefix ? `${this.params.iconClassPrefix}-${this.name}` : this.name;
    classes.push(name);
    return classes;
  }
  getContent(options) {
    return this.content;
  }
};
var NbSvgIcon = class {
  constructor(name, content, params = {}) {
    this.name = name;
    this.content = content;
    this.params = params;
  }
  getClasses(options) {
    const classes = [];
    if (this.params.packClass) {
      classes.push(this.params.packClass);
    }
    return classes;
  }
  getContent(options) {
    return this.content;
  }
};
var NbIconDefinition = class {
};
function throwPackNotFoundError(name) {
  throw Error(`Icon Pack '${name}' is not registered`);
}
function throwNoDefaultPackError() {
  throw Error("Default pack is not registered.");
}
function throwWrongPackTypeError(name, type, desiredType) {
  throw Error(`Pack '${name}' is not an '${desiredType}' Pack and its type is '${type}'`);
}
var _NbIconLibraries = class _NbIconLibraries {
  constructor() {
    this.packs = /* @__PURE__ */ new Map();
  }
  /**
   * Registers new Svg icon pack
   * @param {string} name
   * @param {NbIcon} icons
   * @param {NbIconPackParams} params
   */
  registerSvgPack(name, icons, params = {}) {
    this.packs.set(name, {
      name,
      icons: new Map(Object.entries(icons)),
      params,
      type: NbIconPackType.SVG
    });
  }
  /**
   * Registers new font pack
   * @param {string} name
   * @param {NbIconPackParams} params
   */
  registerFontPack(name, params = {}) {
    this.packs.set(name, {
      name,
      params,
      icons: /* @__PURE__ */ new Map(),
      type: NbIconPackType.FONT
    });
  }
  /**
   * Returns pack by name
   * @param {string} name
   */
  getPack(name) {
    return this.packs.get(name);
  }
  /**
   * Sets pack as a default
   * @param {string} name
   */
  setDefaultPack(name) {
    if (!this.packs.has(name)) {
      throwPackNotFoundError(name);
    }
    this.defaultPack = this.packs.get(name);
  }
  /**
   * Returns Svg icon
   * @param {string} name
   * @param {string} pack
   *
   * @returns NbIconDefinition
   */
  getSvgIcon(name, pack) {
    const iconsPack = pack ? this.getPackOrThrow(pack) : this.getDefaultPackOrThrow();
    if (iconsPack.type !== NbIconPackType.SVG) {
      throwWrongPackTypeError(iconsPack.name, iconsPack.type, "SVG");
    }
    const icon = this.getIconFromPack(name, iconsPack);
    if (!icon) {
      return null;
    }
    return {
      name,
      pack: iconsPack.name,
      type: NbIconPackType.SVG,
      icon: this.createSvgIcon(name, icon, iconsPack.params)
    };
  }
  /**
   * Returns Font icon
   * @param {string} name
   * @param {string} pack
   *
   * @returns NbIconDefinition
   */
  getFontIcon(name, pack) {
    const iconsPack = pack ? this.getPackOrThrow(pack) : this.getDefaultPackOrThrow();
    if (iconsPack.type !== NbIconPackType.FONT) {
      throwWrongPackTypeError(iconsPack.name, iconsPack.type, "Font");
    }
    const icon = this.getIconFromPack(name, iconsPack) ?? "";
    const iconContent = iconsPack.params.ligature ? name : icon;
    return {
      name,
      pack: iconsPack.name,
      type: NbIconPackType.FONT,
      icon: this.createFontIcon(name, iconContent, iconsPack.params)
    };
  }
  /**
   * Returns an icon
   * @param {string} name
   * @param {string} pack
   *
   * @returns NbIconDefinition
   */
  getIcon(name, pack) {
    const iconsPack = pack ? this.getPackOrThrow(pack) : this.getDefaultPackOrThrow();
    if (iconsPack.type === NbIconPackType.SVG) {
      return this.getSvgIcon(name, pack);
    }
    return this.getFontIcon(name, pack);
  }
  createSvgIcon(name, content, params) {
    return content instanceof NbSvgIcon ? content : new NbSvgIcon(name, content, params);
  }
  createFontIcon(name, content, params) {
    return content instanceof NbFontIcon ? content : new NbFontIcon(name, content, params);
  }
  getPackOrThrow(name) {
    const pack = this.packs.get(name);
    if (!pack) {
      throwPackNotFoundError(name);
    }
    return pack;
  }
  getDefaultPackOrThrow() {
    if (!this.defaultPack) {
      throwNoDefaultPackError();
    }
    return this.defaultPack;
  }
  getIconFromPack(name, pack) {
    if (pack.icons.has(name)) {
      return pack.icons.get(name);
    }
    return null;
  }
};
_NbIconLibraries.ɵfac = function NbIconLibraries_Factory(t) {
  return new (t || _NbIconLibraries)();
};
_NbIconLibraries.ɵprov = ɵɵdefineInjectable({
  token: _NbIconLibraries,
  factory: _NbIconLibraries.ɵfac,
  providedIn: "root"
});
var NbIconLibraries = _NbIconLibraries;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbIconLibraries, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _NbIconComponent = class _NbIconComponent {
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  /**
   * Sets all icon configurable properties via config object.
   * If passed value is a string set icon name.
   * @docs-private
   */
  get config() {
    return this._config;
  }
  set config(value) {
    if (!value) {
      return;
    }
    this._config = value;
    if (typeof value === "string") {
      this.icon = value;
    } else {
      this.icon = value.icon;
      this.pack = value.pack;
      this.status = value.status;
      this.options = value.options;
    }
  }
  constructor(sanitizer, iconLibrary, el, renderer, statusService) {
    this.sanitizer = sanitizer;
    this.iconLibrary = iconLibrary;
    this.el = el;
    this.renderer = renderer;
    this.statusService = statusService;
    this.prevClasses = [];
    this.html = "";
  }
  ngOnInit() {
    this.iconDef = this.renderIcon(this.icon, this.pack, this.options);
  }
  ngOnChanges() {
    const iconDef = this.iconLibrary.getIcon(this.icon, this.pack);
    if (iconDef) {
      this.renderIcon(this.icon, this.pack, this.options);
    } else {
      this.clearIcon();
    }
  }
  renderIcon(name, pack, options) {
    const iconDefinition = this.iconLibrary.getIcon(name, pack);
    if (!iconDefinition) {
      return void 0;
    }
    const content = iconDefinition.icon.getContent(options);
    if (content) {
      this.html = this.sanitizer.bypassSecurityTrustHtml(content);
    }
    this.assignClasses(iconDefinition.icon.getClasses(options));
    return iconDefinition;
  }
  clearIcon() {
    this.html = "";
    this.assignClasses([]);
  }
  assignClasses(classes) {
    this.prevClasses.forEach((className) => {
      this.renderer.removeClass(this.el.nativeElement, className);
    });
    classes.forEach((className) => {
      this.renderer.addClass(this.el.nativeElement, className);
    });
    this.prevClasses = classes;
  }
};
_NbIconComponent.ɵfac = function NbIconComponent_Factory(t) {
  return new (t || _NbIconComponent)(ɵɵdirectiveInject(DomSanitizer), ɵɵdirectiveInject(NbIconLibraries), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NbStatusService));
};
_NbIconComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbIconComponent,
  selectors: [["nb-icon"]],
  hostVars: 17,
  hostBindings: function NbIconComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵhostProperty("innerHtml", ctx.html, ɵɵsanitizeHtml);
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    }
  },
  inputs: {
    icon: "icon",
    pack: "pack",
    options: "options",
    status: "status",
    config: "config"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 0,
  vars: 0,
  template: function NbIconComponent_Template(rf, ctx) {
  },
  styles: ["[_nghost-%COMP%]{display:inline-block}"],
  changeDetection: 0
});
var NbIconComponent = _NbIconComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbIconComponent, [{
    type: Component,
    args: [{
      selector: "nb-icon",
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [":host{display:inline-block}\n"]
    }]
  }], () => [{
    type: DomSanitizer
  }, {
    type: NbIconLibraries
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: NbStatusService
  }], {
    html: [{
      type: HostBinding,
      args: ["innerHtml"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    icon: [{
      type: Input
    }],
    pack: [{
      type: Input
    }],
    options: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    config: [{
      type: Input
    }]
  });
})();
var _NbIconModule = class _NbIconModule {
  constructor(iconsLibrary) {
    this.iconsLibrary = iconsLibrary;
    this.essentialsPackName = "nebular-essentials";
    if (this.iconsLibrary.getPack(this.essentialsPackName)) {
      return;
    }
    this.iconsLibrary.registerSvgPack(this.essentialsPackName, {
      "chevron-down-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-down"><rect width="24" height="24" opacity="0"/><path d="M12 15.5a1 1 0 0 1-.71-.29l-4-4a1 1 0 1 1 1.42-1.42L12 13.1l3.3-3.18a1 1 0 1 1 1.38 1.44l-4 3.86a1 1 0 0 1-.68.28z"/></g></g></svg>',
      "chevron-up-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-up"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M16 14.5a1 1 0 0 1-.71-.29L12 10.9l-3.3 3.18a1 1 0 0 1-1.41 0 1 1 0 0 1 0-1.42l4-3.86a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1 0 1.42 1 1 0 0 1-.69.28z"/></g></g></svg>',
      "chevron-left-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-left"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M13.36 17a1 1 0 0 1-.72-.31l-3.86-4a1 1 0 0 1 0-1.4l4-4a1 1 0 1 1 1.42 1.42L10.9 12l3.18 3.3a1 1 0 0 1 0 1.41 1 1 0 0 1-.72.29z"/></g></g></svg>',
      "chevron-right-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-right"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M10.5 17a1 1 0 0 1-.71-.29 1 1 0 0 1 0-1.42L13.1 12 9.92 8.69a1 1 0 0 1 0-1.41 1 1 0 0 1 1.42 0l3.86 4a1 1 0 0 1 0 1.4l-4 4a1 1 0 0 1-.7.32z"/></g></g></svg>',
      "checkmark-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="checkmark"><rect width="24" height="24" opacity="0"/><path d="M9.86 18a1 1 0 0 1-.73-.32l-4.86-5.17a1 1 0 1 1 1.46-1.37l4.12 4.39 8.41-9.2a1 1 0 1 1 1.48 1.34l-9.14 10a1 1 0 0 1-.73.33z"/></g></g></svg>',
      "paper-plane-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="paper-plane"><rect width="24" height="24" opacity="0"/><path d="M21 4a1.31 1.31 0 0 0-.06-.27v-.09a1 1 0 0 0-.2-.3 1 1 0 0 0-.29-.19h-.09a.86.86 0 0 0-.31-.15H20a1 1 0 0 0-.3 0l-18 6a1 1 0 0 0 0 1.9l8.53 2.84 2.84 8.53a1 1 0 0 0 1.9 0l6-18A1 1 0 0 0 21 4zm-4.7 2.29l-5.57 5.57L5.16 10zM14 18.84l-1.86-5.57 5.57-5.57z"/></g></g></svg>',
      "file-text-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="file-text"><rect width="24" height="24" opacity="0"/><path d="M15 16H9a1 1 0 0 0 0 2h6a1 1 0 0 0 0-2z"/><path d="M9 14h3a1 1 0 0 0 0-2H9a1 1 0 0 0 0 2z"/><path d="M19.74 8.33l-5.44-6a1 1 0 0 0-.74-.33h-7A2.53 2.53 0 0 0 4 4.5v15A2.53 2.53 0 0 0 6.56 22h10.88A2.53 2.53 0 0 0 20 19.5V9a1 1 0 0 0-.26-.67zM14 5l2.74 3h-2a.79.79 0 0 1-.74-.85zm3.44 15H6.56a.53.53 0 0 1-.56-.5v-15a.53.53 0 0 1 .56-.5H12v3.15A2.79 2.79 0 0 0 14.71 10H18v9.5a.53.53 0 0 1-.56.5z"/></g></g></svg>',
      "alert-triangle-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="alert-triangle"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M22.56 16.3L14.89 3.58a3.43 3.43 0 0 0-5.78 0L1.44 16.3a3 3 0 0 0-.05 3A3.37 3.37 0 0 0 4.33 21h15.34a3.37 3.37 0 0 0 2.94-1.66 3 3 0 0 0-.05-3.04zm-1.7 2.05a1.31 1.31 0 0 1-1.19.65H4.33a1.31 1.31 0 0 1-1.19-.65 1 1 0 0 1 0-1l7.68-12.73a1.48 1.48 0 0 1 2.36 0l7.67 12.72a1 1 0 0 1 .01 1.01z"/><circle cx="12" cy="16" r="1"/><path d="M12 8a1 1 0 0 0-1 1v4a1 1 0 0 0 2 0V9a1 1 0 0 0-1-1z"/></g></g></svg>',
      "question-mark-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="question-mark"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M17 9A5 5 0 0 0 7 9a1 1 0 0 0 2 0 3 3 0 1 1 3 3 1 1 0 0 0-1 1v2a1 1 0 0 0 2 0v-1.1A5 5 0 0 0 17 9z"/><circle cx="12" cy="19" r="1"/></g></g></svg>',
      "email-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="email"><rect width="24" height="24" opacity="0"/><path d="M19 4H5a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V7a3 3 0 0 0-3-3zm-.67 2L12 10.75 5.67 6zM19 18H5a1 1 0 0 1-1-1V7.25l7.4 5.55a1 1 0 0 0 .6.2 1 1 0 0 0 .6-.2L20 7.25V17a1 1 0 0 1-1 1z"/></g></g></svg>',
      "flash-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="flash"><rect width="24" height="24" opacity="0"/><path d="M11.11 23a1 1 0 0 1-.34-.06 1 1 0 0 1-.65-1.05l.77-7.09H5a1 1 0 0 1-.83-1.56l7.89-11.8a1 1 0 0 1 1.17-.38 1 1 0 0 1 .65 1l-.77 7.14H19a1 1 0 0 1 .83 1.56l-7.89 11.8a1 1 0 0 1-.83.44zM6.87 12.8H12a1 1 0 0 1 .74.33 1 1 0 0 1 .25.78l-.45 4.15 4.59-6.86H12a1 1 0 0 1-1-1.11l.45-4.15z"/></g></g></svg>',
      "search-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="search"><rect width="24" height="24" opacity="0"/><path d="M20.71 19.29l-3.4-3.39A7.92 7.92 0 0 0 19 11a8 8 0 1 0-8 8 7.92 7.92 0 0 0 4.9-1.69l3.39 3.4a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42zM5 11a6 6 0 1 1 6 6 6 6 0 0 1-6-6z"/></g></g></svg>',
      "close-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="close"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M13.41 12l4.3-4.29a1 1 0 1 0-1.42-1.42L12 10.59l-4.29-4.3a1 1 0 0 0-1.42 1.42l4.3 4.29-4.3 4.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0l4.29-4.3 4.29 4.3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g></svg>',
      "collapse-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="collapse"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19 9h-2.58l3.29-3.29a1 1 0 1 0-1.42-1.42L15 7.57V5a1 1 0 0 0-1-1 1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 0-2z"/><path d="M10 13H5a1 1 0 0 0 0 2h2.57l-3.28 3.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L9 16.42V19a1 1 0 0 0 1 1 1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1z"/></g></g></svg>',
      "expand-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="expand"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M20 5a1 1 0 0 0-1-1h-5a1 1 0 0 0 0 2h2.57l-3.28 3.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L18 7.42V10a1 1 0 0 0 1 1 1 1 0 0 0 1-1z"/><path d="M10.71 13.29a1 1 0 0 0-1.42 0L6 16.57V14a1 1 0 0 0-1-1 1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 0-2H7.42l3.29-3.29a1 1 0 0 0 0-1.42z"/></g></g></svg>',
      "minus-outline": '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="minus"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19 13H5a1 1 0 0 1 0-2h14a1 1 0 0 1 0 2z"/></g></g></svg>',
      "minus-bold-outline": '<svg xmlns:xlink="http://www.w3.org/1999/xlink" fill="currentColor" viewBox="0 0 8 2" width="100%" height="100%"><defs><rect id="nb-mbo" y="3" width="8" height="2" rx="1"/></defs><use xlink:href="#nb-mbo" transform="translate(0 -3)" fill-rule="evenodd"/></svg>',
      "checkmark-bold-outline": '<svg xmlns:xlink="http://www.w3.org/1999/xlink" fill="currentColor" viewBox="0 0 8 7" width="100%" height="100%"><defs><path id="nb-cbo" d="M6.039 1.43a1.11 1.11 0 0 1 1.517-.228c.483.342.588.998.234 1.466L4.431 7.1a1 1 0 0 1-1.492.115L.317 4.677a1.023 1.023 0 0 1 .002-1.483 1.113 1.113 0 0 1 1.535.002l1.641 1.59L6.04 1.428z"/></defs><use xlink:href="#nb-cbo" transform="translate(0 -1)" fill-rule="evenodd"/></svg>',
      "arrow-back": '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="arrow-back"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M19 11H7.14l3.63-4.36a1 1 0 1 0-1.54-1.28l-5 6a1.19 1.19 0 0 0-.09.15c0 .05 0 .08-.07.13A1 1 0 0 0 4 12a1 1 0 0 0 .07.36c0 .05 0 .08.07.13a1.19 1.19 0 0 0 .09.15l5 6A1 1 0 0 0 10 19a1 1 0 0 0 .64-.23 1 1 0 0 0 .13-1.41L7.14 13H19a1 1 0 0 0 0-2z"/></g></g></svg>'
    });
  }
};
_NbIconModule.ɵfac = function NbIconModule_Factory(t) {
  return new (t || _NbIconModule)(ɵɵinject(NbIconLibraries));
};
_NbIconModule.ɵmod = ɵɵdefineNgModule({
  type: _NbIconModule,
  declarations: [NbIconComponent],
  imports: [CommonModule],
  exports: [NbIconComponent]
});
_NbIconModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
var NbIconModule = _NbIconModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbIconModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [NbIconComponent],
      exports: [NbIconComponent]
    }]
  }], () => [{
    type: NbIconLibraries
  }], null);
})();
var _NbCardHeaderComponent = class _NbCardHeaderComponent {
};
_NbCardHeaderComponent.ɵfac = function NbCardHeaderComponent_Factory(t) {
  return new (t || _NbCardHeaderComponent)();
};
_NbCardHeaderComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCardHeaderComponent,
  selectors: [["nb-card-header"]],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function NbCardHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
var NbCardHeaderComponent = _NbCardHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardHeaderComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-header",
      template: `<ng-content></ng-content>`
    }]
  }], null, null);
})();
var _NbCardBodyComponent = class _NbCardBodyComponent {
};
_NbCardBodyComponent.ɵfac = function NbCardBodyComponent_Factory(t) {
  return new (t || _NbCardBodyComponent)();
};
_NbCardBodyComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCardBodyComponent,
  selectors: [["nb-card-body"]],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function NbCardBodyComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
var NbCardBodyComponent = _NbCardBodyComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardBodyComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-body",
      template: `<ng-content></ng-content>`
    }]
  }], null, null);
})();
var _NbCardFooterComponent = class _NbCardFooterComponent {
};
_NbCardFooterComponent.ɵfac = function NbCardFooterComponent_Factory(t) {
  return new (t || _NbCardFooterComponent)();
};
_NbCardFooterComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCardFooterComponent,
  selectors: [["nb-card-footer"]],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function NbCardFooterComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
var NbCardFooterComponent = _NbCardFooterComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardFooterComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-footer",
      template: `<ng-content></ng-content>`
    }]
  }], null, null);
})();
var _NbCardComponent = class _NbCardComponent {
  /**
   * Card size, available sizes:
   * tiny, small, medium, large, giant
   */
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = value;
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get hasAccent() {
    return this.accent;
  }
  get primaryAccent() {
    return this.accent === "primary";
  }
  get infoAccent() {
    return this.accent === "info";
  }
  get successAccent() {
    return this.accent === "success";
  }
  get warningAccent() {
    return this.accent === "warning";
  }
  get dangerAccent() {
    return this.accent === "danger";
  }
  get basicAccent() {
    return this.accent === "basic";
  }
  get controlAccent() {
    return this.accent === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(statusService) {
    this.statusService = statusService;
    this._size = "";
    this.status = "";
    this.accent = "";
  }
};
_NbCardComponent.ɵfac = function NbCardComponent_Factory(t) {
  return new (t || _NbCardComponent)(ɵɵdirectiveInject(NbStatusService));
};
_NbCardComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCardComponent,
  selectors: [["nb-card"]],
  hostVars: 42,
  hostBindings: function NbCardComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("accent", ctx.hasAccent)("accent-primary", ctx.primaryAccent)("accent-info", ctx.infoAccent)("accent-success", ctx.successAccent)("accent-warning", ctx.warningAccent)("accent-danger", ctx.dangerAccent)("accent-basic", ctx.basicAccent)("accent-control", ctx.controlAccent);
    }
  },
  inputs: {
    size: "size",
    status: "status",
    accent: "accent"
  },
  ngContentSelectors: _c2,
  decls: 4,
  vars: 0,
  template: function NbCardComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c12);
      ɵɵprojection(0);
      ɵɵprojection(1, 1);
      ɵɵprojection(2, 2);
      ɵɵprojection(3, 3);
    }
  },
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;flex-direction:column}"]
});
var NbCardComponent = _NbCardComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardComponent, [{
    type: Component,
    args: [{
      selector: "nb-card",
      template: `
    <ng-content select="nb-card-header"></ng-content>
    <ng-content select="nb-card-body"></ng-content>
    <ng-content></ng-content>
    <ng-content select="nb-card-footer"></ng-content>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;flex-direction:column}\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    accent: [{
      type: Input
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    hasAccent: [{
      type: HostBinding,
      args: ["class.accent"]
    }],
    primaryAccent: [{
      type: HostBinding,
      args: ["class.accent-primary"]
    }],
    infoAccent: [{
      type: HostBinding,
      args: ["class.accent-info"]
    }],
    successAccent: [{
      type: HostBinding,
      args: ["class.accent-success"]
    }],
    warningAccent: [{
      type: HostBinding,
      args: ["class.accent-warning"]
    }],
    dangerAccent: [{
      type: HostBinding,
      args: ["class.accent-danger"]
    }],
    basicAccent: [{
      type: HostBinding,
      args: ["class.accent-basic"]
    }],
    controlAccent: [{
      type: HostBinding,
      args: ["class.accent-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbRevealCardComponent = class _NbRevealCardComponent {
  constructor() {
    this.revealed = false;
    this.showToggleButton = true;
  }
  toggle() {
    this.revealed = !this.revealed;
  }
};
_NbRevealCardComponent.ɵfac = function NbRevealCardComponent_Factory(t) {
  return new (t || _NbRevealCardComponent)();
};
_NbRevealCardComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbRevealCardComponent,
  selectors: [["nb-reveal-card"]],
  hostVars: 2,
  hostBindings: function NbRevealCardComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("revealed", ctx.revealed);
    }
  },
  inputs: {
    revealed: "revealed",
    showToggleButton: "showToggleButton"
  },
  ngContentSelectors: _c4,
  decls: 4,
  vars: 1,
  consts: [[1, "second-card-container"], ["class", "reveal-button", 3, "click", 4, "ngIf"], [1, "reveal-button", 3, "click"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true"]],
  template: function NbRevealCardComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c3);
      ɵɵprojection(0);
      ɵɵelementStart(1, "div", 0);
      ɵɵprojection(2, 1);
      ɵɵelementEnd();
      ɵɵtemplate(3, NbRevealCardComponent_a_3_Template, 2, 0, "a", 1);
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showToggleButton);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["[_nghost-%COMP%]{display:block;position:relative;overflow:hidden}[_nghost-%COMP%]   .second-card-container[_ngcontent-%COMP%]{position:absolute;top:100%;right:0;left:0;overflow:hidden;transition:top 0s .5s}[_nghost-%COMP%]     nb-card-front nb-card, [_nghost-%COMP%]     nb-card-back nb-card{box-shadow:none;margin:0}[_nghost-%COMP%]     nb-card-front{display:block;height:100%}[_nghost-%COMP%]     nb-card-back{position:absolute;left:0;top:100%;width:100%;transition:top .5s}[_nghost-%COMP%]   .reveal-button[_ngcontent-%COMP%]{cursor:pointer;position:absolute;right:0;bottom:0;transform:rotate(180deg);transition:transform .3s}.revealed[_nghost-%COMP%]   .second-card-container[_ngcontent-%COMP%]{top:0;transition:none}.revealed[_nghost-%COMP%]   .second-card-container[_ngcontent-%COMP%]     nb-card-back{top:0}.revealed[_nghost-%COMP%]   .reveal-button[_ngcontent-%COMP%]{transform:none}"]
});
var NbRevealCardComponent = _NbRevealCardComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRevealCardComponent, [{
    type: Component,
    args: [{
      selector: "nb-reveal-card",
      template: `
    <ng-content select="nb-card-front"></ng-content>
    <div class="second-card-container">
      <ng-content select="nb-card-back"></ng-content>
    </div>
    <a *ngIf="showToggleButton" class="reveal-button" (click)="toggle()">
      <nb-icon icon="chevron-down-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
    </a>
  `,
      styles: [":host{display:block;position:relative;overflow:hidden}:host .second-card-container{position:absolute;top:100%;right:0;left:0;overflow:hidden;transition:top 0s .5s}:host ::ng-deep nb-card-front nb-card,:host ::ng-deep nb-card-back nb-card{box-shadow:none;margin:0}:host ::ng-deep nb-card-front{display:block;height:100%}:host ::ng-deep nb-card-back{position:absolute;left:0;top:100%;width:100%;transition:top .5s}:host .reveal-button{cursor:pointer;position:absolute;right:0;bottom:0;transform:rotate(180deg);transition:transform .3s}:host(.revealed) .second-card-container{top:0;transition:none}:host(.revealed) .second-card-container ::ng-deep nb-card-back{top:0}:host(.revealed) .reveal-button{transform:none}\n"]
    }]
  }], null, {
    revealed: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.revealed"]
    }],
    showToggleButton: [{
      type: Input
    }]
  });
})();
var _NbFlipCardComponent = class _NbFlipCardComponent {
  constructor() {
    this.flipped = false;
    this.showToggleButton = true;
  }
  toggle() {
    this.flipped = !this.flipped;
  }
};
_NbFlipCardComponent.ɵfac = function NbFlipCardComponent_Factory(t) {
  return new (t || _NbFlipCardComponent)();
};
_NbFlipCardComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbFlipCardComponent,
  selectors: [["nb-flip-card"]],
  hostVars: 2,
  hostBindings: function NbFlipCardComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("flipped", ctx.flipped);
    }
  },
  inputs: {
    flipped: "flipped",
    showToggleButton: "showToggleButton"
  },
  ngContentSelectors: _c4,
  decls: 7,
  vars: 2,
  consts: [[1, "flipcard-body"], [1, "front-container"], ["class", "flip-button", 3, "click", 4, "ngIf"], [1, "back-container"], [1, "flip-button", 3, "click"], ["icon", "chevron-left-outline", "pack", "nebular-essentials", "aria-hidden", "true"]],
  template: function NbFlipCardComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c3);
      ɵɵelementStart(0, "div", 0)(1, "div", 1);
      ɵɵprojection(2);
      ɵɵtemplate(3, NbFlipCardComponent_a_3_Template, 2, 0, "a", 2);
      ɵɵelementEnd();
      ɵɵelementStart(4, "div", 3);
      ɵɵprojection(5, 1);
      ɵɵtemplate(6, NbFlipCardComponent_a_6_Template, 2, 0, "a", 2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showToggleButton);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showToggleButton);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:block;min-width:0;perspective:1200px;position:relative}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]{transform:rotateY(-180deg)}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]{opacity:0;transition:opacity 0s .25s;backface-visibility:hidden;-webkit-backface-visibility:hidden}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%]{opacity:0;z-index:-1}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]{backface-visibility:visible;-webkit-backface-visibility:visible}.flipcard-body[_ngcontent-%COMP%]{display:flex;transition:transform .5s;transform-style:preserve-3d}.flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%], .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]{flex:1;height:fit-content;overflow:auto}.flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%], .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%]{cursor:pointer;position:absolute;right:0;bottom:0;opacity:1;transition:opacity 0s .15s}.flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]{backface-visibility:visible;-webkit-backface-visibility:visible;transition:opacity 0s .2s}.flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]{backface-visibility:hidden;-webkit-backface-visibility:hidden;transform:rotateY(180deg)}"]
});
var NbFlipCardComponent = _NbFlipCardComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFlipCardComponent, [{
    type: Component,
    args: [{
      selector: "nb-flip-card",
      template: `
    <div class="flipcard-body">
      <div class="front-container">
        <ng-content select="nb-card-front"></ng-content>
        <a *ngIf="showToggleButton" class="flip-button" (click)="toggle()">
          <nb-icon icon="chevron-left-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
        </a>
      </div>
      <div class="back-container">
        <ng-content select="nb-card-back"></ng-content>
        <a *ngIf="showToggleButton" class="flip-button" (click)="toggle()">
          <nb-icon icon="chevron-left-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
        </a>
      </div>
    </div>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:block;min-width:0;perspective:1200px;position:relative}:host-context(.flipped) .flipcard-body{transform:rotateY(-180deg)}:host-context(.flipped) .flipcard-body .front-container{opacity:0;transition:opacity 0s .25s;backface-visibility:hidden;-webkit-backface-visibility:hidden}:host-context(.flipped) .flipcard-body .front-container .flip-button{opacity:0;z-index:-1}:host-context(.flipped) .flipcard-body .back-container{backface-visibility:visible;-webkit-backface-visibility:visible}.flipcard-body{display:flex;transition:transform .5s;transform-style:preserve-3d}.flipcard-body .front-container,.flipcard-body .back-container{flex:1;height:fit-content;overflow:auto}.flipcard-body .front-container .flip-button,.flipcard-body .back-container .flip-button{cursor:pointer;position:absolute;right:0;bottom:0;opacity:1;transition:opacity 0s .15s}.flipcard-body .front-container{backface-visibility:visible;-webkit-backface-visibility:visible;transition:opacity 0s .2s}.flipcard-body .back-container{backface-visibility:hidden;-webkit-backface-visibility:hidden;transform:rotateY(180deg)}\n"]
    }]
  }], null, {
    flipped: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.flipped"]
    }],
    showToggleButton: [{
      type: Input
    }]
  });
})();
var _NbCardFrontComponent = class _NbCardFrontComponent {
};
_NbCardFrontComponent.ɵfac = function NbCardFrontComponent_Factory(t) {
  return new (t || _NbCardFrontComponent)();
};
_NbCardFrontComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCardFrontComponent,
  selectors: [["nb-card-front"]],
  ngContentSelectors: _c6,
  decls: 1,
  vars: 0,
  template: function NbCardFrontComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c5);
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
var NbCardFrontComponent = _NbCardFrontComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardFrontComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-front",
      template: '<ng-content select="nb-card"></ng-content>'
    }]
  }], null, null);
})();
var _NbCardBackComponent = class _NbCardBackComponent {
};
_NbCardBackComponent.ɵfac = function NbCardBackComponent_Factory(t) {
  return new (t || _NbCardBackComponent)();
};
_NbCardBackComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCardBackComponent,
  selectors: [["nb-card-back"]],
  ngContentSelectors: _c6,
  decls: 1,
  vars: 0,
  template: function NbCardBackComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c5);
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
var NbCardBackComponent = _NbCardBackComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardBackComponent, [{
    type: Component,
    args: [{
      selector: "nb-card-back",
      template: '<ng-content select="nb-card"></ng-content>'
    }]
  }], null, null);
})();
var NB_CARD_COMPONENTS = [NbCardComponent, NbCardBodyComponent, NbCardFooterComponent, NbCardHeaderComponent, NbRevealCardComponent, NbFlipCardComponent, NbCardFrontComponent, NbCardBackComponent];
var _NbCardModule = class _NbCardModule {
};
_NbCardModule.ɵfac = function NbCardModule_Factory(t) {
  return new (t || _NbCardModule)();
};
_NbCardModule.ɵmod = ɵɵdefineNgModule({
  type: _NbCardModule,
  declarations: [NbCardComponent, NbCardBodyComponent, NbCardFooterComponent, NbCardHeaderComponent, NbRevealCardComponent, NbFlipCardComponent, NbCardFrontComponent, NbCardBackComponent],
  imports: [NbSharedModule, NbIconModule],
  exports: [NbCardComponent, NbCardBodyComponent, NbCardFooterComponent, NbCardHeaderComponent, NbRevealCardComponent, NbFlipCardComponent, NbCardFrontComponent, NbCardBackComponent]
});
_NbCardModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbIconModule]
});
var NbCardModule = _NbCardModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCardModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule],
      declarations: [...NB_CARD_COMPONENTS],
      exports: [...NB_CARD_COMPONENTS]
    }]
  }], null, null);
})();
var NbCalendarViewMode;
(function(NbCalendarViewMode2) {
  NbCalendarViewMode2["YEAR"] = "year";
  NbCalendarViewMode2["MONTH"] = "month";
  NbCalendarViewMode2["DATE"] = "date";
})(NbCalendarViewMode || (NbCalendarViewMode = {}));
var NbCalendarSize;
(function(NbCalendarSize2) {
  NbCalendarSize2["MEDIUM"] = "medium";
  NbCalendarSize2["LARGE"] = "large";
})(NbCalendarSize || (NbCalendarSize = {}));
function convertToBoolProperty(val) {
  if (typeof val === "string") {
    val = val.toLowerCase().trim();
    return val === "true" || val === "";
  }
  return !!val;
}
var NbDateService = class {
  constructor() {
    this.DAYS_IN_WEEK = 7;
    this.HOURS_IN_DAY_PERIOD = 12;
  }
  setLocale(locale) {
    this.locale = locale;
  }
  /**
   * Checks if the date is between the start date and the end date.
   * */
  isBetween(date, start, end) {
    return this.compareDates(date, start) > 0 && this.compareDates(date, end) < 0;
  }
  /**
   * Checks is two dates have the same day.
   * */
  isSameDaySafe(date1, date2) {
    return date1 && date2 && this.isSameDay(date1, date2);
  }
  /**
   * Checks is two dates have the same month.
   * */
  isSameMonthSafe(date1, date2) {
    return date1 && date2 && this.isSameMonth(date1, date2);
  }
  /**
   * Checks is two dates have the same year.
   * */
  isSameYearSafe(date1, date2) {
    return date1 && date2 && this.isSameYear(date1, date2);
  }
  isSameHourAndMinute(date1, date2) {
    return this.isSameHour(date1, date2) && this.isSameMinute(date1, date2);
  }
  isSameHour(date1, date2) {
    return this.getHours(date1) === this.getHours(date2);
  }
  isSameMinute(date1, date2) {
    return this.getMinutes(date1) === this.getMinutes(date2);
  }
  getTwentyFourHoursFormat() {
    return "HH:mm";
  }
  getTwentyFourHoursFormatWithSeconds() {
    return "HH:mm:ss";
  }
  getTwelveHoursFormatWithSeconds() {
    return "hh:mm:ss a";
  }
  getDayPeriod(date) {
    const isFirstDayPeriod = this.getHours(date) < this.HOURS_IN_DAY_PERIOD;
    if (isFirstDayPeriod) {
      return "AM";
    } else {
      return "PM";
    }
  }
};
var batch = (target, batchSize, offset = 0) => {
  return target.reduce((res, item, index) => {
    const chunkIndex = Math.floor((index + offset) / batchSize);
    if (!res[chunkIndex]) {
      res[chunkIndex] = [];
    }
    res[chunkIndex].push(item);
    return res;
  }, []);
};
var rangeFromTo = (from2, to = 0, producer = (i) => i) => {
  const arr = [];
  for (let i = from2; i < to; i++) {
    arr.push(producer(i));
  }
  return arr;
};
var range = (bound, producer = (i) => i) => {
  return rangeFromTo(0, bound, producer);
};
var _NbCalendarYearModelService = class _NbCalendarYearModelService {
  constructor(dateService) {
    this.dateService = dateService;
    this.yearsInView = 12;
    this.yearsInRow = 4;
  }
  getYearsInView() {
    return this.yearsInView;
  }
  getYearsInRow() {
    return this.yearsInRow;
  }
  getViewYears(viewYear) {
    const year = this.dateService.getYear(viewYear);
    let viewStartYear;
    if (year >= 0) {
      viewStartYear = year - year % this.yearsInView;
    } else {
      viewStartYear = year - (year % this.yearsInView + this.yearsInView);
    }
    const years = range(this.yearsInView).map((i) => this.copyWithYear(viewStartYear + i, viewYear));
    return batch(years, this.yearsInRow);
  }
  copyWithYear(year, date) {
    return this.dateService.createDate(year, this.dateService.getMonth(date), this.dateService.getDate(date));
  }
};
_NbCalendarYearModelService.ɵfac = function NbCalendarYearModelService_Factory(t) {
  return new (t || _NbCalendarYearModelService)(ɵɵinject(NbDateService));
};
_NbCalendarYearModelService.ɵprov = ɵɵdefineInjectable({
  token: _NbCalendarYearModelService,
  factory: _NbCalendarYearModelService.ɵfac
});
var NbCalendarYearModelService = _NbCalendarYearModelService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarYearModelService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var _NbButton = class _NbButton {
  /**
   * Sets `filled` appearance
   */
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  /**
   * Sets `outline` appearance
   */
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  /**
   * Sets `ghost` appearance
   */
  get ghost() {
    return this.appearance === "ghost";
  }
  set ghost(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "ghost";
    }
  }
  /**
   * If set element will fill its container
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  /**
   * Disables the button
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    if (this.disabled !== convertToBoolProperty(value)) {
      this._disabled = !this.disabled;
      this.renderer.setProperty(this.hostElement.nativeElement, "disabled", this.disabled);
    }
  }
  // issue #794
  get tabbable() {
    if (this.disabled) {
      return "-1";
    }
    if (this.tabIndex == null) {
      return "0";
    }
    return this.tabIndex.toString();
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get round() {
    return this.shape === "round";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(renderer, hostElement, cd, zone, statusService) {
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.cd = cd;
    this.zone = zone;
    this.statusService = statusService;
    this.size = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this.appearance = "filled";
    this._fullWidth = false;
    this._disabled = false;
    this.iconLeft = false;
    this.iconRight = false;
  }
  ngAfterContentChecked() {
    const firstNode = this.nodes[0];
    const lastNode = this.nodes[this.nodes.length - 1];
    this.iconLeft = this.isIconExist(firstNode);
    this.iconRight = this.isIconExist(lastNode);
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostElement.nativeElement, "nb-transition");
    }));
  }
  /**
   * @docs-private
   **/
  updateProperties(config) {
    let isPropertyChanged = false;
    for (const key in config) {
      if (config.hasOwnProperty(key) && this[key] !== config[key]) {
        this[key] = config[key];
        isPropertyChanged = true;
      }
    }
    if (isPropertyChanged) {
      this.cd.markForCheck();
    }
  }
  get iconElement() {
    const el = this.hostElement.nativeElement;
    return el.querySelector("nb-icon");
  }
  get nodes() {
    return this.cd.rootNodes.filter((child) => child.nodeType !== Node.COMMENT_NODE);
  }
  isIconExist(node) {
    return this.icons.some((item) => item.nativeElement === node);
  }
};
_NbButton.ɵfac = function NbButton_Factory(t) {
  return new (t || _NbButton)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
};
_NbButton.ɵdir = ɵɵdefineDirective({
  type: _NbButton,
  contentQueries: function NbButton_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbIconComponent, 4, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.icons = _t);
    }
  },
  hostVars: 34,
  hostBindings: function NbButton_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-disabled", ctx.disabled)("tabindex", ctx.tabbable);
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("appearance-filled", ctx.filled)("appearance-outline", ctx.outline)("appearance-ghost", ctx.ghost)("full-width", ctx.fullWidth)("btn-disabled", ctx.disabled)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("shape-rectangle", ctx.rectangle)("shape-round", ctx.round)("shape-semi-round", ctx.semiRound)("icon-start", ctx.iconLeft)("icon-end", ctx.iconRight);
    }
  },
  inputs: {
    size: "size",
    status: "status",
    shape: "shape",
    appearance: "appearance",
    filled: "filled",
    outline: "outline",
    ghost: "ghost",
    fullWidth: "fullWidth",
    disabled: "disabled",
    tabIndex: "tabIndex"
  }
});
var NbButton = _NbButton;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButton, [{
    type: Directive
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    filled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-filled"]
    }],
    outline: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-outline"]
    }],
    ghost: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-ghost"]
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.full-width"]
    }],
    disabled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.btn-disabled"]
    }],
    tabIndex: [{
      type: Input
    }],
    tabbable: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }],
    iconLeft: [{
      type: HostBinding,
      args: ["class.icon-start"]
    }],
    iconRight: [{
      type: HostBinding,
      args: ["class.icon-end"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    icons: [{
      type: ContentChildren,
      args: [NbIconComponent, {
        read: ElementRef
      }]
    }]
  });
})();
var _NbButtonComponent = class _NbButtonComponent extends NbButton {
  /**
   * Sets `hero` appearance
   */
  get hero() {
    return this.appearance === "hero";
  }
  set hero(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "hero";
    }
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  /**
   * @private
   * Keep this handler to partially support anchor disabling.
   * Unlike button, anchor doesn't have 'disabled' DOM property,
   * so handler will be called anyway. We preventing navigation and bubbling.
   * Disabling is partial due to click handlers precedence. Consider example:
   * <a nbButton [disabled]="true" (click)="clickHandler()">...</a>
   * 'clickHandler' will be called before our host listener below. We can't prevent
   * such handlers call.
   */
  onClick(event) {
    if (this.disabled) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }
  }
  constructor(renderer, hostElement, cd, zone, statusService) {
    super(renderer, hostElement, cd, zone, statusService);
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.cd = cd;
    this.zone = zone;
    this.statusService = statusService;
  }
};
_NbButtonComponent.ɵfac = function NbButtonComponent_Factory(t) {
  return new (t || _NbButtonComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
};
_NbButtonComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbButtonComponent,
  selectors: [["button", "nbButton", ""], ["a", "nbButton", ""], ["input", "type", "button", "nbButton", ""], ["input", "type", "submit", "nbButton", ""]],
  hostVars: 16,
  hostBindings: function NbButtonComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbButtonComponent_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("appearance-hero", ctx.hero)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    }
  },
  inputs: {
    hero: "hero"
  },
  features: [ɵɵProvidersFeature([{
    provide: NbButton,
    useExisting: _NbButtonComponent
  }]), ɵɵInheritDefinitionFeature],
  attrs: _c7,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function NbButtonComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbButtonComponent = _NbButtonComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonComponent, [{
    type: Component,
    args: [{
      selector: 'button[nbButton],a[nbButton],input[type="button"][nbButton],input[type="submit"][nbButton]',
      template: `
    <ng-content></ng-content>
  `,
      providers: [{
        provide: NbButton,
        useExisting: NbButtonComponent
      }],
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    hero: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-hero"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var _NbCalendarViewModeComponent = class _NbCalendarViewModeComponent {
  constructor(dateService, yearModelService) {
    this.dateService = dateService;
    this.yearModelService = yearModelService;
    this.viewMode = NbCalendarViewMode.DATE;
    this.changeMode = new EventEmitter(true);
  }
  getText() {
    if (!this.date) {
      return "";
    }
    switch (this.viewMode) {
      case NbCalendarViewMode.DATE: {
        const month = this.dateService.getMonthName(this.date, TranslationWidth.Wide);
        const year = this.dateService.getYear(this.date);
        return `${month} ${year}`;
      }
      case NbCalendarViewMode.MONTH:
        return `${this.dateService.getYear(this.date)}`;
      case NbCalendarViewMode.YEAR:
        return `${this.getFirstYear()} - ${this.getLastYear()}`;
    }
  }
  getIcon() {
    if (this.viewMode === NbCalendarViewMode.DATE) {
      return "chevron-down-outline";
    }
    return "chevron-up-outline";
  }
  getFirstYear() {
    const years = this.yearModelService.getViewYears(this.date);
    return this.dateService.getYear(years[0][0]).toString();
  }
  getLastYear() {
    const years = this.yearModelService.getViewYears(this.date);
    const lastRow = years[years.length - 1];
    const lastYear = lastRow[lastRow.length - 1];
    return this.dateService.getYear(lastYear).toString();
  }
};
_NbCalendarViewModeComponent.ɵfac = function NbCalendarViewModeComponent_Factory(t) {
  return new (t || _NbCalendarViewModeComponent)(ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(NbCalendarYearModelService));
};
_NbCalendarViewModeComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarViewModeComponent,
  selectors: [["nb-calendar-view-mode"]],
  inputs: {
    date: "date",
    viewMode: "viewMode"
  },
  outputs: {
    changeMode: "changeMode"
  },
  decls: 3,
  vars: 2,
  consts: [["nbButton", "", "ghost", "", "status", "basic", 3, "click"], ["pack", "nebular-essentials", 3, "icon"]],
  template: function NbCalendarViewModeComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function NbCalendarViewModeComponent_Template_button_click_0_listener() {
        return ctx.changeMode.emit();
      });
      ɵɵtext(1);
      ɵɵelement(2, "nb-icon", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.getText(), " ");
      ɵɵadvance();
      ɵɵproperty("icon", ctx.getIcon());
    }
  },
  dependencies: [NbButtonComponent, NbIconComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarViewModeComponent = _NbCalendarViewModeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarViewModeComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-view-mode",
      template: `
    <button nbButton (click)="changeMode.emit()" ghost status="basic">
      {{ getText() }}
      <nb-icon [icon]="getIcon()" pack="nebular-essentials"></nb-icon>
    </button>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbDateService
  }, {
    type: NbCalendarYearModelService
  }], {
    date: [{
      type: Input
    }],
    viewMode: [{
      type: Input
    }],
    changeMode: [{
      type: Output
    }]
  });
})();
var _NbCalendarPageableNavigationComponent = class _NbCalendarPageableNavigationComponent {
  constructor(directionService) {
    this.directionService = directionService;
    this.next = new EventEmitter();
    this.prev = new EventEmitter();
  }
  get isLtr() {
    return this.directionService.isLtr();
  }
};
_NbCalendarPageableNavigationComponent.ɵfac = function NbCalendarPageableNavigationComponent_Factory(t) {
  return new (t || _NbCalendarPageableNavigationComponent)(ɵɵdirectiveInject(NbLayoutDirectionService));
};
_NbCalendarPageableNavigationComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarPageableNavigationComponent,
  selectors: [["nb-calendar-pageable-navigation"]],
  outputs: {
    next: "next",
    prev: "prev"
  },
  decls: 4,
  vars: 2,
  consts: [["nbButton", "", "ghost", "", "status", "basic", 1, "prev-month", 3, "click"], ["pack", "nebular-essentials", 3, "icon"], ["nbButton", "", "ghost", "", "status", "basic", 1, "next-month", 3, "click"]],
  template: function NbCalendarPageableNavigationComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function NbCalendarPageableNavigationComponent_Template_button_click_0_listener() {
        return ctx.prev.emit();
      });
      ɵɵelement(1, "nb-icon", 1);
      ɵɵelementEnd();
      ɵɵelementStart(2, "button", 2);
      ɵɵlistener("click", function NbCalendarPageableNavigationComponent_Template_button_click_2_listener() {
        return ctx.next.emit();
      });
      ɵɵelement(3, "nb-icon", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("icon", ctx.isLtr ? "chevron-left-outline" : "chevron-right-outline");
      ɵɵadvance(2);
      ɵɵproperty("icon", ctx.isLtr ? "chevron-right-outline" : "chevron-left-outline");
    }
  },
  dependencies: [NbButtonComponent, NbIconComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;align-items:center;justify-content:flex-start}"]
});
var NbCalendarPageableNavigationComponent = _NbCalendarPageableNavigationComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarPageableNavigationComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-pageable-navigation",
      template: `
    <button nbButton (click)="prev.emit()" ghost status="basic" class="prev-month">
      <nb-icon [icon]="isLtr ? 'chevron-left-outline' : 'chevron-right-outline'" pack="nebular-essentials"></nb-icon>
    </button>
    <button nbButton (click)="next.emit()" ghost status="basic" class="next-month">
      <nb-icon [icon]="isLtr ? 'chevron-right-outline' : 'chevron-left-outline'" pack="nebular-essentials"></nb-icon>
    </button>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;align-items:center;justify-content:flex-start}\n"]
    }]
  }], () => [{
    type: NbLayoutDirectionService
  }], {
    next: [{
      type: Output
    }],
    prev: [{
      type: Output
    }]
  });
})();
var _NbCalendarYearCellComponent = class _NbCalendarYearCellComponent {
  constructor(dateService) {
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.yearCellClass = true;
  }
  get selected() {
    return this.dateService.isSameYearSafe(this.date, this.selectedValue);
  }
  get today() {
    return this.dateService.isSameYearSafe(this.date, this.dateService.today());
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get year() {
    return this.dateService.getYear(this.date);
  }
  onClick() {
    if (this.disabled) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.yearEnd(), this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.yearStart(), this.max) > 0;
  }
  yearStart() {
    return this.dateService.getYearStart(this.date);
  }
  yearEnd() {
    return this.dateService.getYearEnd(this.date);
  }
};
_NbCalendarYearCellComponent.ɵfac = function NbCalendarYearCellComponent_Factory(t) {
  return new (t || _NbCalendarYearCellComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarYearCellComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarYearCellComponent,
  selectors: [["nb-calendar-year-cell"]],
  hostVars: 10,
  hostBindings: function NbCalendarYearCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbCalendarYearCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("selected", ctx.selected)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge)("year-cell", ctx.yearCellClass);
    }
  },
  inputs: {
    date: "date",
    min: "min",
    max: "max",
    selectedValue: "selectedValue",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  decls: 2,
  vars: 1,
  consts: [[1, "cell-content"]],
  template: function NbCalendarYearCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.year, " ");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarYearCellComponent = _NbCalendarYearCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarYearCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-year-cell",
      template: `
    <div class="cell-content">
      {{ year }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    yearCellClass: [{
      type: HostBinding,
      args: ["class.year-cell"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbCalendarPickerRowComponent = class _NbCalendarPickerRowComponent {
  constructor(cfr) {
    this.cfr = cfr;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter();
  }
  ngOnChanges() {
    const factory = this.cfr.resolveComponentFactory(this.component);
    this.containerRef.clear();
    this.row.forEach((date) => {
      const component = this.containerRef.createComponent(factory, this.containerRef.length);
      this.patchWithContext(component.instance, date);
      component.changeDetectorRef.detectChanges();
    });
  }
  patchWithContext(component, date) {
    component.visibleDate = this.visibleDate;
    component.selectedValue = this.selectedValue;
    component.date = date;
    component.min = this.min;
    component.max = this.max;
    component.filter = this.filter;
    component.size = this.size;
    component.select.subscribe(this.select.emit.bind(this.select));
  }
};
_NbCalendarPickerRowComponent.ɵfac = function NbCalendarPickerRowComponent_Factory(t) {
  return new (t || _NbCalendarPickerRowComponent)(ɵɵdirectiveInject(ComponentFactoryResolver$1));
};
_NbCalendarPickerRowComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarPickerRowComponent,
  selectors: [["nb-calendar-picker-row"]],
  viewQuery: function NbCalendarPickerRowComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(TemplateRef, 7, ViewContainerRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.containerRef = _t.first);
    }
  },
  inputs: {
    row: "row",
    selectedValue: "selectedValue",
    visibleDate: "visibleDate",
    component: "component",
    min: "min",
    max: "max",
    filter: "filter",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 1,
  vars: 0,
  template: function NbCalendarPickerRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbCalendarPickerRowComponent_ng_template_0_Template, 0, 0, "ng-template");
    }
  },
  styles: ["[_nghost-%COMP%]{display:flex;justify-content:space-between}"],
  changeDetection: 0
});
var NbCalendarPickerRowComponent = _NbCalendarPickerRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarPickerRowComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-picker-row",
      template: "<ng-template></ng-template>",
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [":host{display:flex;justify-content:space-between}\n"]
    }]
  }], () => [{
    type: ComponentFactoryResolver$1
  }], {
    row: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    component: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    containerRef: [{
      type: ViewChild,
      args: [TemplateRef, {
        read: ViewContainerRef,
        static: true
      }]
    }]
  });
})();
var _NbCalendarPickerComponent = class _NbCalendarPickerComponent {
  constructor() {
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
};
_NbCalendarPickerComponent.ɵfac = function NbCalendarPickerComponent_Factory(t) {
  return new (t || _NbCalendarPickerComponent)();
};
_NbCalendarPickerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarPickerComponent,
  selectors: [["nb-calendar-picker"]],
  hostVars: 2,
  hostBindings: function NbCalendarPickerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("size-large", ctx.isLarge);
    }
  },
  inputs: {
    data: "data",
    visibleDate: "visibleDate",
    selectedValue: "selectedValue",
    cellComponent: "cellComponent",
    min: "min",
    max: "max",
    filter: "filter",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  decls: 1,
  vars: 1,
  consts: [[3, "row", "visibleDate", "selectedValue", "component", "min", "max", "filter", "size", "select", 4, "ngFor", "ngForOf"], [3, "row", "visibleDate", "selectedValue", "component", "min", "max", "filter", "size", "select"]],
  template: function NbCalendarPickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbCalendarPickerComponent_nb_calendar_picker_row_0_Template, 1, 8, "nb-calendar-picker-row", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngForOf", ctx.data);
    }
  },
  dependencies: [NgForOf, NbCalendarPickerRowComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarPickerComponent = _NbCalendarPickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarPickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-picker",
      template: `
    <nb-calendar-picker-row
      *ngFor="let row of data"
      [row]="row"
      [visibleDate]="visibleDate"
      [selectedValue]="selectedValue"
      [component]="cellComponent"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [size]="size"
      (select)="select.emit($event)">
    </nb-calendar-picker-row>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    data: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    cellComponent: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var _NbCalendarYearPickerComponent = class _NbCalendarYearPickerComponent {
  set _cellComponent(cellComponent) {
    if (cellComponent) {
      this.cellComponent = cellComponent;
    }
  }
  get large() {
    return this.size === NbCalendarSize.LARGE;
  }
  constructor(dateService, yearModelService) {
    this.dateService = dateService;
    this.yearModelService = yearModelService;
    this.cellComponent = NbCalendarYearCellComponent;
    this.size = NbCalendarSize.MEDIUM;
    this.yearChange = new EventEmitter();
  }
  ngOnChanges() {
    this.years = this.yearModelService.getViewYears(this.year);
  }
  onSelect(year) {
    this.yearChange.emit(year);
  }
};
_NbCalendarYearPickerComponent.ɵfac = function NbCalendarYearPickerComponent_Factory(t) {
  return new (t || _NbCalendarYearPickerComponent)(ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(NbCalendarYearModelService));
};
_NbCalendarYearPickerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarYearPickerComponent,
  selectors: [["nb-calendar-year-picker"]],
  hostVars: 2,
  hostBindings: function NbCalendarYearPickerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("size-large", ctx.large);
    }
  },
  inputs: {
    date: "date",
    min: "min",
    max: "max",
    filter: "filter",
    _cellComponent: [InputFlags.None, "cellComponent", "_cellComponent"],
    size: "size",
    year: "year"
  },
  outputs: {
    yearChange: "yearChange"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 1,
  vars: 8,
  consts: [[3, "data", "min", "max", "filter", "selectedValue", "visibleDate", "cellComponent", "size", "select"]],
  template: function NbCalendarYearPickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nb-calendar-picker", 0);
      ɵɵlistener("select", function NbCalendarYearPickerComponent_Template_nb_calendar_picker_select_0_listener($event) {
        return ctx.onSelect($event);
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("data", ctx.years)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("selectedValue", ctx.date)("visibleDate", ctx.year)("cellComponent", ctx.cellComponent)("size", ctx.size);
    }
  },
  dependencies: [NbCalendarPickerComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarYearPickerComponent = _NbCalendarYearPickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarYearPickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-year-picker",
      template: `
    <nb-calendar-picker
      [data]="years"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [selectedValue]="date"
      [visibleDate]="year"
      [cellComponent]="cellComponent"
      [size]="size"
      (select)="onSelect($event)">
    </nb-calendar-picker>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbDateService
  }, {
    type: NbCalendarYearModelService
  }], {
    date: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    _cellComponent: [{
      type: Input,
      args: ["cellComponent"]
    }],
    size: [{
      type: Input
    }],
    year: [{
      type: Input
    }],
    yearChange: [{
      type: Output
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var _NbCalendarMonthCellComponent = class _NbCalendarMonthCellComponent {
  constructor(dateService) {
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.monthCellClass = true;
  }
  get selected() {
    return this.dateService.isSameMonthSafe(this.date, this.selectedValue);
  }
  get today() {
    return this.dateService.isSameMonthSafe(this.date, this.dateService.today());
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get month() {
    return this.dateService.getMonthName(this.date);
  }
  onClick() {
    if (this.disabled) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.monthEnd(), this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.monthStart(), this.max) > 0;
  }
  monthStart() {
    return this.dateService.getMonthStart(this.date);
  }
  monthEnd() {
    return this.dateService.getMonthEnd(this.date);
  }
};
_NbCalendarMonthCellComponent.ɵfac = function NbCalendarMonthCellComponent_Factory(t) {
  return new (t || _NbCalendarMonthCellComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarMonthCellComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarMonthCellComponent,
  selectors: [["nb-calendar-month-cell"]],
  hostVars: 10,
  hostBindings: function NbCalendarMonthCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbCalendarMonthCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("selected", ctx.selected)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge)("month-cell", ctx.monthCellClass);
    }
  },
  inputs: {
    date: "date",
    selectedValue: "selectedValue",
    min: "min",
    max: "max",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  decls: 2,
  vars: 1,
  consts: [[1, "cell-content"]],
  template: function NbCalendarMonthCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.month, " ");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarMonthCellComponent = _NbCalendarMonthCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarMonthCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-month-cell",
      template: `
    <div class="cell-content">
      {{ month }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    monthCellClass: [{
      type: HostBinding,
      args: ["class.month-cell"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var MONTHS_IN_VIEW = 12;
var MONTHS_IN_COLUMN = 4;
var _NbCalendarMonthPickerComponent = class _NbCalendarMonthPickerComponent {
  constructor(dateService) {
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.monthChange = new EventEmitter();
    this.cellComponent = NbCalendarMonthCellComponent;
  }
  set _cellComponent(cellComponent) {
    if (cellComponent) {
      this.cellComponent = cellComponent;
    }
  }
  get large() {
    return this.size === NbCalendarSize.LARGE;
  }
  ngOnChanges(changes) {
    if (changes.month) {
      this.initMonths();
    }
  }
  initMonths() {
    const date = this.dateService.getDate(this.month);
    const year = this.dateService.getYear(this.month);
    const firstMonth = this.dateService.createDate(year, 0, date);
    const months = [firstMonth];
    for (let monthIndex = 1; monthIndex < MONTHS_IN_VIEW; monthIndex++) {
      months.push(this.dateService.addMonth(firstMonth, monthIndex));
    }
    this.months = batch(months, MONTHS_IN_COLUMN);
  }
  onSelect(month) {
    this.monthChange.emit(month);
  }
};
_NbCalendarMonthPickerComponent.ɵfac = function NbCalendarMonthPickerComponent_Factory(t) {
  return new (t || _NbCalendarMonthPickerComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarMonthPickerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarMonthPickerComponent,
  selectors: [["nb-calendar-month-picker"]],
  hostVars: 2,
  hostBindings: function NbCalendarMonthPickerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("size-large", ctx.large);
    }
  },
  inputs: {
    min: "min",
    max: "max",
    filter: "filter",
    size: "size",
    month: "month",
    date: "date",
    _cellComponent: [InputFlags.None, "cellComponent", "_cellComponent"]
  },
  outputs: {
    monthChange: "monthChange"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 1,
  vars: 8,
  consts: [[3, "data", "min", "max", "filter", "selectedValue", "visibleDate", "cellComponent", "size", "select"]],
  template: function NbCalendarMonthPickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nb-calendar-picker", 0);
      ɵɵlistener("select", function NbCalendarMonthPickerComponent_Template_nb_calendar_picker_select_0_listener($event) {
        return ctx.onSelect($event);
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("data", ctx.months)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("selectedValue", ctx.date)("visibleDate", ctx.month)("cellComponent", ctx.cellComponent)("size", ctx.size);
    }
  },
  dependencies: [NbCalendarPickerComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarMonthPickerComponent = _NbCalendarMonthPickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarMonthPickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-month-picker",
      template: `
    <nb-calendar-picker
      [data]="months"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [selectedValue]="date"
      [visibleDate]="month"
      [cellComponent]="cellComponent"
      [size]="size"
      (select)="onSelect($event)">
    </nb-calendar-picker>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbDateService
  }], {
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    month: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    monthChange: [{
      type: Output
    }],
    _cellComponent: [{
      type: Input,
      args: ["cellComponent"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var _NbCalendarDayCellComponent = class _NbCalendarDayCellComponent {
  constructor(dateService) {
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.dayCellClass = true;
  }
  get today() {
    return this.dateService.isSameDaySafe(this.date, this.dateService.today());
  }
  get boundingMonth() {
    return !this.dateService.isSameMonthSafe(this.date, this.visibleDate);
  }
  get selected() {
    return this.dateService.isSameDaySafe(this.date, this.selectedValue);
  }
  get empty() {
    return !this.date;
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax() || this.dontFitFilter();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get day() {
    return this.date && this.dateService.getDate(this.date);
  }
  onClick() {
    if (this.disabled || this.empty) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.date, this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.date, this.max) > 0;
  }
  dontFitFilter() {
    return this.date && this.filter && !this.filter(this.date);
  }
};
_NbCalendarDayCellComponent.ɵfac = function NbCalendarDayCellComponent_Factory(t) {
  return new (t || _NbCalendarDayCellComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarDayCellComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarDayCellComponent,
  selectors: [["nb-calendar-day-cell"]],
  hostVars: 14,
  hostBindings: function NbCalendarDayCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbCalendarDayCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("today", ctx.today)("bounding-month", ctx.boundingMonth)("selected", ctx.selected)("empty", ctx.empty)("disabled", ctx.disabled)("size-large", ctx.isLarge)("day-cell", ctx.dayCellClass);
    }
  },
  inputs: {
    date: "date",
    selectedValue: "selectedValue",
    visibleDate: "visibleDate",
    min: "min",
    max: "max",
    filter: "filter",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  decls: 2,
  vars: 1,
  consts: [[1, "cell-content"]],
  template: function NbCalendarDayCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.day, " ");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarDayCellComponent = _NbCalendarDayCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarDayCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-day-cell",
      template: `
    <div class="cell-content">
      {{ day }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    boundingMonth: [{
      type: HostBinding,
      args: ["class.bounding-month"]
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    empty: [{
      type: HostBinding,
      args: ["class.empty"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    dayCellClass: [{
      type: HostBinding,
      args: ["class.day-cell"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbCalendarMonthModelService = class _NbCalendarMonthModelService {
  constructor(dateService) {
    this.dateService = dateService;
  }
  createDaysGrid(activeMonth, boundingMonth = true, firstDayOfWeek) {
    const weeks = this.createDates(activeMonth, firstDayOfWeek);
    return this.withBoundingMonths(weeks, activeMonth, boundingMonth);
  }
  createDates(activeMonth, firstDayOfWeek) {
    const days = this.createDateRangeForMonth(activeMonth);
    const startOfWeekDayDiff = this.getStartOfWeekDayDiff(activeMonth, firstDayOfWeek);
    return batch(days, this.dateService.DAYS_IN_WEEK, startOfWeekDayDiff);
  }
  withBoundingMonths(weeks, activeMonth, boundingMonth) {
    let withBoundingMonths = weeks;
    if (this.isShouldAddPrevBoundingMonth(withBoundingMonths)) {
      withBoundingMonths = this.addPrevBoundingMonth(withBoundingMonths, activeMonth, boundingMonth);
    }
    if (this.isShouldAddNextBoundingMonth(withBoundingMonths)) {
      withBoundingMonths = this.addNextBoundingMonth(withBoundingMonths, activeMonth, boundingMonth);
    }
    return withBoundingMonths;
  }
  addPrevBoundingMonth(weeks, activeMonth, boundingMonth) {
    const firstWeek = weeks.shift();
    const requiredItems = this.dateService.DAYS_IN_WEEK - firstWeek.length;
    firstWeek.unshift(...this.createPrevBoundingDays(activeMonth, boundingMonth, requiredItems));
    return [firstWeek, ...weeks];
  }
  addNextBoundingMonth(weeks, activeMonth, boundingMonth) {
    const lastWeek = weeks.pop();
    const requiredItems = this.dateService.DAYS_IN_WEEK - lastWeek.length;
    lastWeek.push(...this.createNextBoundingDays(activeMonth, boundingMonth, requiredItems));
    return [...weeks, lastWeek];
  }
  createPrevBoundingDays(activeMonth, boundingMonth, requiredItems) {
    const month = this.dateService.addMonth(activeMonth, -1);
    const daysInMonth = this.dateService.getNumberOfDaysInMonth(month);
    return this.createDateRangeForMonth(month).slice(daysInMonth - requiredItems).map((date) => boundingMonth ? date : null);
  }
  createNextBoundingDays(activeMonth, boundingMonth, requiredItems) {
    const month = this.dateService.addMonth(activeMonth, 1);
    return this.createDateRangeForMonth(month).slice(0, requiredItems).map((date) => boundingMonth ? date : null);
  }
  getStartOfWeekDayDiff(date, firstDayOfWeek) {
    const startOfMonth = this.dateService.getMonthStart(date);
    return this.getWeekStartDiff(startOfMonth, firstDayOfWeek);
  }
  getWeekStartDiff(date, firstDayOfWeek) {
    const weekOfset = firstDayOfWeek ?? this.dateService.getFirstDayOfWeek();
    return (7 - weekOfset + this.dateService.getDayOfWeek(date)) % 7;
  }
  isShouldAddPrevBoundingMonth(weeks) {
    return weeks[0].length < this.dateService.DAYS_IN_WEEK;
  }
  isShouldAddNextBoundingMonth(weeks) {
    return weeks[weeks.length - 1].length < this.dateService.DAYS_IN_WEEK;
  }
  createDateRangeForMonth(date) {
    const daysInMonth = this.dateService.getNumberOfDaysInMonth(date);
    return range(daysInMonth, (i) => {
      const year = this.dateService.getYear(date);
      const month = this.dateService.getMonth(date);
      return this.dateService.createDate(year, month, i + 1);
    });
  }
};
_NbCalendarMonthModelService.ɵfac = function NbCalendarMonthModelService_Factory(t) {
  return new (t || _NbCalendarMonthModelService)(ɵɵinject(NbDateService));
};
_NbCalendarMonthModelService.ɵprov = ɵɵdefineInjectable({
  token: _NbCalendarMonthModelService,
  factory: _NbCalendarMonthModelService.ɵfac
});
var NbCalendarMonthModelService = _NbCalendarMonthModelService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarMonthModelService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var _NbCalendarDaysNamesComponent = class _NbCalendarDaysNamesComponent {
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  constructor(dateService) {
    this.dateService = dateService;
  }
  ngOnInit() {
    const days = this.createDaysNames();
    this.days = this.shiftStartOfWeek(days);
  }
  ngOnChanges({
    firstDayOfWeek
  }) {
    if (firstDayOfWeek) {
      const days = this.createDaysNames();
      this.days = this.shiftStartOfWeek(days);
    }
  }
  createDaysNames() {
    return this.dateService.getDayOfWeekNames().map(this.markIfHoliday);
  }
  shiftStartOfWeek(days) {
    const firstDayOfWeek = this.firstDayOfWeek ?? this.dateService.getFirstDayOfWeek();
    for (let i = 0; i < firstDayOfWeek; i++) {
      days.push(days.shift());
    }
    return days;
  }
  markIfHoliday(name, i) {
    return {
      name,
      isHoliday: i % 6 === 0
    };
  }
};
_NbCalendarDaysNamesComponent.ɵfac = function NbCalendarDaysNamesComponent_Factory(t) {
  return new (t || _NbCalendarDaysNamesComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarDaysNamesComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarDaysNamesComponent,
  selectors: [["nb-calendar-days-names"]],
  hostVars: 2,
  hostBindings: function NbCalendarDaysNamesComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("size-large", ctx.isLarge);
    }
  },
  inputs: {
    size: "size",
    firstDayOfWeek: "firstDayOfWeek"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 1,
  vars: 1,
  consts: [["class", "day", 3, "holiday", 4, "ngFor", "ngForOf"], [1, "day"]],
  template: function NbCalendarDaysNamesComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbCalendarDaysNamesComponent_div_0_Template, 2, 3, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngForOf", ctx.days);
    }
  },
  dependencies: [NgForOf],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;justify-content:space-between}[_nghost-%COMP%]   .day[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center}"],
  changeDetection: 0
});
var NbCalendarDaysNamesComponent = _NbCalendarDaysNamesComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarDaysNamesComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-days-names",
      template: `
    <div class="day" *ngFor="let day of days" [class.holiday]="day.isHoliday">{{ day.name }}</div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;justify-content:space-between}:host .day{display:flex;align-items:center;justify-content:center}\n"]
    }]
  }], () => [{
    type: NbDateService
  }], {
    size: [{
      type: Input
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    firstDayOfWeek: [{
      type: Input
    }]
  });
})();
var _NbCalendarWeekNumberComponent = class _NbCalendarWeekNumberComponent {
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  constructor(dateService) {
    this.dateService = dateService;
  }
  ngOnChanges(changes) {
    if (changes.weeks) {
      this.weekNumbers = this.getWeeks();
    }
  }
  getWeeks() {
    return this.weeks.map((week) => {
      const lastDay = [...week].reverse().find((day) => !!day);
      return this.dateService.getWeekNumber(lastDay);
    });
  }
};
_NbCalendarWeekNumberComponent.ɵfac = function NbCalendarWeekNumberComponent_Factory(t) {
  return new (t || _NbCalendarWeekNumberComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarWeekNumberComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarWeekNumberComponent,
  selectors: [["nb-calendar-week-numbers"]],
  hostVars: 2,
  hostBindings: function NbCalendarWeekNumberComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("size-large", ctx.isLarge);
    }
  },
  inputs: {
    weeks: "weeks",
    size: "size",
    weekNumberSymbol: "weekNumberSymbol"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 4,
  vars: 2,
  consts: [[1, "sign-container"], [1, "sign"], ["class", "week-number", 4, "ngFor", "ngForOf"], [1, "week-number"]],
  template: function NbCalendarWeekNumberComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "div", 1);
      ɵɵtext(2);
      ɵɵelementEnd()();
      ɵɵtemplate(3, NbCalendarWeekNumberComponent_div_3_Template, 2, 1, "div", 2);
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵtextInterpolate(ctx.weekNumberSymbol);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.weekNumbers);
    }
  },
  dependencies: [NgForOf],
  styles: [_c8],
  changeDetection: 0
});
var NbCalendarWeekNumberComponent = _NbCalendarWeekNumberComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarWeekNumberComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-week-numbers",
      template: `
    <div class="sign-container">
      <div class="sign">{{ weekNumberSymbol }}</div>
    </div>
    <div class="week-number" *ngFor="let weekNumber of weekNumbers">{{ weekNumber }}</div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;flex-direction:column}\n"]
    }]
  }], () => [{
    type: NbDateService
  }], {
    weeks: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var _NbCalendarDayPickerComponent = class _NbCalendarDayPickerComponent {
  /**
   * Custom day cell component. Have to implement `NbCalendarCell` interface.
   * */
  set setCellComponent(cellComponent) {
    if (cellComponent) {
      this.cellComponent = cellComponent;
    }
  }
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
  get large() {
    return this.size === NbCalendarSize.LARGE;
  }
  constructor(monthModel) {
    this.monthModel = monthModel;
    this.boundingMonths = true;
    this.cellComponent = NbCalendarDayCellComponent;
    this.size = NbCalendarSize.MEDIUM;
    this._showWeekNumber = false;
    this.dateChange = new EventEmitter();
  }
  ngOnChanges({
    visibleDate,
    boundingMonths,
    firstDayOfWeek
  }) {
    if (visibleDate || boundingMonths || firstDayOfWeek) {
      this.weeks = this.monthModel.createDaysGrid(this.visibleDate, this.boundingMonths, this.firstDayOfWeek);
    }
  }
  onSelect(day) {
    this.dateChange.emit(day);
  }
};
_NbCalendarDayPickerComponent.ɵfac = function NbCalendarDayPickerComponent_Factory(t) {
  return new (t || _NbCalendarDayPickerComponent)(ɵɵdirectiveInject(NbCalendarMonthModelService));
};
_NbCalendarDayPickerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarDayPickerComponent,
  selectors: [["nb-calendar-day-picker"]],
  hostVars: 2,
  hostBindings: function NbCalendarDayPickerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("size-large", ctx.large);
    }
  },
  inputs: {
    visibleDate: "visibleDate",
    boundingMonths: "boundingMonths",
    min: "min",
    max: "max",
    filter: "filter",
    setCellComponent: [InputFlags.None, "cellComponent", "setCellComponent"],
    size: "size",
    date: "date",
    showWeekNumber: "showWeekNumber",
    weekNumberSymbol: "weekNumberSymbol",
    firstDayOfWeek: "firstDayOfWeek"
  },
  outputs: {
    dateChange: "dateChange"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 4,
  vars: 11,
  consts: [[3, "weeks", "size", "weekNumberSymbol", 4, "ngIf"], [1, "days-container"], [3, "size", "firstDayOfWeek"], [3, "data", "visibleDate", "selectedValue", "cellComponent", "min", "max", "filter", "size", "select"], [3, "weeks", "size", "weekNumberSymbol"]],
  template: function NbCalendarDayPickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbCalendarDayPickerComponent_nb_calendar_week_numbers_0_Template, 1, 3, "nb-calendar-week-numbers", 0);
      ɵɵelementStart(1, "div", 1);
      ɵɵelement(2, "nb-calendar-days-names", 2);
      ɵɵelementStart(3, "nb-calendar-picker", 3);
      ɵɵlistener("select", function NbCalendarDayPickerComponent_Template_nb_calendar_picker_select_3_listener($event) {
        return ctx.onSelect($event);
      });
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.showWeekNumber);
      ɵɵadvance(2);
      ɵɵproperty("size", ctx.size)("firstDayOfWeek", ctx.firstDayOfWeek);
      ɵɵadvance();
      ɵɵproperty("data", ctx.weeks)("visibleDate", ctx.visibleDate)("selectedValue", ctx.date)("cellComponent", ctx.cellComponent)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("size", ctx.size);
    }
  },
  dependencies: [NgIf, NbCalendarDaysNamesComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent],
  styles: ["[_nghost-%COMP%]{display:flex}.days-container[_ngcontent-%COMP%]{width:100%}"],
  changeDetection: 0
});
var NbCalendarDayPickerComponent = _NbCalendarDayPickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarDayPickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-day-picker",
      template: `
    <nb-calendar-week-numbers *ngIf="showWeekNumber"
                              [weeks]="weeks"
                              [size]="size"
                              [weekNumberSymbol]="weekNumberSymbol">
    </nb-calendar-week-numbers>
    <div class="days-container">
      <nb-calendar-days-names [size]="size" [firstDayOfWeek]="firstDayOfWeek"></nb-calendar-days-names>
      <nb-calendar-picker
          [data]="weeks"
          [visibleDate]="visibleDate"
          [selectedValue]="date"
          [cellComponent]="cellComponent"
          [min]="min"
          [max]="max"
          [filter]="filter"
          [size]="size"
          (select)="onSelect($event)">
      </nb-calendar-picker>
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [":host{display:flex}.days-container{width:100%}\n"]
    }]
  }], () => [{
    type: NbCalendarMonthModelService
  }], {
    visibleDate: [{
      type: Input
    }],
    boundingMonths: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    setCellComponent: [{
      type: Input,
      args: ["cellComponent"]
    }],
    size: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    dateChange: [{
      type: Output
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var _NbBaseCalendarComponent = class _NbBaseCalendarComponent {
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
  constructor(dateService, yearModelService) {
    this.dateService = dateService;
    this.yearModelService = yearModelService;
    this.boundingMonth = true;
    this.activeViewMode = NbCalendarViewMode.DATE;
    this.size = NbCalendarSize.MEDIUM;
    this.showNavigation = true;
    this._showWeekNumber = false;
    this.dateChange = new EventEmitter();
    this.ViewMode = NbCalendarViewMode;
  }
  ngOnInit() {
    if (!this.visibleDate) {
      this.visibleDate = this.dateService.today();
    }
  }
  get large() {
    return this.size === NbCalendarSize.LARGE;
  }
  setViewMode(viewMode) {
    this.activeViewMode = viewMode;
  }
  setVisibleDate(visibleDate) {
    this.visibleDate = visibleDate;
  }
  prevMonth() {
    this.changeVisibleMonth(-1);
  }
  nextMonth() {
    this.changeVisibleMonth(1);
  }
  prevYear() {
    this.changeVisibleYear(-1);
  }
  nextYear() {
    this.changeVisibleYear(1);
  }
  prevYears() {
    this.changeVisibleYears(-1);
  }
  nextYears() {
    this.changeVisibleYears(1);
  }
  navigatePrev() {
    switch (this.activeViewMode) {
      case NbCalendarViewMode.DATE:
        return this.prevMonth();
      case NbCalendarViewMode.MONTH:
        return this.prevYear();
      case NbCalendarViewMode.YEAR:
        return this.prevYears();
    }
  }
  navigateNext() {
    switch (this.activeViewMode) {
      case NbCalendarViewMode.DATE:
        return this.nextMonth();
      case NbCalendarViewMode.MONTH:
        return this.nextYear();
      case NbCalendarViewMode.YEAR:
        return this.nextYears();
    }
  }
  onChangeViewMode() {
    if (this.activeViewMode === NbCalendarViewMode.DATE) {
      return this.setViewMode(NbCalendarViewMode.YEAR);
    }
    this.setViewMode(NbCalendarViewMode.DATE);
  }
  changeVisibleMonth(direction) {
    this.visibleDate = this.dateService.addMonth(this.visibleDate, direction);
  }
  changeVisibleYear(direction) {
    this.visibleDate = this.dateService.addYear(this.visibleDate, direction);
  }
  changeVisibleYears(direction) {
    this.visibleDate = this.dateService.addYear(this.visibleDate, direction * this.yearModelService.getYearsInView());
  }
};
_NbBaseCalendarComponent.ɵfac = function NbBaseCalendarComponent_Factory(t) {
  return new (t || _NbBaseCalendarComponent)(ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(NbCalendarYearModelService));
};
_NbBaseCalendarComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbBaseCalendarComponent,
  selectors: [["nb-base-calendar"]],
  hostVars: 6,
  hostBindings: function NbBaseCalendarComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("has-navigation", ctx.showNavigation)("has-week-number", ctx.showWeekNumber)("size-large", ctx.large);
    }
  },
  inputs: {
    boundingMonth: "boundingMonth",
    activeViewMode: [InputFlags.None, "startView", "activeViewMode"],
    min: "min",
    max: "max",
    filter: "filter",
    dayCellComponent: "dayCellComponent",
    monthCellComponent: "monthCellComponent",
    yearCellComponent: "yearCellComponent",
    size: "size",
    visibleDate: "visibleDate",
    showNavigation: "showNavigation",
    date: "date",
    showWeekNumber: "showWeekNumber",
    weekNumberSymbol: "weekNumberSymbol",
    firstDayOfWeek: "firstDayOfWeek"
  },
  outputs: {
    dateChange: "dateChange"
  },
  decls: 6,
  vars: 5,
  consts: [["class", "calendar-navigation", 4, "ngIf"], [3, "ngSwitch"], [3, "boundingMonths", "cellComponent", "min", "max", "filter", "visibleDate", "size", "date", "showWeekNumber", "firstDayOfWeek", "weekNumberSymbol", "dateChange", 4, "ngSwitchCase"], [3, "cellComponent", "date", "min", "max", "filter", "size", "year", "yearChange", 4, "ngSwitchCase"], [3, "cellComponent", "min", "max", "filter", "size", "month", "date", "monthChange", 4, "ngSwitchCase"], [1, "calendar-navigation"], [3, "date", "viewMode", "changeMode"], [3, "prev", "next"], [3, "boundingMonths", "cellComponent", "min", "max", "filter", "visibleDate", "size", "date", "showWeekNumber", "firstDayOfWeek", "weekNumberSymbol", "dateChange"], [3, "cellComponent", "date", "min", "max", "filter", "size", "year", "yearChange"], [3, "cellComponent", "min", "max", "filter", "size", "month", "date", "monthChange"]],
  template: function NbBaseCalendarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nb-card");
      ɵɵtemplate(1, NbBaseCalendarComponent_nb_card_header_1_Template, 3, 2, "nb-card-header", 0);
      ɵɵelementStart(2, "nb-card-body", 1);
      ɵɵtemplate(3, NbBaseCalendarComponent_nb_calendar_day_picker_3_Template, 1, 11, "nb-calendar-day-picker", 2)(4, NbBaseCalendarComponent_nb_calendar_year_picker_4_Template, 1, 7, "nb-calendar-year-picker", 3)(5, NbBaseCalendarComponent_nb_calendar_month_picker_5_Template, 1, 7, "nb-calendar-month-picker", 4);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showNavigation);
      ɵɵadvance();
      ɵɵproperty("ngSwitch", ctx.activeViewMode);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", ctx.ViewMode.DATE);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", ctx.ViewMode.YEAR);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", ctx.ViewMode.MONTH);
    }
  },
  dependencies: [NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, NbCalendarDayPickerComponent, NgIf, NgSwitch, NgSwitchCase, NbCardComponent, NbCardBodyComponent, NbCardHeaderComponent],
  encapsulation: 2
});
var NbBaseCalendarComponent = _NbBaseCalendarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBaseCalendarComponent, [{
    type: Component,
    args: [{
      selector: "nb-base-calendar",
      template: '<nb-card>\n  <nb-card-header *ngIf="showNavigation" class="calendar-navigation">\n    <nb-calendar-view-mode [date]="visibleDate"\n                           [viewMode]="activeViewMode"\n                           (changeMode)="onChangeViewMode()">\n    </nb-calendar-view-mode>\n\n    <nb-calendar-pageable-navigation (prev)="navigatePrev()" (next)="navigateNext()">\n    </nb-calendar-pageable-navigation>\n  </nb-card-header>\n\n  <nb-card-body [ngSwitch]="activeViewMode">\n\n    <nb-calendar-day-picker *ngSwitchCase="ViewMode.DATE"\n                            [boundingMonths]="boundingMonth"\n                            [cellComponent]="dayCellComponent"\n                            [min]="min"\n                            [max]="max"\n                            [filter]="filter"\n                            [visibleDate]="visibleDate"\n                            [size]="size"\n                            [date]="date"\n                            [showWeekNumber]="showWeekNumber"\n                            [firstDayOfWeek]="firstDayOfWeek"\n                            (dateChange)="dateChange.emit($any($event))"\n                            [weekNumberSymbol]="weekNumberSymbol">\n    </nb-calendar-day-picker>\n\n    <nb-calendar-year-picker *ngSwitchCase="ViewMode.YEAR"\n                             [cellComponent]="yearCellComponent"\n                             [date]="$any(date)"\n                             [min]="min"\n                             [max]="max"\n                             [filter]="filter"\n                             [size]="size"\n                             [year]="visibleDate"\n                             (yearChange)="setVisibleDate($event); setViewMode(ViewMode.MONTH)">\n    </nb-calendar-year-picker>\n\n    <nb-calendar-month-picker *ngSwitchCase="ViewMode.MONTH"\n                              [cellComponent]="monthCellComponent"\n                              [min]="min"\n                              [max]="max"\n                              [filter]="filter"\n                              [size]="size"\n                              [month]="visibleDate"\n                              [date]="$any(date)"\n                              (monthChange)="setVisibleDate($event); setViewMode(ViewMode.DATE)">\n    </nb-calendar-month-picker>\n\n  </nb-card-body>\n\n</nb-card>\n'
    }]
  }], () => [{
    type: NbDateService
  }, {
    type: NbCalendarYearModelService
  }], {
    boundingMonth: [{
      type: Input
    }],
    activeViewMode: [{
      type: Input,
      args: ["startView"]
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    dayCellComponent: [{
      type: Input
    }],
    monthCellComponent: [{
      type: Input
    }],
    yearCellComponent: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    showNavigation: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.has-navigation"]
    }],
    date: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.has-week-number"]
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    dateChange: [{
      type: Output
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }]
  });
})();
var _NbCalendarComponent = class _NbCalendarComponent {
  constructor() {
    this.boundingMonth = true;
    this.startView = NbCalendarViewMode.DATE;
    this.size = NbCalendarSize.MEDIUM;
    this.showNavigation = true;
    this._showWeekNumber = false;
    this.weekNumberSymbol = "#";
    this.dateChange = new EventEmitter();
  }
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
};
_NbCalendarComponent.ɵfac = function NbCalendarComponent_Factory(t) {
  return new (t || _NbCalendarComponent)();
};
_NbCalendarComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarComponent,
  selectors: [["nb-calendar"]],
  inputs: {
    boundingMonth: "boundingMonth",
    startView: "startView",
    min: "min",
    max: "max",
    filter: "filter",
    dayCellComponent: "dayCellComponent",
    monthCellComponent: "monthCellComponent",
    yearCellComponent: "yearCellComponent",
    size: "size",
    visibleDate: "visibleDate",
    showNavigation: "showNavigation",
    date: "date",
    showWeekNumber: "showWeekNumber",
    weekNumberSymbol: "weekNumberSymbol",
    firstDayOfWeek: "firstDayOfWeek"
  },
  outputs: {
    dateChange: "dateChange"
  },
  decls: 1,
  vars: 15,
  consts: [[3, "boundingMonth", "startView", "date", "min", "max", "filter", "dayCellComponent", "monthCellComponent", "yearCellComponent", "size", "visibleDate", "showNavigation", "showWeekNumber", "weekNumberSymbol", "firstDayOfWeek", "dateChange"]],
  template: function NbCalendarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nb-base-calendar", 0);
      ɵɵlistener("dateChange", function NbCalendarComponent_Template_nb_base_calendar_dateChange_0_listener($event) {
        return ctx.dateChange.emit($event);
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("boundingMonth", ctx.boundingMonth)("startView", ctx.startView)("date", ctx.date)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("dayCellComponent", ctx.dayCellComponent)("monthCellComponent", ctx.monthCellComponent)("yearCellComponent", ctx.yearCellComponent)("size", ctx.size)("visibleDate", ctx.visibleDate)("showNavigation", ctx.showNavigation)("showWeekNumber", ctx.showWeekNumber)("weekNumberSymbol", ctx.weekNumberSymbol)("firstDayOfWeek", ctx.firstDayOfWeek);
    }
  },
  dependencies: [NbBaseCalendarComponent],
  encapsulation: 2
});
var NbCalendarComponent = _NbCalendarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar",
      template: `
    <nb-base-calendar
      [boundingMonth]="boundingMonth"
      [startView]="startView"
      [date]="date"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [dayCellComponent]="dayCellComponent"
      [monthCellComponent]="monthCellComponent"
      [yearCellComponent]="yearCellComponent"
      [size]="size"
      [visibleDate]="visibleDate"
      [showNavigation]="showNavigation"
      [showWeekNumber]="showWeekNumber"
      [weekNumberSymbol]="weekNumberSymbol"
      [firstDayOfWeek]="firstDayOfWeek"
      (dateChange)="dateChange.emit($event)"
    ></nb-base-calendar>
  `
    }]
  }], null, {
    boundingMonth: [{
      type: Input
    }],
    startView: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    dayCellComponent: [{
      type: Input
    }],
    monthCellComponent: [{
      type: Input
    }],
    yearCellComponent: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    showNavigation: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    dateChange: [{
      type: Output
    }]
  });
})();
var NB_BUTTON_COMPONENTS = [NbButtonComponent];
var _NbButtonModule = class _NbButtonModule {
};
_NbButtonModule.ɵfac = function NbButtonModule_Factory(t) {
  return new (t || _NbButtonModule)();
};
_NbButtonModule.ɵmod = ɵɵdefineNgModule({
  type: _NbButtonModule,
  declarations: [NbButtonComponent],
  imports: [NbSharedModule],
  exports: [NbButtonComponent]
});
_NbButtonModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule]
});
var NbButtonModule = _NbButtonModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [...NB_BUTTON_COMPONENTS],
      exports: [...NB_BUTTON_COMPONENTS]
    }]
  }], null, null);
})();
var _NbNativeDateService = class _NbNativeDateService extends NbDateService {
  constructor(locale) {
    super();
    this.setLocale(locale);
  }
  setLocale(locale) {
    super.setLocale(locale);
    this.datePipe = new DatePipe(locale);
  }
  setHours(date, hour) {
    const result = this.clone(date);
    result.setHours(hour);
    return result;
  }
  setMinutes(date, minute) {
    const result = this.clone(date);
    result.setMinutes(minute);
    return result;
  }
  setSeconds(date, second) {
    const result = this.clone(date);
    result.setSeconds(second);
    return result;
  }
  setMilliseconds(date, second) {
    const result = this.clone(date);
    result.setMilliseconds(second);
    return result;
  }
  isValidDateString(date, format) {
    return !isNaN(this.parse(date, format).getTime());
  }
  isValidTimeString(date, format) {
    return this.isValidDateString(date, format);
  }
  today() {
    return /* @__PURE__ */ new Date();
  }
  getLocaleTimeFormat() {
    return getLocaleTimeFormat(this.locale, FormatWidth.Short);
  }
  getDate(date) {
    return date.getDate();
  }
  getMonth(date) {
    return date.getMonth();
  }
  getYear(date) {
    return date.getFullYear();
  }
  getDayOfWeek(date) {
    return date.getDay();
  }
  /**
   * returns first day of the week, it can be 1 if week starts from monday
   * and 0 if from sunday and so on.
   * */
  getFirstDayOfWeek() {
    return getLocaleFirstDayOfWeek(this.locale);
  }
  getMonthName(date, style2 = TranslationWidth.Abbreviated) {
    const index = date.getMonth();
    return this.getMonthNameByIndex(index, style2);
  }
  getMonthNameByIndex(index, style2 = TranslationWidth.Abbreviated) {
    return getLocaleMonthNames(this.locale, FormStyle.Format, style2)[index];
  }
  getDayOfWeekNames() {
    return [...getLocaleDayNames(this.locale, FormStyle.Format, TranslationWidth.Short)];
  }
  format(date, format) {
    return this.datePipe.transform(date, format);
  }
  /**
   * We haven't got capability to parse date using formatting without third party libraries.
   * */
  parse(date, format) {
    return new Date(Date.parse(date));
  }
  addDay(date, num) {
    return this.createDate(date.getFullYear(), date.getMonth(), date.getDate() + num);
  }
  addMonth(date, num) {
    const month = this.createDate(date.getFullYear(), date.getMonth() + num, 1);
    month.setDate(Math.min(date.getDate(), this.getMonthEnd(month).getDate()));
    return month;
  }
  addMinutes(date, minute) {
    const result = new Date(date);
    result.setMinutes(date.getMinutes() + minute);
    return result;
  }
  addHours(date, hour) {
    const result = new Date(date);
    result.setHours(date.getHours() + hour);
    return result;
  }
  getHours(date) {
    return date.getHours();
  }
  getMinutes(date) {
    return date.getMinutes();
  }
  getSeconds(date) {
    return date.getSeconds();
  }
  getMilliseconds(date) {
    return date.getMilliseconds();
  }
  addYear(date, num) {
    return this.createDate(date.getFullYear() + num, date.getMonth(), date.getDate());
  }
  clone(date) {
    return new Date(date.getTime());
  }
  compareDates(date1, date2) {
    return date1.getTime() - date2.getTime();
  }
  createDate(year, month, date) {
    const result = new Date(year, month, date);
    if (year >= 0 && year < 100) {
      result.setFullYear(result.getFullYear() - 1900);
    }
    return result;
  }
  getMonthEnd(date) {
    return this.createDate(date.getFullYear(), date.getMonth() + 1, 0);
  }
  getMonthStart(date) {
    return this.createDate(date.getFullYear(), date.getMonth(), 1);
  }
  getNumberOfDaysInMonth(date) {
    return this.getMonthEnd(date).getDate();
  }
  getYearEnd(date) {
    return this.createDate(date.getFullYear(), 11, 31);
  }
  getYearStart(date) {
    return this.createDate(date.getFullYear(), 0, 1);
  }
  valueOf(date) {
    return date.valueOf();
  }
  isSameDay(date1, date2) {
    return this.isSameMonth(date1, date2) && date1.getDate() === date2.getDate();
  }
  isSameMonth(date1, date2) {
    return this.isSameYear(date1, date2) && date1.getMonth() === date2.getMonth();
  }
  isSameYear(date1, date2) {
    return date1.getFullYear() === date2.getFullYear();
  }
  getId() {
    return "native";
  }
  getWeekNumber(date) {
    return parseInt(this.datePipe.transform(date, "w"), 10);
  }
  getDateFormat() {
    return "yyyy-MM-dd";
  }
  getTwelveHoursFormat() {
    return "hh:mm a";
  }
};
_NbNativeDateService.ɵfac = function NbNativeDateService_Factory(t) {
  return new (t || _NbNativeDateService)(ɵɵinject(LOCALE_ID));
};
_NbNativeDateService.ɵprov = ɵɵdefineInjectable({
  token: _NbNativeDateService,
  factory: _NbNativeDateService.ɵfac
});
var NbNativeDateService = _NbNativeDateService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbNativeDateService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }], null);
})();
var _NbCalendarTimeModelService = class _NbCalendarTimeModelService {
  constructor(dateService) {
    this.dateService = dateService;
    this.MINUTES_AND_SECONDS = 60;
  }
  getHoursRange(step = this.MINUTES_AND_SECONDS) {
    let date = this.getResetTime();
    const endDate = this.dateService.addDay(date, 1);
    const result = [];
    while (this.dateService.compareDates(date, endDate) < 0) {
      result.push(date);
      date = this.dateService.addMinutes(date, step);
    }
    return result;
  }
  getResetTime() {
    let today = this.dateService.today();
    today = this.dateService.setHours(today, 0);
    today = this.dateService.setMinutes(today, 0);
    today = this.dateService.setSeconds(today, 0);
    today = this.dateService.setMilliseconds(today, 0);
    return today;
  }
  paddToTwoSymbols(n) {
    if (n < 10) {
      return "0" + n;
    }
    return n.toString();
  }
  buildDateFormat(twelveHoursFormat, withSeconds = false) {
    if (twelveHoursFormat) {
      return `${this.dateService.getDateFormat()} ${this.dateService.getTwelveHoursFormat()}`;
    }
    if (withSeconds) {
      return `${this.dateService.getDateFormat()} ${this.dateService.getTwentyFourHoursFormatWithSeconds()}`;
    }
    return `${this.dateService.getDateFormat()} ${this.dateService.getTwentyFourHoursFormat()}`;
  }
};
_NbCalendarTimeModelService.ɵfac = function NbCalendarTimeModelService_Factory(t) {
  return new (t || _NbCalendarTimeModelService)(ɵɵinject(NbDateService));
};
_NbCalendarTimeModelService.ɵprov = ɵɵdefineInjectable({
  token: _NbCalendarTimeModelService,
  factory: _NbCalendarTimeModelService.ɵfac
});
var NbCalendarTimeModelService = _NbCalendarTimeModelService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarTimeModelService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var _NbCalendarActionsComponent = class _NbCalendarActionsComponent {
  constructor() {
    this._applyButtonText = "ok";
    this._currentTimeButtonText = "now";
    this.setCurrentTime = new EventEmitter();
    this.saveValue = new EventEmitter();
  }
  set applyButtonText(value) {
    if (value) {
      this._applyButtonText = value;
    }
  }
  get applyText() {
    return this._applyButtonText;
  }
  set currentTimeButtonText(value) {
    if (value) {
      this._currentTimeButtonText = value;
    }
  }
  get currentTimeText() {
    return this._currentTimeButtonText;
  }
};
_NbCalendarActionsComponent.ɵfac = function NbCalendarActionsComponent_Factory(t) {
  return new (t || _NbCalendarActionsComponent)();
};
_NbCalendarActionsComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarActionsComponent,
  selectors: [["nb-calendar-actions"]],
  inputs: {
    applyButtonText: "applyButtonText",
    currentTimeButtonText: "currentTimeButtonText",
    showCurrentTimeButton: "showCurrentTimeButton"
  },
  outputs: {
    setCurrentTime: "setCurrentTime",
    saveValue: "saveValue"
  },
  decls: 3,
  vars: 2,
  consts: [["nbButton", "", "ghost", "", "status", "primary", "size", "small", 3, "click", 4, "ngIf"], ["nbButton", "", "status", "primary", "size", "small", 1, "apply-text-button", 3, "click"], ["nbButton", "", "ghost", "", "status", "primary", "size", "small", 3, "click"]],
  template: function NbCalendarActionsComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbCalendarActionsComponent_button_0_Template, 2, 1, "button", 0);
      ɵɵelementStart(1, "button", 1);
      ɵɵlistener("click", function NbCalendarActionsComponent_Template_button_click_1_listener() {
        return ctx.saveValue.emit();
      });
      ɵɵtext(2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.showCurrentTimeButton);
      ɵɵadvance(2);
      ɵɵtextInterpolate1(" ", ctx.applyText, "");
    }
  },
  dependencies: [NgIf, NbButtonComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;justify-content:space-between}[dir=ltr]   [_nghost-%COMP%]   .apply-text-button[_ngcontent-%COMP%]{margin-left:auto}[dir=rtl]   [_nghost-%COMP%]   .apply-text-button[_ngcontent-%COMP%]{margin-right:auto}"],
  changeDetection: 0
});
var NbCalendarActionsComponent = _NbCalendarActionsComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarActionsComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-actions",
      template: `
    <button
      *ngIf="showCurrentTimeButton"
      nbButton
      ghost
      status="primary"
      size="small"
      (click)="setCurrentTime.emit()">
      {{ currentTimeText }}</button>
    <button
      class="apply-text-button"
      nbButton
      status="primary"
      size="small"
      (click)="saveValue.emit()">
      {{ applyText }}</button>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;justify-content:space-between}[dir=ltr] :host .apply-text-button{margin-left:auto}[dir=rtl] :host .apply-text-button{margin-right:auto}\n"]
    }]
  }], null, {
    applyButtonText: [{
      type: Input
    }],
    currentTimeButtonText: [{
      type: Input
    }],
    showCurrentTimeButton: [{
      type: Input
    }],
    setCurrentTime: [{
      type: Output
    }],
    saveValue: [{
      type: Output
    }]
  });
})();
var SERVICES = [{
  provide: NbDateService,
  useClass: NbNativeDateService
}, DatePipe, NbCalendarMonthModelService, NbCalendarYearModelService, NbCalendarTimeModelService];
var COMPONENTS$3 = [NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarDaysNamesComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, NbCalendarDayPickerComponent, NbCalendarDayCellComponent, NbCalendarActionsComponent, NbCalendarMonthCellComponent, NbCalendarYearCellComponent, NbCalendarPickerRowComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent];
var _NbCalendarKitModule = class _NbCalendarKitModule {
};
_NbCalendarKitModule.ɵfac = function NbCalendarKitModule_Factory(t) {
  return new (t || _NbCalendarKitModule)();
};
_NbCalendarKitModule.ɵmod = ɵɵdefineNgModule({
  type: _NbCalendarKitModule,
  declarations: [NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarDaysNamesComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, NbCalendarDayPickerComponent, NbCalendarDayCellComponent, NbCalendarActionsComponent, NbCalendarMonthCellComponent, NbCalendarYearCellComponent, NbCalendarPickerRowComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent],
  imports: [NbSharedModule, NbButtonModule, NbIconModule],
  exports: [NbCalendarViewModeComponent, NbCalendarPageableNavigationComponent, NbCalendarDaysNamesComponent, NbCalendarYearPickerComponent, NbCalendarMonthPickerComponent, NbCalendarDayPickerComponent, NbCalendarDayCellComponent, NbCalendarActionsComponent, NbCalendarMonthCellComponent, NbCalendarYearCellComponent, NbCalendarPickerRowComponent, NbCalendarPickerComponent, NbCalendarWeekNumberComponent]
});
_NbCalendarKitModule.ɵinj = ɵɵdefineInjector({
  providers: [...SERVICES],
  imports: [NbSharedModule, NbButtonModule, NbIconModule]
});
var NbCalendarKitModule = _NbCalendarKitModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarKitModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbButtonModule, NbIconModule],
      exports: [...COMPONENTS$3],
      declarations: [...COMPONENTS$3],
      providers: [...SERVICES]
    }]
  }], null, null);
})();
var _NbBaseCalendarModule = class _NbBaseCalendarModule {
};
_NbBaseCalendarModule.ɵfac = function NbBaseCalendarModule_Factory(t) {
  return new (t || _NbBaseCalendarModule)();
};
_NbBaseCalendarModule.ɵmod = ɵɵdefineNgModule({
  type: _NbBaseCalendarModule,
  declarations: [NbBaseCalendarComponent],
  imports: [NbCalendarKitModule, NbSharedModule, NbCardModule],
  exports: [NbBaseCalendarComponent]
});
_NbBaseCalendarModule.ɵinj = ɵɵdefineInjector({
  imports: [NbCalendarKitModule, NbSharedModule, NbCardModule]
});
var NbBaseCalendarModule = _NbBaseCalendarModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBaseCalendarModule, [{
    type: NgModule,
    args: [{
      imports: [NbCalendarKitModule, NbSharedModule, NbCardModule],
      exports: [NbBaseCalendarComponent],
      declarations: [NbBaseCalendarComponent]
    }]
  }], null, null);
})();
var _NbCalendarModule = class _NbCalendarModule {
};
_NbCalendarModule.ɵfac = function NbCalendarModule_Factory(t) {
  return new (t || _NbCalendarModule)();
};
_NbCalendarModule.ɵmod = ɵɵdefineNgModule({
  type: _NbCalendarModule,
  declarations: [NbCalendarComponent],
  imports: [NbBaseCalendarModule],
  exports: [NbCalendarComponent]
});
_NbCalendarModule.ɵinj = ɵɵdefineInjector({
  imports: [NbBaseCalendarModule]
});
var NbCalendarModule = _NbCalendarModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarModule, [{
    type: NgModule,
    args: [{
      imports: [NbBaseCalendarModule],
      exports: [NbCalendarComponent],
      declarations: [NbCalendarComponent]
    }]
  }], null, null);
})();
var NbBaseCalendarRangeCell = class {
  get hasRange() {
    return !!(this.selectedValue && this.selectedValue.start && this.selectedValue.end);
  }
};
var _NbCalendarRangeDayCellComponent = class _NbCalendarRangeDayCellComponent extends NbBaseCalendarRangeCell {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.rangeCellClass = true;
    this.dayCellClass = true;
  }
  get inRange() {
    if (this.date && this.hasRange) {
      return this.isInRange(this.date, this.selectedValue);
    }
    return false;
  }
  get start() {
    return this.date && this.hasRange && this.dateService.isSameDay(this.date, this.selectedValue.start);
  }
  get end() {
    return this.date && this.hasRange && this.dateService.isSameDay(this.date, this.selectedValue.end);
  }
  get today() {
    return this.date && this.dateService.isSameDay(this.date, this.dateService.today());
  }
  get boundingMonth() {
    return !this.dateService.isSameMonthSafe(this.date, this.visibleDate);
  }
  get selected() {
    if (this.inRange) {
      return true;
    }
    if (this.selectedValue) {
      return this.dateService.isSameDaySafe(this.date, this.selectedValue.start);
    }
    return false;
  }
  get empty() {
    return !this.date;
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax() || this.dontFitFilter();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get day() {
    return this.date && this.dateService.getDate(this.date);
  }
  onClick() {
    if (this.disabled || this.empty) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.date, this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.date, this.max) > 0;
  }
  dontFitFilter() {
    return this.date && this.filter && !this.filter(this.date);
  }
  isInRange(date, {
    start,
    end
  }) {
    const isGreaterThanStart = this.dateService.compareDates(this.date, start) >= 0;
    const isLessThanEnd = this.dateService.compareDates(this.date, end) <= 0;
    return isGreaterThanStart && isLessThanEnd;
  }
};
_NbCalendarRangeDayCellComponent.ɵfac = function NbCalendarRangeDayCellComponent_Factory(t) {
  return new (t || _NbCalendarRangeDayCellComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarRangeDayCellComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarRangeDayCellComponent,
  selectors: [["nb-calendar-range-day-cell"]],
  hostVars: 22,
  hostBindings: function NbCalendarRangeDayCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbCalendarRangeDayCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("in-range", ctx.inRange)("start", ctx.start)("end", ctx.end)("range-cell", ctx.rangeCellClass)("day-cell", ctx.dayCellClass)("today", ctx.today)("bounding-month", ctx.boundingMonth)("selected", ctx.selected)("empty", ctx.empty)("disabled", ctx.disabled)("size-large", ctx.isLarge);
    }
  },
  inputs: {
    date: "date",
    selectedValue: "selectedValue",
    visibleDate: "visibleDate",
    min: "min",
    max: "max",
    filter: "filter",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 1,
  consts: [[1, "cell-content"]],
  template: function NbCalendarRangeDayCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate(ctx.day);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarRangeDayCellComponent = _NbCalendarRangeDayCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeDayCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-range-day-cell",
      template: `
    <div class="cell-content">{{ day }}</div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    inRange: [{
      type: HostBinding,
      args: ["class.in-range"]
    }],
    start: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    end: [{
      type: HostBinding,
      args: ["class.end"]
    }],
    rangeCellClass: [{
      type: HostBinding,
      args: ["class.range-cell"]
    }],
    dayCellClass: [{
      type: HostBinding,
      args: ["class.day-cell"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    boundingMonth: [{
      type: HostBinding,
      args: ["class.bounding-month"]
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    empty: [{
      type: HostBinding,
      args: ["class.empty"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbCalendarRangeYearCellComponent = class _NbCalendarRangeYearCellComponent extends NbBaseCalendarRangeCell {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.yearCellClass = true;
    this.rangeCellClass = true;
  }
  get inRange() {
    return this.hasRange && this.isInRange(this.date, this.selectedValue);
  }
  get rangeStart() {
    return this.hasRange && this.dateService.isSameYear(this.date, this.selectedValue.start);
  }
  get rangeEnd() {
    return this.hasRange && this.dateService.isSameYear(this.date, this.selectedValue.end);
  }
  get selected() {
    if (this.inRange) {
      return true;
    }
    if (this.selectedValue) {
      return this.dateService.isSameYearSafe(this.date, this.selectedValue.start);
    }
    return false;
  }
  get today() {
    return this.dateService.isSameYear(this.date, this.dateService.today());
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  get year() {
    return this.dateService.getYear(this.date);
  }
  onClick() {
    if (this.disabled) {
      return;
    }
    this.select.emit(this.date);
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.yearEnd(), this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.yearStart(), this.max) > 0;
  }
  yearStart() {
    return this.dateService.getYearStart(this.date);
  }
  yearEnd() {
    return this.dateService.getYearEnd(this.date);
  }
  isInRange(date, {
    start,
    end
  }) {
    if (start && end) {
      const cellYear = this.dateService.getYear(date);
      const startYear = this.dateService.getYear(start);
      const endYear = this.dateService.getYear(end);
      return cellYear >= startYear && cellYear <= endYear;
    }
    return this.dateService.isSameYear(date, start);
  }
};
_NbCalendarRangeYearCellComponent.ɵfac = function NbCalendarRangeYearCellComponent_Factory(t) {
  return new (t || _NbCalendarRangeYearCellComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarRangeYearCellComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarRangeYearCellComponent,
  selectors: [["nb-calendar-range-year-cell"]],
  hostVars: 18,
  hostBindings: function NbCalendarRangeYearCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbCalendarRangeYearCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("in-range", ctx.inRange)("start", ctx.rangeStart)("end", ctx.rangeEnd)("selected", ctx.selected)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge)("year-cell", ctx.yearCellClass)("range-cell", ctx.rangeCellClass);
    }
  },
  inputs: {
    date: "date",
    min: "min",
    max: "max",
    selectedValue: "selectedValue",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 1,
  consts: [[1, "cell-content"]],
  template: function NbCalendarRangeYearCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.year, " ");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarRangeYearCellComponent = _NbCalendarRangeYearCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeYearCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-range-year-cell",
      template: `
    <div class="cell-content">
      {{ year }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    inRange: [{
      type: HostBinding,
      args: ["class.in-range"]
    }],
    rangeStart: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    rangeEnd: [{
      type: HostBinding,
      args: ["class.end"]
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    yearCellClass: [{
      type: HostBinding,
      args: ["class.year-cell"]
    }],
    rangeCellClass: [{
      type: HostBinding,
      args: ["class.range-cell"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbCalendarRangeMonthCellComponent = class _NbCalendarRangeMonthCellComponent extends NbBaseCalendarRangeCell {
  get month() {
    return this.dateService.getMonthName(this.date);
  }
  get selected() {
    if (this.inRange) {
      return true;
    }
    if (this.selectedValue) {
      return this.dateService.isSameMonthSafe(this.date, this.selectedValue.start);
    }
    return false;
  }
  get inRange() {
    if (this.hasRange) {
      return this.isInRage(this.date, this.selectedValue);
    }
    return false;
  }
  get rangeStart() {
    if (this.hasRange) {
      return this.dateService.isSameMonth(this.date, this.selectedValue.start);
    }
    return false;
  }
  get rangeEnd() {
    if (this.hasRange) {
      return this.dateService.isSameMonth(this.date, this.selectedValue.end);
    }
    return false;
  }
  get today() {
    return this.dateService.isSameMonthSafe(this.date, this.dateService.today());
  }
  get disabled() {
    return this.smallerThanMin() || this.greaterThanMax();
  }
  get isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
  onClick() {
    if (this.disabled) {
      return;
    }
    this.select.emit(this.date);
  }
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.size = NbCalendarSize.MEDIUM;
    this.select = new EventEmitter(true);
    this.monthCellClass = true;
    this.rangeCellClass = true;
  }
  smallerThanMin() {
    return this.date && this.min && this.dateService.compareDates(this.monthEnd(), this.min) < 0;
  }
  greaterThanMax() {
    return this.date && this.max && this.dateService.compareDates(this.monthStart(), this.max) > 0;
  }
  monthStart() {
    return this.dateService.getMonthStart(this.date);
  }
  monthEnd() {
    return this.dateService.getMonthEnd(this.date);
  }
  isInRage(date, range2) {
    if (range2.start && range2.end) {
      const cellDate = this.dateService.getMonthStart(date);
      const start = this.dateService.getMonthStart(range2.start);
      const end = this.dateService.getMonthStart(range2.end);
      const isGreaterThanStart = this.dateService.compareDates(cellDate, start) >= 0;
      const isLessThanEnd = this.dateService.compareDates(cellDate, end) <= 0;
      return isGreaterThanStart && isLessThanEnd;
    }
    return this.dateService.isSameMonth(date, range2.start);
  }
};
_NbCalendarRangeMonthCellComponent.ɵfac = function NbCalendarRangeMonthCellComponent_Factory(t) {
  return new (t || _NbCalendarRangeMonthCellComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarRangeMonthCellComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarRangeMonthCellComponent,
  selectors: [["nb-calendar-range-month-cell"]],
  hostVars: 18,
  hostBindings: function NbCalendarRangeMonthCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbCalendarRangeMonthCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("month-cell", ctx.monthCellClass)("range-cell", ctx.rangeCellClass)("selected", ctx.selected)("in-range", ctx.inRange)("start", ctx.rangeStart)("end", ctx.rangeEnd)("today", ctx.today)("disabled", ctx.disabled)("size-large", ctx.isLarge);
    }
  },
  inputs: {
    date: "date",
    visibleDate: "visibleDate",
    selectedValue: "selectedValue",
    min: "min",
    max: "max",
    size: "size"
  },
  outputs: {
    select: "select"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 1,
  consts: [[1, "cell-content"]],
  template: function NbCalendarRangeMonthCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.month, " ");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbCalendarRangeMonthCellComponent = _NbCalendarRangeMonthCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeMonthCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-range-month-cell",
      template: `
    <div class="cell-content">
      {{ month }}
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbDateService
  }], {
    date: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    selectedValue: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    monthCellClass: [{
      type: HostBinding,
      args: ["class.month-cell"]
    }],
    rangeCellClass: [{
      type: HostBinding,
      args: ["class.range-cell"]
    }],
    selected: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    inRange: [{
      type: HostBinding,
      args: ["class.in-range"]
    }],
    rangeStart: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    rangeEnd: [{
      type: HostBinding,
      args: ["class.end"]
    }],
    today: [{
      type: HostBinding,
      args: ["class.today"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.disabled"]
    }],
    isLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbCalendarRangeComponent = class _NbCalendarRangeComponent {
  /**
   * Custom day cell component. Have to implement `NbCalendarCell` interface.
   * */
  set _cellComponent(cellComponent) {
    if (cellComponent) {
      this.dayCellComponent = cellComponent;
    }
  }
  /**
   * Custom month cell component. Have to implement `NbCalendarCell` interface.
   * */
  set _monthCellComponent(cellComponent) {
    if (cellComponent) {
      this.monthCellComponent = cellComponent;
    }
  }
  /**
   * Custom year cell component. Have to implement `NbCalendarCell` interface.
   * */
  set _yearCellComponent(cellComponent) {
    if (cellComponent) {
      this.yearCellComponent = cellComponent;
    }
  }
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
  constructor(dateService) {
    this.dateService = dateService;
    this.boundingMonth = true;
    this.startView = NbCalendarViewMode.DATE;
    this.dayCellComponent = NbCalendarRangeDayCellComponent;
    this.monthCellComponent = NbCalendarRangeMonthCellComponent;
    this.yearCellComponent = NbCalendarRangeYearCellComponent;
    this.size = NbCalendarSize.MEDIUM;
    this.showNavigation = true;
    this._showWeekNumber = false;
    this.weekNumberSymbol = "#";
    this.rangeChange = new EventEmitter();
  }
  onChange(date) {
    this.initDateIfNull();
    this.handleSelected(date);
  }
  initDateIfNull() {
    if (!this.range) {
      this.range = {
        start: null,
        end: null
      };
    }
  }
  handleSelected(date) {
    if (this.selectionStarted()) {
      this.selectEnd(date);
    } else {
      this.selectStart(date);
    }
  }
  selectionStarted() {
    const {
      start,
      end
    } = this.range;
    return start && !end;
  }
  selectStart(start) {
    this.selectRange({
      start
    });
  }
  selectEnd(date) {
    const {
      start
    } = this.range;
    if (this.dateService.compareDates(date, start) > 0) {
      this.selectRange({
        start,
        end: date
      });
    } else {
      this.selectRange({
        start: date,
        end: start
      });
    }
  }
  selectRange(range2) {
    this.range = range2;
    this.rangeChange.emit(range2);
  }
};
_NbCalendarRangeComponent.ɵfac = function NbCalendarRangeComponent_Factory(t) {
  return new (t || _NbCalendarRangeComponent)(ɵɵdirectiveInject(NbDateService));
};
_NbCalendarRangeComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarRangeComponent,
  selectors: [["nb-calendar-range"]],
  inputs: {
    boundingMonth: "boundingMonth",
    startView: "startView",
    min: "min",
    max: "max",
    filter: "filter",
    _cellComponent: [InputFlags.None, "dayCellComponent", "_cellComponent"],
    _monthCellComponent: [InputFlags.None, "monthCellComponent", "_monthCellComponent"],
    monthCellComponent: "monthCellComponent",
    _yearCellComponent: [InputFlags.None, "yearCellComponent", "_yearCellComponent"],
    size: "size",
    visibleDate: "visibleDate",
    showNavigation: "showNavigation",
    range: "range",
    showWeekNumber: "showWeekNumber",
    weekNumberSymbol: "weekNumberSymbol",
    firstDayOfWeek: "firstDayOfWeek"
  },
  outputs: {
    rangeChange: "rangeChange"
  },
  decls: 1,
  vars: 15,
  consts: [[3, "date", "min", "max", "filter", "startView", "boundingMonth", "dayCellComponent", "monthCellComponent", "yearCellComponent", "visibleDate", "showNavigation", "size", "showWeekNumber", "weekNumberSymbol", "firstDayOfWeek", "dateChange"]],
  template: function NbCalendarRangeComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nb-base-calendar", 0);
      ɵɵlistener("dateChange", function NbCalendarRangeComponent_Template_nb_base_calendar_dateChange_0_listener($event) {
        return ctx.onChange($event);
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("date", ctx.range)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("startView", ctx.startView)("boundingMonth", ctx.boundingMonth)("dayCellComponent", ctx.dayCellComponent)("monthCellComponent", ctx.monthCellComponent)("yearCellComponent", ctx.yearCellComponent)("visibleDate", ctx.visibleDate)("showNavigation", ctx.showNavigation)("size", ctx.size)("showWeekNumber", ctx.showWeekNumber)("weekNumberSymbol", ctx.weekNumberSymbol)("firstDayOfWeek", ctx.firstDayOfWeek);
    }
  },
  dependencies: [NbBaseCalendarComponent],
  encapsulation: 2
});
var NbCalendarRangeComponent = _NbCalendarRangeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-range",
      template: `
    <nb-base-calendar
      [date]="range"
      (dateChange)="onChange($any($event))"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [startView]="startView"
      [boundingMonth]="boundingMonth"
      [dayCellComponent]="dayCellComponent"
      [monthCellComponent]="monthCellComponent"
      [yearCellComponent]="yearCellComponent"
      [visibleDate]="visibleDate"
      [showNavigation]="showNavigation"
      [size]="size"
      [showWeekNumber]="showWeekNumber"
      [weekNumberSymbol]="weekNumberSymbol"
      [firstDayOfWeek]="firstDayOfWeek"
    ></nb-base-calendar>
  `
    }]
  }], () => [{
    type: NbDateService
  }], {
    boundingMonth: [{
      type: Input
    }],
    startView: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    _cellComponent: [{
      type: Input,
      args: ["dayCellComponent"]
    }],
    _monthCellComponent: [{
      type: Input,
      args: ["monthCellComponent"]
    }],
    monthCellComponent: [{
      type: Input
    }],
    _yearCellComponent: [{
      type: Input,
      args: ["yearCellComponent"]
    }],
    size: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    showNavigation: [{
      type: Input
    }],
    range: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    rangeChange: [{
      type: Output
    }]
  });
})();
var _NbCalendarRangeModule = class _NbCalendarRangeModule {
};
_NbCalendarRangeModule.ɵfac = function NbCalendarRangeModule_Factory(t) {
  return new (t || _NbCalendarRangeModule)();
};
_NbCalendarRangeModule.ɵmod = ɵɵdefineNgModule({
  type: _NbCalendarRangeModule,
  declarations: [NbCalendarRangeComponent, NbCalendarRangeDayCellComponent, NbCalendarRangeYearCellComponent, NbCalendarRangeMonthCellComponent],
  imports: [NbBaseCalendarModule],
  exports: [NbCalendarRangeComponent]
});
_NbCalendarRangeModule.ɵinj = ɵɵdefineInjector({
  imports: [NbBaseCalendarModule]
});
var NbCalendarRangeModule = _NbCalendarRangeModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarRangeModule, [{
    type: NgModule,
    args: [{
      imports: [NbBaseCalendarModule],
      exports: [NbCalendarRangeComponent],
      declarations: [NbCalendarRangeComponent, NbCalendarRangeDayCellComponent, NbCalendarRangeYearCellComponent, NbCalendarRangeMonthCellComponent]
    }]
  }], null, null);
})();
var NB_TIME_PICKER_CONFIG = new InjectionToken("NB_TIME_PICKER_CONFIG");
var NB_DEFAULT_TIMEPICKER_LOCALIZATION_CONFIG = {
  hoursText: "Hr",
  minutesText: "Min",
  secondsText: "Sec",
  ampmText: "Am/Pm"
};
var _NbListComponent = class _NbListComponent {
  constructor() {
    this.role = "list";
  }
};
_NbListComponent.ɵfac = function NbListComponent_Factory(t) {
  return new (t || _NbListComponent)();
};
_NbListComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbListComponent,
  selectors: [["nb-list"]],
  hostVars: 1,
  hostBindings: function NbListComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
    }
  },
  inputs: {
    role: "role"
  },
  ngContentSelectors: _c10,
  decls: 1,
  vars: 0,
  template: function NbListComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c9);
      ɵɵprojection(0);
    }
  },
  styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;flex:1 1 auto;overflow:auto}"]
});
var NbListComponent = _NbListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbListComponent, [{
    type: Component,
    args: [{
      selector: "nb-list",
      template: `<ng-content select="nb-list-item"></ng-content>`,
      styles: [":host{display:flex;flex-direction:column;flex:1 1 auto;overflow:auto}\n"]
    }]
  }], null, {
    role: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var _NbListItemComponent = class _NbListItemComponent {
  constructor() {
    this.role = "listitem";
  }
};
_NbListItemComponent.ɵfac = function NbListItemComponent_Factory(t) {
  return new (t || _NbListItemComponent)();
};
_NbListItemComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbListItemComponent,
  selectors: [["nb-list-item"]],
  hostVars: 1,
  hostBindings: function NbListItemComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
    }
  },
  inputs: {
    role: "role"
  },
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function NbListItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  styles: ["[_nghost-%COMP%]{display:flex;align-items:center;flex-shrink:0}"]
});
var NbListItemComponent = _NbListItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbListItemComponent, [{
    type: Component,
    args: [{
      selector: "nb-list-item",
      template: `<ng-content></ng-content>`,
      styles: [":host{display:flex;align-items:center;flex-shrink:0}\n"]
    }]
  }], null, {
    role: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var _NbTimePickerCellComponent = class _NbTimePickerCellComponent {
  set selected(selected) {
    if (selected) {
      this._selected = selected;
      this.scrollToElement();
    }
    this.selectedChange$.next(selected);
  }
  get selected() {
    return this._selected;
  }
  constructor(ngZone, platformService) {
    this.ngZone = ngZone;
    this.platformService = platformService;
    this.selectedChange$ = new Subject();
    this.unselected$ = this.selectedChange$.pipe(filter((selected) => !selected));
    this.destroy$ = new Subject();
    this.select = new EventEmitter();
  }
  onClick() {
    this.select.emit({
      value: this.value
    });
  }
  ngAfterViewInit() {
    if (this.selected) {
      this.ngZone.onStable.pipe(take(1), takeUntil(merge(this.unselected$, this.destroy$))).subscribe(() => this.scrollToElement());
    }
  }
  scrollToElement() {
    if (this.valueContainerElement && this.platformService.isBrowser) {
      this.ngZone.runOutsideAngular(() => this.valueContainerElement.nativeElement.scrollIntoView({
        block: "center"
      }));
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NbTimePickerCellComponent.ɵfac = function NbTimePickerCellComponent_Factory(t) {
  return new (t || _NbTimePickerCellComponent)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbPlatform));
};
_NbTimePickerCellComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTimePickerCellComponent,
  selectors: [["nb-timepicker-cell"]],
  viewQuery: function NbTimePickerCellComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c11, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.valueContainerElement = _t.first);
    }
  },
  hostBindings: function NbTimePickerCellComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbTimePickerCellComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
  },
  inputs: {
    selected: "selected",
    value: "value"
  },
  outputs: {
    select: "select"
  },
  decls: 3,
  vars: 1,
  consts: [["valueContainer", ""]],
  template: function NbTimePickerCellComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", null, 0);
      ɵɵtext(2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵtextInterpolate(ctx.value);
    }
  },
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{width:100%;height:100%;display:flex;align-items:center;justify-content:center;-webkit-user-select:none;user-select:none}"],
  changeDetection: 0
});
var NbTimePickerCellComponent = _NbTimePickerCellComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTimePickerCellComponent, [{
    type: Component,
    args: [{
      selector: "nb-timepicker-cell",
      template: `
    <div #valueContainer>{{ value }}</div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{width:100%;height:100%;display:flex;align-items:center;justify-content:center;-webkit-user-select:none;user-select:none}\n"]
    }]
  }], () => [{
    type: NgZone
  }, {
    type: NbPlatform
  }], {
    selected: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    select: [{
      type: Output
    }],
    valueContainerElement: [{
      type: ViewChild,
      args: ["valueContainer"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbTimePickerComponent = class _NbTimePickerComponent {
  /**
   * Emits when timepicker looses focus.
   */
  get blur() {
    return this.blur$.asObservable();
  }
  /**
   * Defines time format string.
   * */
  get timeFormat() {
    return this._timeFormat;
  }
  set timeFormat(timeFormat) {
    this._timeFormat = timeFormat;
  }
  /**
   * Defines 12 hours format .
   * */
  get twelveHoursFormat() {
    return this._twelveHoursFormat;
  }
  set twelveHoursFormat(value) {
    this._twelveHoursFormat = convertToBoolProperty(value);
  }
  /**
   * Defines should show am/pm label if twelveHoursFormat enabled.
   * */
  get showAmPmLabel() {
    return this._showAmPmLabel;
  }
  set showAmPmLabel(value) {
    this._showAmPmLabel = convertToBoolProperty(value);
  }
  /**
   * Show seconds in timepicker.
   * Ignored when singleColumn is true
   * */
  get withSeconds() {
    return this._withSeconds;
  }
  set withSeconds(value) {
    this._withSeconds = convertToBoolProperty(value);
  }
  /**
   * Show timepicker values in one column with 60 minutes step by default.
   * */
  get singleColumn() {
    return this._singleColumn;
  }
  set singleColumn(value) {
    this._singleColumn = convertToBoolProperty(value);
  }
  /**
   * Defines minutes offset for options, when timepicker is in single column mode.
   * By default it’s 60 minutes: '12:00, 13:00: 14:00, 15:00...'
   * */
  set step(step) {
    this._step = step;
  }
  get step() {
    return this._step;
  }
  /**
   * Date which will be rendered as selected.
   * */
  set date(date) {
    this._date = date;
    this.isAM = this.dateService.getDayPeriod(this.date) === "AM";
    this.buildColumnOptions();
    this.cd.markForCheck();
  }
  get date() {
    return this._date;
  }
  constructor(config, platformService, locale, cd, calendarTimeModelService, dateService) {
    this.config = config;
    this.platformService = platformService;
    this.cd = cd;
    this.calendarTimeModelService = calendarTimeModelService;
    this.dateService = dateService;
    this.blur$ = new Subject();
    this.dayPeriodColumnOptions = [
      "AM",
      "PM"
      /* NbDayPeriod.PM */
    ];
    this.isAM = true;
    this.timepickerFormatChange$ = new Subject();
    this.computedTimeFormat = this.setupTimeFormat();
    this._showAmPmLabel = true;
    this.showFooter = true;
    this.onSelectTime = new EventEmitter();
    this.initFromConfig(this.config);
  }
  ngOnChanges({
    step,
    twelveHoursFormat,
    withSeconds,
    singleColumn
  }) {
    const nextTimeFormat = this.setupTimeFormat();
    if (nextTimeFormat !== this.computedTimeFormat) {
      this.computedTimeFormat = nextTimeFormat;
      this.timepickerFormatChange$.next();
    }
    const isConfigChanged = step || twelveHoursFormat || withSeconds || singleColumn;
    if (isConfigChanged || !this.fullTimeOptions) {
      this.buildColumnOptions();
    }
  }
  setHost(hostRef) {
    this.hostRef = hostRef;
  }
  attach(hostRef) {
    this.hostRef = hostRef;
  }
  setCurrentTime() {
    this.date = this.dateService.today();
    this.onSelectTime.emit({
      time: this.date,
      save: true
    });
  }
  setHour(value) {
    this.updateValue(this.dateService.setHours(this.date, value));
  }
  setMinute(value) {
    this.updateValue(this.dateService.setMinutes(this.date, value));
  }
  setSecond(value) {
    this.updateValue(this.dateService.setSeconds(this.date, value));
  }
  selectFullTime(value) {
    this.updateValue(value);
  }
  changeDayPeriod(dayPeriodToSet) {
    if (this.dateService.getDayPeriod(this.date) === dayPeriodToSet) {
      return;
    }
    const direction = dayPeriodToSet === "AM" ? -1 : 1;
    const increment = direction * this.dateService.HOURS_IN_DAY_PERIOD;
    this.updateValue(this.dateService.addHours(this.date, increment));
  }
  updateValue(date) {
    this.onSelectTime.emit({
      time: date
    });
  }
  saveValue() {
    this.onSelectTime.emit({
      time: this.date,
      save: true
    });
  }
  trackByTimeValues(index, item) {
    return item.value;
  }
  trackBySingleColumnValue(index, item) {
    return this.dateService.valueOf(item);
  }
  trackByDayPeriod(index, item) {
    return item;
  }
  showSeconds() {
    return this.withSeconds && !this.singleColumn;
  }
  isSelectedHour(val) {
    if (this.date) {
      return this.dateService.getHours(this.date) === val;
    }
    return false;
  }
  isSelectedMinute(val) {
    if (this.date) {
      return this.dateService.getMinutes(this.date) === val;
    }
    return false;
  }
  isSelectedSecond(val) {
    if (this.date) {
      return this.dateService.getSeconds(this.date) === val;
    }
    return false;
  }
  isSelectedDayPeriod(dayPeriod) {
    if (this.date) {
      return dayPeriod === this.dateService.getDayPeriod(this.date);
    }
    return false;
  }
  getFullTimeString(item) {
    return this.dateService.format(item, this.computedTimeFormat).toUpperCase();
  }
  isSelectedFullTimeValue(value) {
    if (this.date) {
      return this.dateService.isSameHourAndMinute(value, this.date);
    }
    return false;
  }
  buildColumnOptions() {
    this.fullTimeOptions = this.singleColumn ? this.calendarTimeModelService.getHoursRange(this.step) : [];
    this.hoursColumnOptions = this.generateHours();
    this.minutesColumnOptions = this.generateMinutesOrSeconds();
    this.secondsColumnOptions = this.showSeconds() ? this.generateMinutesOrSeconds() : [];
  }
  /**
   * @docs-private
   */
  isFirefox() {
    return this.platformService.FIREFOX;
  }
  generateHours() {
    if (!this.twelveHoursFormat) {
      return range(24, (v) => {
        return {
          value: v,
          text: this.calendarTimeModelService.paddToTwoSymbols(v)
        };
      });
    }
    if (this.isAM) {
      return range(12, (v) => {
        const text = v === 0 ? 12 : v;
        return {
          value: v,
          text: this.calendarTimeModelService.paddToTwoSymbols(text)
        };
      });
    }
    return rangeFromTo(12, 24, (v) => {
      const text = v === 12 ? 12 : v - 12;
      return {
        value: v,
        text: this.calendarTimeModelService.paddToTwoSymbols(text)
      };
    });
  }
  generateMinutesOrSeconds() {
    return range(60, (v) => {
      return {
        value: v,
        text: this.calendarTimeModelService.paddToTwoSymbols(v)
      };
    });
  }
  setupTimeFormat() {
    if (!this.timeFormat) {
      return this.config.format || this.buildTimeFormat();
    }
    return this.timeFormat;
  }
  /**
   * @docs-private
   */
  buildTimeFormat() {
    if (this.twelveHoursFormat) {
      return `${this.withSeconds && !this.singleColumn ? this.dateService.getTwelveHoursFormatWithSeconds() : this.dateService.getTwelveHoursFormat()}`;
    } else {
      return `${this.withSeconds && !this.singleColumn ? this.dateService.getTwentyFourHoursFormatWithSeconds() : this.dateService.getTwentyFourHoursFormat()}`;
    }
  }
  initFromConfig(config) {
    if (config) {
      this.twelveHoursFormat = config.twelveHoursFormat;
    } else {
      this.twelveHoursFormat = this.dateService.getLocaleTimeFormat().includes("h");
    }
    const localeConfig = __spreadValues(__spreadValues({}, NB_DEFAULT_TIMEPICKER_LOCALIZATION_CONFIG), config?.localization ?? {});
    this.hoursText = localeConfig.hoursText;
    this.minutesText = localeConfig.minutesText;
    this.secondsText = localeConfig.secondsText;
    this.ampmText = localeConfig.ampmText;
  }
};
_NbTimePickerComponent.ɵfac = function NbTimePickerComponent_Factory(t) {
  return new (t || _NbTimePickerComponent)(ɵɵdirectiveInject(NB_TIME_PICKER_CONFIG), ɵɵdirectiveInject(NbPlatform), ɵɵdirectiveInject(LOCALE_ID), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbCalendarTimeModelService), ɵɵdirectiveInject(NbDateService));
};
_NbTimePickerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTimePickerComponent,
  selectors: [["nb-timepicker"]],
  viewQuery: function NbTimePickerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbPortalDirective, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portal = _t.first);
    }
  },
  inputs: {
    timeFormat: "timeFormat",
    twelveHoursFormat: "twelveHoursFormat",
    showAmPmLabel: "showAmPmLabel",
    withSeconds: "withSeconds",
    singleColumn: "singleColumn",
    step: "step",
    date: "date",
    showFooter: "showFooter",
    applyButtonText: "applyButtonText",
    hoursText: "hoursText",
    minutesText: "minutesText",
    secondsText: "secondsText",
    ampmText: "ampmText",
    currentTimeButtonText: "currentTimeButtonText"
  },
  outputs: {
    onSelectTime: "onSelectTime"
  },
  exportAs: ["nbTimepicker"],
  features: [ɵɵNgOnChangesFeature],
  decls: 1,
  vars: 0,
  consts: [["class", "nb-timepicker-container", 3, "supports-scrollbar-theming", 4, "nbPortal"], [1, "nb-timepicker-container"], [1, "column-header"], [4, "ngIf", "ngIfElse"], ["fullTimeHeadersBlock", ""], [1, "picker-body"], ["fullTimeColumnBlock", ""], ["class", "actions-footer", 4, "ngIf"], [1, "header-cell"], ["class", "header-cell", 4, "ngIf"], [3, "ngIf"], [1, "values-list"], ["class", "list-item", 3, "selected", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "list-item"], [3, "value", "selected", "select"], ["class", "values-list", 4, "ngIf"], ["class", "list-item am-pm-item", 3, "selected", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "list-item", "am-pm-item"], [1, "actions-footer"], [3, "applyButtonText", "currentTimeButtonText", "setCurrentTime", "saveValue"]],
  template: function NbTimePickerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbTimePickerComponent_nb_card_0_Template, 10, 7, "nb-card", 0);
    }
  },
  dependencies: [NgForOf, NgIf, NbPortalDirective, NbListComponent, NbListItemComponent, NbCardComponent, NbCardFooterComponent, NbCardHeaderComponent, NbCalendarActionsComponent, NbTimePickerCellComponent],
  styles: ["\n\n\n\n\n.nb-timepicker-container[_ngcontent-%COMP%]{overflow:hidden;margin-bottom:0}.values-list[_ngcontent-%COMP%]{width:100%;overflow:hidden;scroll-snap-type:y proximity}.values-list[_ngcontent-%COMP%]:hover{overflow-y:auto}.list-item[_ngcontent-%COMP%]{border:0;padding:0;cursor:pointer}.picker-body[_ngcontent-%COMP%]{display:flex;width:100%;flex:1 0 0;overflow:hidden}.column-header[_ngcontent-%COMP%]{width:100%;display:flex;justify-content:space-between;padding:0}.header-cell[_ngcontent-%COMP%]{width:100%;display:flex;align-items:center;justify-content:center}.actions-footer[_ngcontent-%COMP%]{width:100%}nb-card-header[_ngcontent-%COMP%], nb-card-footer[_ngcontent-%COMP%]{flex:0 0 auto}"],
  changeDetection: 0
});
var NbTimePickerComponent = _NbTimePickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTimePickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-timepicker",
      exportAs: "nbTimepicker",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<nb-card *nbPortal [class.supports-scrollbar-theming]="!isFirefox()" class="nb-timepicker-container">\n  <nb-card-header class="column-header">\n    <ng-container *ngIf="singleColumn; else fullTimeHeadersBlock">\n      <div class="header-cell">Time</div>\n    </ng-container>\n    <ng-template #fullTimeHeadersBlock>\n      <div class="header-cell">{{ hoursText }}</div>\n      <div class="header-cell">{{ minutesText }}</div>\n      <div *ngIf="withSeconds" class="header-cell">{{ secondsText }}</div>\n      <div *ngIf="twelveHoursFormat" class="header-cell">\n        <ng-template [ngIf]="showAmPmLabel">{{ ampmText }}</ng-template>\n      </div>\n    </ng-template>\n  </nb-card-header>\n\n  <div class="picker-body">\n    <ng-container *ngIf="singleColumn; else fullTimeColumnBlock">\n      <nb-list class="values-list">\n        <nb-list-item\n          class="list-item"\n          [class.selected]="isSelectedFullTimeValue(item)"\n          *ngFor="let item of fullTimeOptions; trackBy: trackBySingleColumnValue.bind(this)"\n        >\n          <nb-timepicker-cell\n            [value]="getFullTimeString(item)"\n            [selected]="isSelectedFullTimeValue(item)"\n            (select)="selectFullTime(item)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n    </ng-container>\n\n    <ng-template #fullTimeColumnBlock>\n      <nb-list class="values-list">\n        <nb-list-item\n          class="list-item"\n          [class.selected]="isSelectedHour(item.value)"\n          *ngFor="let item of hoursColumnOptions; trackBy: trackByTimeValues"\n        >\n          <nb-timepicker-cell\n            [value]="item.text"\n            [selected]="isSelectedHour(item.value)"\n            (select)="setHour(item.value)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n      <nb-list class="values-list">\n        <nb-list-item\n          class="list-item"\n          [class.selected]="isSelectedMinute(item.value)"\n          *ngFor="let item of minutesColumnOptions; trackBy: trackByTimeValues"\n        >\n          <nb-timepicker-cell\n            [value]="item.text"\n            [selected]="isSelectedMinute(item.value)"\n            (select)="setMinute(item.value)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n      <nb-list *ngIf="showSeconds()" class="values-list">\n        <nb-list-item\n          class="list-item"\n          [class.selected]="isSelectedSecond(item.value)"\n          *ngFor="let item of secondsColumnOptions; trackBy: trackByTimeValues"\n        >\n          <nb-timepicker-cell\n            [value]="item.text"\n            [selected]="isSelectedSecond(item.value)"\n            (select)="setSecond(item.value)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n      <nb-list *ngIf="twelveHoursFormat" class="values-list">\n        <nb-list-item\n          class="list-item am-pm-item"\n          [class.selected]="isSelectedDayPeriod(dayPeriod)"\n          *ngFor="let dayPeriod of dayPeriodColumnOptions; trackBy: trackByDayPeriod"\n        >\n          <nb-timepicker-cell\n            [value]="dayPeriod"\n            [selected]="isSelectedDayPeriod(dayPeriod)"\n            (select)="changeDayPeriod(dayPeriod)"\n          >\n          </nb-timepicker-cell>\n        </nb-list-item>\n      </nb-list>\n    </ng-template>\n  </div>\n\n  <nb-card-footer *ngIf="showFooter" class="actions-footer">\n    <nb-calendar-actions\n      [applyButtonText]="applyButtonText"\n      [currentTimeButtonText]="currentTimeButtonText"\n      (setCurrentTime)="setCurrentTime()"\n      (saveValue)="saveValue()"\n    ></nb-calendar-actions>\n  </nb-card-footer>\n</nb-card>\n',
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */.nb-timepicker-container{overflow:hidden;margin-bottom:0}.values-list{width:100%;overflow:hidden;scroll-snap-type:y proximity}.values-list:hover{overflow-y:auto}.list-item{border:0;padding:0;cursor:pointer}.picker-body{display:flex;width:100%;flex:1 0 0;overflow:hidden}.column-header{width:100%;display:flex;justify-content:space-between;padding:0}.header-cell{width:100%;display:flex;align-items:center;justify-content:center}.actions-footer{width:100%}nb-card-header,nb-card-footer{flex:0 0 auto}\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TIME_PICKER_CONFIG]
    }]
  }, {
    type: NbPlatform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [LOCALE_ID]
    }]
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbCalendarTimeModelService
  }, {
    type: NbDateService
  }], {
    timeFormat: [{
      type: Input
    }],
    twelveHoursFormat: [{
      type: Input
    }],
    showAmPmLabel: [{
      type: Input
    }],
    withSeconds: [{
      type: Input
    }],
    singleColumn: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    showFooter: [{
      type: Input
    }],
    applyButtonText: [{
      type: Input
    }],
    hoursText: [{
      type: Input
    }],
    minutesText: [{
      type: Input
    }],
    secondsText: [{
      type: Input
    }],
    ampmText: [{
      type: Input
    }],
    currentTimeButtonText: [{
      type: Input
    }],
    onSelectTime: [{
      type: Output
    }],
    portal: [{
      type: ViewChild,
      args: [NbPortalDirective, {
        static: true
      }]
    }]
  });
})();
var _NbCalendarWithTimeComponent = class _NbCalendarWithTimeComponent extends NbCalendarComponent {
  constructor(dateService, cd, calendarTimeModelService) {
    super();
    this.dateService = dateService;
    this.cd = cd;
    this.calendarTimeModelService = calendarTimeModelService;
  }
  ngOnInit() {
    if (!this.date) {
      this.date = this.calendarTimeModelService.getResetTime();
    }
  }
  ngAfterViewInit() {
    this.portalOutlet.attachTemplatePortal(this.timepicker.portal);
  }
  onDateValueChange(date) {
    const hours = this.dateService.getHours(this.date);
    const minutes = this.dateService.getMinutes(this.date);
    const seconds = this.dateService.getSeconds(this.date);
    const milliseconds = this.dateService.getMilliseconds(this.date);
    let newDate = this.dateService.setHours(date, hours);
    newDate = this.dateService.setMinutes(newDate, minutes);
    newDate = this.dateService.setMinutes(newDate, minutes);
    newDate = this.dateService.setSeconds(newDate, seconds);
    newDate = this.dateService.setMilliseconds(newDate, milliseconds);
    this.date = newDate;
  }
  onTimeChange(selectedTime) {
    let newDate = this.dateService.clone(this.date);
    newDate = this.dateService.setHours(newDate, this.dateService.getHours(selectedTime.time));
    newDate = this.dateService.setMinutes(newDate, this.dateService.getMinutes(selectedTime.time));
    newDate = this.dateService.setSeconds(newDate, this.dateService.getSeconds(selectedTime.time));
    newDate = this.dateService.setMilliseconds(newDate, this.dateService.getMilliseconds(selectedTime.time));
    this.date = newDate;
  }
  saveValue() {
    this.dateChange.emit(this.date);
  }
  saveCurrentTime() {
    this.dateChange.emit(this.dateService.today());
  }
  showSeconds() {
    return this.withSeconds && !this.singleColumn;
  }
  isLarge() {
    return this.size === NbCalendarSize.LARGE;
  }
};
_NbCalendarWithTimeComponent.ɵfac = function NbCalendarWithTimeComponent_Factory(t) {
  return new (t || _NbCalendarWithTimeComponent)(ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbCalendarTimeModelService));
};
_NbCalendarWithTimeComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCalendarWithTimeComponent,
  selectors: [["nb-calendar-with-time"]],
  viewQuery: function NbCalendarWithTimeComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbPortalOutletDirective, 5);
      ɵɵviewQuery(NbTimePickerComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.timepicker = _t.first);
    }
  },
  inputs: {
    visibleDate: "visibleDate",
    twelveHoursFormat: "twelveHoursFormat",
    showAmPmLabel: "showAmPmLabel",
    withSeconds: "withSeconds",
    singleColumn: "singleColumn",
    step: "step",
    timeFormat: "timeFormat",
    title: "title",
    applyButtonText: "applyButtonText",
    currentTimeButtonText: "currentTimeButtonText",
    showCurrentTimeButton: "showCurrentTimeButton"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 10,
  vars: 32,
  consts: [[1, "calendar-with-time"], [1, "picker-body"], [3, "boundingMonth", "startView", "date", "min", "max", "filter", "dayCellComponent", "monthCellComponent", "yearCellComponent", "size", "visibleDate", "showNavigation", "showWeekNumber", "weekNumberSymbol", "firstDayOfWeek", "dateChange"], [1, "timepicker-section"], [1, "picker-title"], [3, "date", "twelveHoursFormat", "showAmPmLabel", "withSeconds", "showFooter", "singleColumn", "step", "onSelectTime"], ["nbPortalOutlet", ""], [1, "picker-footer"], [3, "applyButtonText", "currentTimeButtonText", "showCurrentTimeButton", "setCurrentTime", "saveValue"]],
  template: function NbCalendarWithTimeComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nb-card", 0)(1, "nb-card-body", 1)(2, "nb-base-calendar", 2);
      ɵɵlistener("dateChange", function NbCalendarWithTimeComponent_Template_nb_base_calendar_dateChange_2_listener($event) {
        return ctx.onDateValueChange($event);
      });
      ɵɵelementEnd();
      ɵɵelementStart(3, "div", 3)(4, "div", 4);
      ɵɵtext(5);
      ɵɵelementEnd();
      ɵɵelementStart(6, "nb-timepicker", 5);
      ɵɵlistener("onSelectTime", function NbCalendarWithTimeComponent_Template_nb_timepicker_onSelectTime_6_listener($event) {
        return ctx.onTimeChange($event);
      });
      ɵɵelementEnd();
      ɵɵelementContainer(7, 6);
      ɵɵelementEnd()();
      ɵɵelementStart(8, "nb-card-footer", 7)(9, "nb-calendar-actions", 8);
      ɵɵlistener("setCurrentTime", function NbCalendarWithTimeComponent_Template_nb_calendar_actions_setCurrentTime_9_listener() {
        return ctx.saveCurrentTime();
      })("saveValue", function NbCalendarWithTimeComponent_Template_nb_calendar_actions_saveValue_9_listener() {
        return ctx.saveValue();
      });
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("boundingMonth", ctx.boundingMonth)("startView", ctx.startView)("date", ctx.date)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("dayCellComponent", ctx.dayCellComponent)("monthCellComponent", ctx.monthCellComponent)("yearCellComponent", ctx.yearCellComponent)("size", ctx.size)("visibleDate", ctx.visibleDate)("showNavigation", ctx.showNavigation)("showWeekNumber", ctx.showWeekNumber)("weekNumberSymbol", ctx.weekNumberSymbol)("firstDayOfWeek", ctx.firstDayOfWeek);
      ɵɵadvance();
      ɵɵclassProp("size-large", ctx.isLarge())("timepicker-single-column-width", ctx.singleColumn)("timepicker-multiple-column-width", !ctx.singleColumn);
      ɵɵadvance(2);
      ɵɵtextInterpolate(ctx.title);
      ɵɵadvance();
      ɵɵproperty("date", ctx.date)("twelveHoursFormat", ctx.twelveHoursFormat)("showAmPmLabel", ctx.showAmPmLabel)("withSeconds", ctx.showSeconds())("showFooter", false)("singleColumn", ctx.singleColumn)("step", ctx.step);
      ɵɵadvance(3);
      ɵɵproperty("applyButtonText", ctx.applyButtonText)("currentTimeButtonText", ctx.currentTimeButtonText)("showCurrentTimeButton", ctx.showCurrentTimeButton);
    }
  },
  dependencies: [NbPortalOutletDirective, NbCardComponent, NbCardBodyComponent, NbCardFooterComponent, NbBaseCalendarComponent, NbTimePickerComponent, NbCalendarActionsComponent],
  styles: ["\n\n\n\n\n\n\n\n\n\n[_nghost-%COMP%]     nb-card.nb-timepicker-container{flex:1 0 0;border-radius:0;width:auto;border-right:0;border-bottom:0}[dir=ltr]   [_nghost-%COMP%]   .picker-footer[_ngcontent-%COMP%]{padding-left:.625rem}[dir=rtl]   [_nghost-%COMP%]   .picker-footer[_ngcontent-%COMP%]{padding-right:.625rem}.picker-body[_ngcontent-%COMP%]{align-items:stretch;display:flex;padding:0}.picker-body[_ngcontent-%COMP%]   nb-base-calendar[_ngcontent-%COMP%]     nb-card{border-radius:0}.calendar-with-time[_ngcontent-%COMP%]{overflow:hidden}.timepicker-section[_ngcontent-%COMP%]{display:flex;flex-direction:column}"],
  changeDetection: 0
});
var NbCalendarWithTimeComponent = _NbCalendarWithTimeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCalendarWithTimeComponent, [{
    type: Component,
    args: [{
      selector: "nb-calendar-with-time",
      template: `
    <nb-card class="calendar-with-time">
      <nb-card-body class="picker-body">
        <nb-base-calendar
          [boundingMonth]="boundingMonth"
          [startView]="startView"
          [date]="date"
          [min]="min"
          [max]="max"
          [filter]="filter"
          [dayCellComponent]="dayCellComponent"
          [monthCellComponent]="monthCellComponent"
          [yearCellComponent]="yearCellComponent"
          [size]="size"
          [visibleDate]="visibleDate"
          [showNavigation]="showNavigation"
          [showWeekNumber]="showWeekNumber"
          [weekNumberSymbol]="weekNumberSymbol"
          [firstDayOfWeek]="firstDayOfWeek"
          (dateChange)="onDateValueChange($event)"
        >
        </nb-base-calendar>
        <div
          class="timepicker-section"
          [class.size-large]="isLarge()"
          [class.timepicker-single-column-width]="singleColumn"
          [class.timepicker-multiple-column-width]="!singleColumn"
        >
          <div class="picker-title">{{ title }}</div>
          <nb-timepicker
            (onSelectTime)="onTimeChange($event)"
            [date]="date"
            [twelveHoursFormat]="twelveHoursFormat"
            [showAmPmLabel]="showAmPmLabel"
            [withSeconds]="showSeconds()"
            [showFooter]="false"
            [singleColumn]="singleColumn"
            [step]="step"
          >
          </nb-timepicker>
          <ng-container nbPortalOutlet></ng-container>
        </div>
      </nb-card-body>
      <nb-card-footer class="picker-footer">
        <nb-calendar-actions
          [applyButtonText]="applyButtonText"
          [currentTimeButtonText]="currentTimeButtonText"
          [showCurrentTimeButton]="showCurrentTimeButton"
          (setCurrentTime)="saveCurrentTime()"
          (saveValue)="saveValue()"
        ></nb-calendar-actions>
      </nb-card-footer>
    </nb-card>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n*//**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host ::ng-deep nb-card.nb-timepicker-container{flex:1 0 0;border-radius:0;width:auto;border-right:0;border-bottom:0}[dir=ltr] :host .picker-footer{padding-left:.625rem}[dir=rtl] :host .picker-footer{padding-right:.625rem}.picker-body{align-items:stretch;display:flex;padding:0}.picker-body nb-base-calendar ::ng-deep nb-card{border-radius:0}.calendar-with-time{overflow:hidden}.timepicker-section{display:flex;flex-direction:column}\n"]
    }]
  }], () => [{
    type: NbDateService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbCalendarTimeModelService
  }], {
    visibleDate: [{
      type: Input
    }],
    twelveHoursFormat: [{
      type: Input
    }],
    showAmPmLabel: [{
      type: Input
    }],
    withSeconds: [{
      type: Input
    }],
    singleColumn: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    timeFormat: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    applyButtonText: [{
      type: Input
    }],
    currentTimeButtonText: [{
      type: Input
    }],
    showCurrentTimeButton: [{
      type: Input
    }],
    portalOutlet: [{
      type: ViewChild,
      args: [NbPortalOutletDirective]
    }],
    timepicker: [{
      type: ViewChild,
      args: [NbTimePickerComponent]
    }]
  });
})();
var _NbDatepickerContainerComponent = class _NbDatepickerContainerComponent extends NbPositionedContainerComponent {
  attach(portal) {
    return this.overlayContainer.attachComponentPortal(portal);
  }
};
_NbDatepickerContainerComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbDatepickerContainerComponent_BaseFactory;
  return function NbDatepickerContainerComponent_Factory(t) {
    return (ɵNbDatepickerContainerComponent_BaseFactory || (ɵNbDatepickerContainerComponent_BaseFactory = ɵɵgetInheritedFactory(_NbDatepickerContainerComponent)))(t || _NbDatepickerContainerComponent);
  };
})();
_NbDatepickerContainerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbDatepickerContainerComponent,
  selectors: [["nb-datepicker-container"]],
  viewQuery: function NbDatepickerContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbOverlayContainerComponent, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.overlayContainer = _t.first);
    }
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 1,
  vars: 0,
  template: function NbDatepickerContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "nb-overlay-container");
    }
  },
  dependencies: [NbOverlayContainerComponent],
  encapsulation: 2
});
var NbDatepickerContainerComponent = _NbDatepickerContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDatepickerContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-datepicker-container",
      template: `
    <nb-overlay-container></nb-overlay-container>
  `
    }]
  }], null, {
    overlayContainer: [{
      type: ViewChild,
      args: [NbOverlayContainerComponent, {
        static: true
      }]
    }]
  });
})();
var NbDatepickerAdapter = class {
};
var NbDatepicker = class {
};
var NB_DATE_ADAPTER = new InjectionToken("Datepicker Adapter");
var NB_DATE_SERVICE_OPTIONS = new InjectionToken("Date service options");
var _NbDatepickerDirective = class _NbDatepickerDirective {
  /**
   * Provides datepicker component.
   * */
  // eslint-disable-next-line @angular-eslint/no-input-rename
  set setPicker(picker) {
    this.picker = picker;
    this.setupPicker();
  }
  constructor(document, datepickerAdapters, hostRef, dateService, changeDetector) {
    this.document = document;
    this.datepickerAdapters = datepickerAdapters;
    this.hostRef = hostRef;
    this.dateService = dateService;
    this.changeDetector = changeDetector;
    this.destroy$ = new Subject();
    this.isDatepickerReady = false;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.validator = Validators.compose([this.parseValidator, this.minValidator, this.maxValidator, this.filterValidator].map((fn) => fn.bind(this)));
    this.subscribeOnInputChange();
  }
  /**
   * Returns html input element.
   * */
  get input() {
    return this.hostRef.nativeElement;
  }
  /**
   * Returns host input value.
   * */
  get inputValue() {
    return this.input.value;
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  /**
   * Writes value in picker and html input element.
   * */
  writeValue(value) {
    if (this.isDatepickerReady) {
      this.writePicker(value);
      this.writeInput(value);
    } else {
      this.queue = value;
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.input.disabled = isDisabled;
  }
  /**
   * Form control validation based on picker validator config.
   * */
  validate() {
    return this.validator(null);
  }
  /**
   * Hides picker, focuses the input
   */
  hidePicker() {
    this.input.focus();
    this.picker.hide();
  }
  /**
   * Validates that we can parse value correctly.
   * */
  parseValidator() {
    if (this.inputValue === "") {
      return null;
    }
    const isValid = this.datepickerAdapter.isValid(this.inputValue, this.picker.format);
    return isValid ? null : {
      nbDatepickerParse: {
        value: this.inputValue
      }
    };
  }
  /**
   * Validates passed value is greater than min.
   * */
  minValidator() {
    const config = this.picker.getValidatorConfig();
    const date = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
    return !config.min || !date || this.dateService.compareDates(config.min, date) <= 0 ? null : {
      nbDatepickerMin: {
        min: config.min,
        actual: date
      }
    };
  }
  /**
   * Validates passed value is smaller than max.
   * */
  maxValidator() {
    const config = this.picker.getValidatorConfig();
    const date = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
    return !config.max || !date || this.dateService.compareDates(config.max, date) >= 0 ? null : {
      nbDatepickerMax: {
        max: config.max,
        actual: date
      }
    };
  }
  /**
   * Validates passed value satisfy the filter.
   * */
  filterValidator() {
    const config = this.picker.getValidatorConfig();
    const date = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
    return !config.filter || !date || config.filter(date) ? null : {
      nbDatepickerFilter: true
    };
  }
  /**
   * Chooses datepicker adapter based on passed picker component.
   * */
  chooseDatepickerAdapter() {
    this.datepickerAdapter = this.datepickerAdapters.find(({
      picker
    }) => this.picker instanceof picker);
    if (this.noDatepickerAdapterProvided()) {
      throw new Error("No datepickerAdapter provided for picker");
    }
  }
  /**
   * Attaches picker to the host input element and subscribes on value changes.
   * */
  setupPicker() {
    this.chooseDatepickerAdapter();
    this.picker.attach(this.hostRef);
    if (this.inputValue) {
      this.picker.value = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
    }
    this.pickerInputsChangedSubscription?.unsubscribe();
    this.pickerInputsChangedSubscription = this.picker.formatChanged$.pipe(map(() => this.picker.format), startWith(this.picker.format), distinctUntilChanged(), pairwise(), takeUntil(this.destroy$)).subscribe(([prevFormat, nextFormat]) => {
      if (this.inputValue) {
        const date = this.datepickerAdapter.parse(this.inputValue, prevFormat);
        this.writeInput(date);
      }
    });
    if (!this.isDatepickerReady) {
      this.picker.init.pipe(take(1), tap(() => this.isDatepickerReady = true), filter(() => !!this.queue), takeUntil(this.destroy$)).subscribe(() => {
        this.writeValue(this.queue);
        this.changeDetector.detectChanges();
        this.queue = void 0;
      });
    }
    this.picker.valueChange.pipe(takeUntil(this.destroy$)).subscribe((value) => {
      this.writePicker(value);
      this.writeInput(value);
      this.onChange(value);
      if (this.picker.shouldHide()) {
        this.hidePicker();
      }
    });
    merge(this.picker.blur, fromEvent(this.input, "blur").pipe(filter(() => !this.picker.isShown && this.document.activeElement !== this.input))).pipe(takeUntil(this.destroy$)).subscribe(() => this.onTouched());
  }
  writePicker(value) {
    this.picker.value = value;
  }
  writeInput(value) {
    this.hostRef.nativeElement.value = this.datepickerAdapter.format(value, this.picker.format);
  }
  /**
   * Validates if no datepicker adapter provided.
   * */
  noDatepickerAdapterProvided() {
    return !this.datepickerAdapter || !(this.datepickerAdapter instanceof NbDatepickerAdapter);
  }
  subscribeOnInputChange() {
    fromEvent(this.input, "input").pipe(map(() => this.inputValue), takeUntil(this.destroy$)).subscribe((value) => this.handleInputChange(value));
  }
  /**
   * Parses input value and write if it isn't null.
   * */
  handleInputChange(value) {
    const date = this.parseInputValue(value);
    this.onChange(date);
    this.writePicker(date);
  }
  parseInputValue(value) {
    if (this.datepickerAdapter.isValid(value, this.picker.format)) {
      return this.datepickerAdapter.parse(value, this.picker.format);
    }
    return null;
  }
};
_NbDatepickerDirective.ɵfac = function NbDatepickerDirective_Factory(t) {
  return new (t || _NbDatepickerDirective)(ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NB_DATE_ADAPTER), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbDatepickerDirective.ɵdir = ɵɵdefineDirective({
  type: _NbDatepickerDirective,
  selectors: [["input", "nbDatepicker", ""]],
  inputs: {
    setPicker: [InputFlags.None, "nbDatepicker", "setPicker"]
  },
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbDatepickerDirective),
    multi: true
  }, {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => _NbDatepickerDirective),
    multi: true
  }])]
});
var NbDatepickerDirective = _NbDatepickerDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDatepickerDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbDatepicker]",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbDatepickerDirective),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => NbDatepickerDirective),
        multi: true
      }]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DATE_ADAPTER]
    }]
  }, {
    type: ElementRef
  }, {
    type: NbDateService
  }, {
    type: ChangeDetectorRef
  }], {
    setPicker: [{
      type: Input,
      args: ["nbDatepicker"]
    }]
  });
})();
var NbBasePicker = class extends NbDatepicker {
  constructor(overlay, positionBuilder, triggerStrategyBuilder, cfr, dateService, dateServiceOptions) {
    super();
    this.overlay = overlay;
    this.positionBuilder = positionBuilder;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.cfr = cfr;
    this.dateService = dateService;
    this.dateServiceOptions = dateServiceOptions;
    this.formatChanged$ = new Subject();
    this.init$ = new ReplaySubject();
    this.onChange$ = new Subject();
    this.overlayOffset = 8;
    this.adjustment = NbAdjustment.COUNTERCLOCKWISE;
    this.destroy$ = new Subject();
    this.blur$ = new Subject();
  }
  /**
   * Returns picker instance.
   * */
  get picker() {
    return this.pickerRef && this.pickerRef.instance;
  }
  /**
   * Stream of picker value changes.
   * */
  get valueChange() {
    return this.onChange$.asObservable();
  }
  get isShown() {
    return this.ref && this.ref.hasAttached();
  }
  get init() {
    return this.init$.asObservable();
  }
  /**
   * Emits when datepicker looses focus.
   */
  get blur() {
    return this.blur$.asObservable();
  }
  /**
   * Datepicker knows nothing about host html input element.
   * So, attach method attaches datepicker to the host input element.
   * */
  attach(hostRef) {
    this.hostRef = hostRef;
    this.subscribeOnTriggers();
  }
  getValidatorConfig() {
    return {
      min: this.min,
      max: this.max,
      filter: this.filter
    };
  }
  show() {
    if (!this.ref) {
      this.createOverlay();
    }
    this.openDatepicker();
  }
  shouldHide() {
    return this.hideOnSelect && !!this.value;
  }
  hide() {
    if (this.ref) {
      this.ref.detach();
    }
    if (this.picker) {
      this.queue = this.value;
      this.pickerRef.destroy();
      this.pickerRef = null;
      this.container = null;
    }
  }
  createOverlay() {
    this.positionStrategy = this.createPositionStrategy();
    this.ref = this.overlay.create({
      positionStrategy: this.positionStrategy,
      scrollStrategy: this.overlay.scrollStrategies.reposition()
    });
    this.subscribeOnPositionChange();
  }
  openDatepicker() {
    this.container = this.ref.attach(new NbComponentPortal(NbDatepickerContainerComponent, null, null, this.cfr));
    this.instantiatePicker();
    this.subscribeOnValueChange();
    this.writeQueue();
    this.patchWithInputs();
    this.pickerRef.changeDetectorRef.markForCheck();
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this.hostRef).position(NbPosition.BOTTOM).offset(this.overlayOffset).adjustment(this.adjustment);
  }
  subscribeOnPositionChange() {
    this.positionStrategy.positionChange.pipe(takeUntil(this.destroy$)).subscribe((position) => patch(this.container, {
      position
    }));
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.FOCUS).host(this.hostRef.nativeElement).container(() => this.container).build();
  }
  subscribeOnTriggers() {
    this.triggerStrategy = this.createTriggerStrategy();
    this.triggerStrategy.show$.subscribe(() => this.show());
    this.triggerStrategy.hide$.subscribe(() => {
      this.blur$.next();
      this.hide();
    });
  }
  instantiatePicker() {
    this.pickerRef = this.container.instance.attach(new NbComponentPortal(this.pickerClass, null, null, this.cfr));
  }
  /**
   * Subscribes on picker value changes and emit data through this.onChange$ subject.
   * */
  subscribeOnValueChange() {
    this.pickerValueChange.subscribe((date) => {
      this.onChange$.next(date);
    });
  }
  patchWithInputs() {
    this.picker.boundingMonth = this.boundingMonth;
    this.picker.startView = this.startView;
    this.picker.min = this.min;
    this.picker.max = this.max;
    this.picker.filter = this.filter;
    this.picker._cellComponent = this.dayCellComponent;
    this.picker._monthCellComponent = this.monthCellComponent;
    this.picker._yearCellComponent = this.yearCellComponent;
    this.picker.size = this.size;
    this.picker.showNavigation = this.showNavigation;
    this.picker.visibleDate = this.visibleDate;
    this.picker.showWeekNumber = this.showWeekNumber;
    this.picker.weekNumberSymbol = this.weekNumberSymbol;
    this.picker.firstDayOfWeek = this.firstDayOfWeek;
  }
  checkFormat() {
    if (this.dateService.getId() === "native" && this.format) {
      throw new Error(`Can't format native date. To use custom formatting you have to install @nebular/moment or @nebular/date-fns package and import NbMomentDateModule or NbDateFnsDateModule accordingly.More information at "Formatting issue" https://akveo.github.io/nebular/docs/components/datepicker/overview#nbdatepickercomponent`);
    }
    const isFormatSet = this.format || this.dateServiceOptions && this.dateServiceOptions.format;
    if (this.dateService.getId() === "date-fns" && !isFormatSet) {
      throw new Error("format is required when using NbDateFnsDateModule");
    }
  }
};
var _NbBasePickerComponent = class _NbBasePickerComponent extends NbBasePicker {
  /**
   * Determines should we show week numbers column.
   * False by default.
   * */
  get showWeekNumber() {
    return this._showWeekNumber;
  }
  set showWeekNumber(value) {
    this._showWeekNumber = convertToBoolProperty(value);
  }
  constructor(document, positionBuilder, triggerStrategyBuilder, overlay, cfr, dateService, dateServiceOptions) {
    super(overlay, positionBuilder, triggerStrategyBuilder, cfr, dateService, dateServiceOptions);
    this.boundingMonth = true;
    this.startView = NbCalendarViewMode.DATE;
    this.size = NbCalendarSize.MEDIUM;
    this.hideOnSelect = true;
    this.showNavigation = true;
    this.weekNumberSymbol = "#";
    this._showWeekNumber = false;
    this.overlayOffset = 8;
    this.adjustment = NbAdjustment.COUNTERCLOCKWISE;
  }
  ngOnInit() {
    this.checkFormat();
    this.init$.next();
  }
  ngOnChanges(changes) {
    if (changes.format) {
      if (!changes.format.isFirstChange()) {
        this.checkFormat();
      }
      this.formatChanged$.next();
    }
    if (this.picker) {
      this.patchWithInputs();
    }
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.hide();
    this.init$.complete();
    if (this.ref) {
      this.ref.dispose();
    }
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
  }
  get pickerValueChange() {
    return void 0;
  }
  get value() {
    return void 0;
  }
  set value(value) {
  }
  writeQueue() {
  }
};
_NbBasePickerComponent.ɵfac = function NbBasePickerComponent_Factory(t) {
  return new (t || _NbBasePickerComponent)(ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbPositionBuilderService), ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(NB_DATE_SERVICE_OPTIONS, 8));
};
_NbBasePickerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbBasePickerComponent,
  selectors: [["ng-component"]],
  inputs: {
    format: "format",
    boundingMonth: "boundingMonth",
    startView: "startView",
    min: "min",
    max: "max",
    filter: "filter",
    dayCellComponent: "dayCellComponent",
    monthCellComponent: "monthCellComponent",
    yearCellComponent: "yearCellComponent",
    size: "size",
    visibleDate: "visibleDate",
    hideOnSelect: "hideOnSelect",
    showNavigation: "showNavigation",
    weekNumberSymbol: "weekNumberSymbol",
    showWeekNumber: "showWeekNumber",
    firstDayOfWeek: "firstDayOfWeek",
    overlayOffset: "overlayOffset",
    adjustment: "adjustment"
  },
  features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
  decls: 0,
  vars: 0,
  template: function NbBasePickerComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
var NbBasePickerComponent = _NbBasePickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBasePickerComponent, [{
    type: Component,
    args: [{
      template: ""
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbOverlayService
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: NbDateService
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_DATE_SERVICE_OPTIONS]
    }]
  }], {
    format: [{
      type: Input
    }],
    boundingMonth: [{
      type: Input
    }],
    startView: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    dayCellComponent: [{
      type: Input
    }],
    monthCellComponent: [{
      type: Input
    }],
    yearCellComponent: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    visibleDate: [{
      type: Input
    }],
    hideOnSelect: [{
      type: Input
    }],
    showNavigation: [{
      type: Input
    }],
    weekNumberSymbol: [{
      type: Input
    }],
    showWeekNumber: [{
      type: Input
    }],
    firstDayOfWeek: [{
      type: Input
    }],
    overlayOffset: [{
      type: Input
    }],
    adjustment: [{
      type: Input
    }]
  });
})();
var _NbDatepickerComponent = class _NbDatepickerComponent extends NbBasePickerComponent {
  constructor() {
    super(...arguments);
    this.pickerClass = NbCalendarComponent;
  }
  /**
   * Date which will be rendered as selected.
   * */
  set date(date) {
    this.value = date;
  }
  /**
   * Emits date when selected.
   * */
  get dateChange() {
    return this.valueChange;
  }
  get value() {
    return this.picker ? this.picker.date : void 0;
  }
  set value(date) {
    if (!this.picker) {
      this.queue = date;
      return;
    }
    if (date) {
      this.visibleDate = date;
      this.picker.visibleDate = date;
      this.picker.date = date;
    }
  }
  get pickerValueChange() {
    return this.picker.dateChange;
  }
  writeQueue() {
    if (this.queue) {
      const date = this.queue;
      this.queue = null;
      this.value = date;
    }
  }
};
_NbDatepickerComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbDatepickerComponent_BaseFactory;
  return function NbDatepickerComponent_Factory(t) {
    return (ɵNbDatepickerComponent_BaseFactory || (ɵNbDatepickerComponent_BaseFactory = ɵɵgetInheritedFactory(_NbDatepickerComponent)))(t || _NbDatepickerComponent);
  };
})();
_NbDatepickerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbDatepickerComponent,
  selectors: [["nb-datepicker"]],
  inputs: {
    date: "date"
  },
  outputs: {
    dateChange: "dateChange"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NbDatepickerComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
var NbDatepickerComponent = _NbDatepickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDatepickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-datepicker",
      template: ""
    }]
  }], null, {
    date: [{
      type: Input
    }],
    dateChange: [{
      type: Output
    }]
  });
})();
var _NbRangepickerComponent = class _NbRangepickerComponent extends NbBasePickerComponent {
  constructor() {
    super(...arguments);
    this.pickerClass = NbCalendarRangeComponent;
  }
  /**
   * Range which will be rendered as selected.
   * */
  set range(range2) {
    this.value = range2;
  }
  /**
   * Emits range when start selected and emits again when end selected.
   * */
  get rangeChange() {
    return this.valueChange;
  }
  get value() {
    return this.picker ? this.picker.range : void 0;
  }
  set value(range2) {
    if (!this.picker) {
      this.queue = range2;
      return;
    }
    if (range2) {
      const visibleDate = range2 && range2.start;
      this.visibleDate = visibleDate;
      this.picker.visibleDate = visibleDate;
      this.picker.range = range2;
    }
  }
  get pickerValueChange() {
    return this.picker.rangeChange;
  }
  shouldHide() {
    return super.shouldHide() && !!(this.value && this.value.start && this.value.end);
  }
  writeQueue() {
    if (this.queue) {
      const range2 = this.queue;
      this.queue = null;
      this.value = range2;
    }
  }
};
_NbRangepickerComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbRangepickerComponent_BaseFactory;
  return function NbRangepickerComponent_Factory(t) {
    return (ɵNbRangepickerComponent_BaseFactory || (ɵNbRangepickerComponent_BaseFactory = ɵɵgetInheritedFactory(_NbRangepickerComponent)))(t || _NbRangepickerComponent);
  };
})();
_NbRangepickerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbRangepickerComponent,
  selectors: [["nb-rangepicker"]],
  inputs: {
    range: "range"
  },
  outputs: {
    rangeChange: "rangeChange"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NbRangepickerComponent_Template(rf, ctx) {
  },
  encapsulation: 2
});
var NbRangepickerComponent = _NbRangepickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRangepickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-rangepicker",
      template: ""
    }]
  }], null, {
    range: [{
      type: Input
    }],
    rangeChange: [{
      type: Output
    }]
  });
})();
var _NbDateTimePickerComponent = class _NbDateTimePickerComponent extends NbBasePickerComponent {
  get value() {
    return this.picker ? this.picker.date : void 0;
  }
  set value(date) {
    if (!this.picker) {
      this.queue = date;
      return;
    }
    if (date) {
      this.visibleDate = date;
      this.picker.visibleDate = date;
      this.picker.date = date;
      this.picker.cd.markForCheck();
    }
  }
  /**
   * Defines 12 hours format like '07:00 PM'.
   * */
  get twelveHoursFormat() {
    return this._twelveHoursFormat;
  }
  set twelveHoursFormat(value) {
    this._twelveHoursFormat = convertToBoolProperty(value);
  }
  /**
   * Defines should show am/pm label if twelveHoursFormat enabled.
   * */
  get showAmPmLabel() {
    return this._showAmPmLabel;
  }
  set showAmPmLabel(value) {
    this._showAmPmLabel = convertToBoolProperty(value);
  }
  /**
   * Show seconds in timepicker.
   * Ignored when singleColumn is true.
   * */
  get withSeconds() {
    return this._withSeconds;
  }
  set withSeconds(value) {
    this._withSeconds = convertToBoolProperty(value);
  }
  /**
   * Show timepicker values in one column with 60 minutes step by default.
   * */
  get singleColumn() {
    return this._singleColumn;
  }
  set singleColumn(value) {
    this._singleColumn = convertToBoolProperty(value);
  }
  /**
   * Emits date with time when selected.
   * */
  get dateTimeChange() {
    return this.valueChange;
  }
  constructor(document, positionBuilder, triggerStrategyBuilder, overlay, cfr, dateService, dateServiceOptions, calendarWithTimeModelService) {
    super(document, positionBuilder, triggerStrategyBuilder, overlay, cfr, dateService, dateServiceOptions);
    this.calendarWithTimeModelService = calendarWithTimeModelService;
    this.pickerClass = NbCalendarWithTimeComponent;
    this.showCurrentTimeButton = true;
    this._showAmPmLabel = true;
  }
  ngOnInit() {
    this.format = this.format || this.buildTimeFormat();
    this.init$.next();
  }
  patchWithInputs() {
    this.picker.singleColumn = this.singleColumn;
    this.picker.twelveHoursFormat = this.twelveHoursFormat;
    this.picker.showAmPmLabel = this.showAmPmLabel;
    this.picker.withSeconds = this.withSeconds;
    this.picker.step = this.step;
    this.picker.title = this.title;
    this.picker.applyButtonText = this.applyButtonText;
    this.picker.currentTimeButtonText = this.currentTimeButtonText;
    this.picker.showCurrentTimeButton = this.showCurrentTimeButton;
    if (this.twelveHoursFormat) {
      this.picker.timeFormat = this.dateService.getTwelveHoursFormat();
    } else {
      this.picker.timeFormat = this.withSeconds && !this.singleColumn ? this.dateService.getTwentyFourHoursFormatWithSeconds() : this.dateService.getTwentyFourHoursFormat();
    }
    super.patchWithInputs();
    this.picker.cd.markForCheck();
  }
  get pickerValueChange() {
    return this.picker.dateChange;
  }
  writeQueue() {
    if (this.queue) {
      const date = this.queue;
      this.queue = null;
      this.value = date;
    }
  }
  buildTimeFormat() {
    if (this.singleColumn) {
      return this.calendarWithTimeModelService.buildDateFormat(this.twelveHoursFormat);
    } else {
      return this.calendarWithTimeModelService.buildDateFormat(this.twelveHoursFormat, this.withSeconds);
    }
  }
};
_NbDateTimePickerComponent.ɵfac = function NbDateTimePickerComponent_Factory(t) {
  return new (t || _NbDateTimePickerComponent)(ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbPositionBuilderService), ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(NB_DATE_SERVICE_OPTIONS, 8), ɵɵdirectiveInject(NbCalendarTimeModelService));
};
_NbDateTimePickerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbDateTimePickerComponent,
  selectors: [["nb-date-timepicker"]],
  inputs: {
    step: "step",
    title: "title",
    applyButtonText: "applyButtonText",
    currentTimeButtonText: "currentTimeButtonText",
    showCurrentTimeButton: "showCurrentTimeButton",
    twelveHoursFormat: "twelveHoursFormat",
    showAmPmLabel: "showAmPmLabel",
    withSeconds: "withSeconds",
    singleColumn: "singleColumn"
  },
  outputs: {
    dateTimeChange: "dateTimeChange"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NbDateTimePickerComponent_Template(rf, ctx) {
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbDateTimePickerComponent = _NbDateTimePickerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDateTimePickerComponent, [{
    type: Component,
    args: [{
      selector: "nb-date-timepicker",
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbOverlayService
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: NbDateService
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_DATE_SERVICE_OPTIONS]
    }]
  }, {
    type: NbCalendarTimeModelService
  }], {
    step: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    applyButtonText: [{
      type: Input
    }],
    currentTimeButtonText: [{
      type: Input
    }],
    showCurrentTimeButton: [{
      type: Input
    }],
    twelveHoursFormat: [{
      type: Input
    }],
    showAmPmLabel: [{
      type: Input
    }],
    withSeconds: [{
      type: Input
    }],
    singleColumn: [{
      type: Input
    }],
    dateTimeChange: [{
      type: Output
    }]
  });
})();
function isUrlPathEqual(path, link) {
  const locationPath = getPathPartOfUrl(path);
  return link === locationPath;
}
function isUrlPathContain(path, link) {
  const locationPath = getPathPartOfUrl(path);
  const endOfUrlSegmentRegExp = /\/|^$/;
  return locationPath.startsWith(link) && locationPath.slice(link.length).charAt(0).search(endOfUrlSegmentRegExp) !== -1;
}
function getPathPartOfUrl(url) {
  return url.match(/.*?(?=[?;#]|$)/)[0];
}
function getFragmentPartOfUrl(url) {
  const matched = url.match(/#(.+)/);
  return matched ? matched[1] : "";
}
function isFragmentEqual(path, fragment) {
  return getFragmentPartOfUrl(path) === fragment;
}
function isFragmentContain(path, fragment) {
  return getFragmentPartOfUrl(path).includes(fragment);
}
var _NbRestoreScrollTopHelper = class _NbRestoreScrollTopHelper {
  constructor(router) {
    this.router = router;
  }
  shouldRestore() {
    return this.router.events.pipe(startWith(null), filter((event) => event === null || event instanceof NavigationEnd), pairwise(), map(([prev, current]) => this.pageChanged(prev, current)), filter((res) => !!res));
  }
  pageChanged(prev, current) {
    return !prev || getPathPartOfUrl(prev.url) !== getPathPartOfUrl(current.url);
  }
};
_NbRestoreScrollTopHelper.ɵfac = function NbRestoreScrollTopHelper_Factory(t) {
  return new (t || _NbRestoreScrollTopHelper)(ɵɵinject(Router));
};
_NbRestoreScrollTopHelper.ɵprov = ɵɵdefineInjectable({
  token: _NbRestoreScrollTopHelper,
  factory: _NbRestoreScrollTopHelper.ɵfac
});
var NbRestoreScrollTopHelper = _NbRestoreScrollTopHelper;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRestoreScrollTopHelper, [{
    type: Injectable
  }], () => [{
    type: Router
  }], null);
})();
var _NbLayoutComponent = class _NbLayoutComponent {
  /**
   * Defines whether the layout columns will be centered after some width
   * @param {boolean} val
   */
  set center(val) {
    this.centerValue = convertToBoolProperty(val);
  }
  /**
   * Defines whether the layout enters a 'window' mode, when the layout content (including sidebars and fixed header)
   * becomes centered by width with a margin from the top of the screen, like a floating window.
   * Automatically enables `withScroll` mode, as in the window mode scroll must be inside the layout and cannot be on
   * window. (TODO: check this)
   * @param {boolean} val
   */
  set windowMode(val) {
    this.windowModeValue = convertToBoolProperty(val);
    this.withScroll = this.windowModeValue;
  }
  /**
   * Defines whether to move the scrollbars to layout or leave it at the body level.
   * Automatically set to true when `windowMode` is enabled.
   * @param {boolean} val
   */
  set withScroll(val) {
    this.withScrollValue = convertToBoolProperty(val);
    const body = this.document.getElementsByTagName("body")[0];
    if (this.withScrollValue) {
      this.renderer.setStyle(body, "overflow", "hidden");
    } else {
      this.renderer.setStyle(body, "overflow", "initial");
    }
  }
  /**
   * Restores scroll to the top of the page after navigation
   * @param {boolean} val
   */
  set restoreScrollTop(val) {
    this.restoreScrollTopValue = convertToBoolProperty(val);
  }
  constructor(themeService, spinnerService, elementRef, renderer, window2, document, platformId, layoutDirectionService, scrollService, rulerService, scrollTop, overlayContainer) {
    this.themeService = themeService;
    this.spinnerService = spinnerService;
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.window = window2;
    this.document = document;
    this.platformId = platformId;
    this.layoutDirectionService = layoutDirectionService;
    this.scrollService = scrollService;
    this.rulerService = rulerService;
    this.scrollTop = scrollTop;
    this.overlayContainer = overlayContainer;
    this.scrollBlockClass = "nb-global-scrollblock";
    this.isScrollBlocked = false;
    this.centerValue = false;
    this.restoreScrollTopValue = true;
    this.windowModeValue = false;
    this.withScrollValue = false;
    this.withSubheader = false;
    this.afterViewInit$ = new BehaviorSubject(null);
    this.destroy$ = new Subject();
    this.registerAsOverlayContainer();
    this.themeService.onThemeChange().pipe(takeUntil(this.destroy$)).subscribe((theme) => {
      const body = this.document.getElementsByTagName("body")[0];
      if (theme.previous) {
        this.renderer.removeClass(body, `nb-theme-${theme.previous}`);
      }
      this.renderer.addClass(body, `nb-theme-${theme.name}`);
    });
    this.themeService.onAppendLayoutClass().pipe(takeUntil(this.destroy$)).subscribe((className) => {
      this.renderer.addClass(this.elementRef.nativeElement, className);
    });
    this.themeService.onRemoveLayoutClass().pipe(takeUntil(this.destroy$)).subscribe((className) => {
      this.renderer.removeClass(this.elementRef.nativeElement, className);
    });
    this.spinnerService.registerLoader(new Promise((resolve) => {
      this.afterViewInit$.pipe(takeUntil(this.destroy$)).subscribe((_) => resolve());
    }));
    this.spinnerService.load();
    this.rulerService.onGetDimensions().pipe(takeUntil(this.destroy$)).subscribe(({
      listener
    }) => {
      listener.next(this.getDimensions());
      listener.complete();
    });
    this.scrollService.onGetPosition().pipe(takeUntil(this.destroy$)).subscribe(({
      listener
    }) => {
      listener.next(this.getScrollPosition());
      listener.complete();
    });
    this.scrollTop.shouldRestore().pipe(filter(() => this.restoreScrollTopValue), takeUntil(this.destroy$)).subscribe(() => {
      this.scroll(0, 0);
    });
    this.scrollService.onScrollableChange().pipe(filter(() => this.withScrollValue), takeUntil(this.destroy$)).subscribe((scrollable) => {
      if (scrollable) {
        this.enableScroll();
      } else {
        this.blockScroll();
      }
    });
    if (isPlatformBrowser(this.platformId)) {
      this.themeService.changeWindowWidth(this.window.innerWidth);
    }
  }
  ngAfterViewInit() {
    this.layoutDirectionService.onDirectionChange().pipe(takeUntil(this.destroy$)).subscribe((direction) => this.document.dir = direction);
    this.scrollService.onManualScroll().pipe(takeUntil(this.destroy$)).subscribe(({
      x,
      y
    }) => this.scroll(x, y));
    this.afterViewInit$.next(true);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.unregisterAsOverlayContainer();
  }
  onScroll($event) {
    this.scrollService.fireScrollChange($event);
  }
  onResize(event) {
    this.themeService.changeWindowWidth(event.target.innerWidth);
  }
  /**
   * Returns scroll and client height/width
   *
   * Depending on the current scroll mode (`withScroll=true`) returns sizes from the body element
   * or from the `.scrollable-container`
   * @returns {NbLayoutDimensions}
   */
  getDimensions() {
    let clientWidth, clientHeight, scrollWidth, scrollHeight = 0;
    if (this.withScrollValue) {
      const container = this.scrollableContainerRef.nativeElement;
      clientWidth = container.clientWidth;
      clientHeight = container.clientHeight;
      scrollWidth = container.scrollWidth;
      scrollHeight = container.scrollHeight;
    } else {
      const {
        documentElement,
        body
      } = this.document;
      clientWidth = documentElement.clientWidth || body.clientWidth;
      clientHeight = documentElement.clientHeight || body.clientHeight;
      scrollWidth = documentElement.scrollWidth || body.scrollWidth;
      scrollHeight = documentElement.scrollHeight || body.scrollHeight;
    }
    return {
      clientWidth,
      clientHeight,
      scrollWidth,
      scrollHeight
    };
  }
  /**
   * Returns scroll position of current scroll container.
   *
   * If `withScroll` = true, returns scroll position of the `.scrollable-container` element,
   * otherwise - of the scrollable element of the window (which may be different depending of a browser)
   *
   * @returns {NbScrollPosition}
   */
  getScrollPosition() {
    if (!isPlatformBrowser(this.platformId)) {
      return {
        x: 0,
        y: 0
      };
    }
    if (this.withScrollValue) {
      const container = this.scrollableContainerRef.nativeElement;
      return {
        x: container.scrollLeft,
        y: container.scrollTop
      };
    }
    const documentRect = this.document.documentElement.getBoundingClientRect();
    const x = -documentRect.left || this.document.body.scrollLeft || this.window.scrollX || this.document.documentElement.scrollLeft || 0;
    const y = -documentRect.top || this.document.body.scrollTop || this.window.scrollY || this.document.documentElement.scrollTop || 0;
    return {
      x,
      y
    };
  }
  registerAsOverlayContainer() {
    if (this.overlayContainer.setContainer) {
      this.overlayContainer.setContainer(this.elementRef.nativeElement);
    }
  }
  unregisterAsOverlayContainer() {
    if (this.overlayContainer.clearContainer) {
      this.overlayContainer.clearContainer();
    }
  }
  scroll(x = null, y = null) {
    const {
      x: currentX,
      y: currentY
    } = this.getScrollPosition();
    x = x == null ? currentX : x;
    y = y == null ? currentY : y;
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }
    if (this.withScrollValue) {
      const scrollable = this.scrollableContainerRef.nativeElement;
      if (scrollable.scrollTo) {
        scrollable.scrollTo(x, y);
      } else {
        scrollable.scrollLeft = x;
        scrollable.scrollTop = y;
      }
    } else {
      this.window.scrollTo(x, y);
    }
  }
  // TODO: Extract into block scroll strategy
  blockScroll() {
    if (this.isScrollBlocked) {
      return;
    }
    this.isScrollBlocked = true;
    this.renderer.addClass(this.document.documentElement, this.scrollBlockClass);
    const scrollableContainerElement = this.scrollableContainerRef.nativeElement;
    const layoutElement = this.layoutContainerRef.nativeElement;
    const layoutWithScrollWidth = layoutElement.clientWidth;
    this.scrollableContainerOverflowOldValue = scrollableContainerElement.style.overflow;
    scrollableContainerElement.style.overflow = "hidden";
    const layoutWithoutScrollWidth = layoutElement.clientWidth;
    const scrollWidth = layoutWithoutScrollWidth - layoutWithScrollWidth;
    if (!scrollWidth) {
      return;
    }
    this.layoutPaddingOldValue = {
      left: layoutElement.style.paddingLeft,
      right: layoutElement.style.paddingRight
    };
    if (this.layoutDirectionService.isLtr()) {
      layoutElement.style.paddingRight = `${scrollWidth}px`;
    } else {
      layoutElement.style.paddingLeft = `${scrollWidth}px`;
    }
  }
  enableScroll() {
    if (this.isScrollBlocked) {
      this.isScrollBlocked = false;
      this.renderer.removeClass(this.document.documentElement, this.scrollBlockClass);
      this.scrollableContainerRef.nativeElement.style.overflow = this.scrollableContainerOverflowOldValue;
      if (this.layoutPaddingOldValue) {
        const layoutElement = this.layoutContainerRef.nativeElement;
        layoutElement.style.paddingLeft = this.layoutPaddingOldValue.left;
        layoutElement.style.paddingRight = this.layoutPaddingOldValue.right;
        this.layoutPaddingOldValue = null;
      }
    }
  }
};
_NbLayoutComponent.ɵfac = function NbLayoutComponent_Factory(t) {
  return new (t || _NbLayoutComponent)(ɵɵdirectiveInject(NbThemeService), ɵɵdirectiveInject(NbSpinnerService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NB_WINDOW), ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(NbLayoutDirectionService), ɵɵdirectiveInject(NbLayoutScrollService), ɵɵdirectiveInject(NbLayoutRulerService), ɵɵdirectiveInject(NbRestoreScrollTopHelper), ɵɵdirectiveInject(NbOverlayContainerAdapter));
};
_NbLayoutComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbLayoutComponent,
  selectors: [["nb-layout"]],
  viewQuery: function NbLayoutComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c122, 5, ViewContainerRef);
      ɵɵviewQuery(_c13, 7, ElementRef);
      ɵɵviewQuery(_c14, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.veryTopRef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.scrollableContainerRef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.layoutContainerRef = _t.first);
    }
  },
  hostVars: 6,
  hostBindings: function NbLayoutComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("scroll", function NbLayoutComponent_scroll_HostBindingHandler($event) {
        return ctx.onScroll($event);
      }, false, ɵɵresolveWindow)("resize", function NbLayoutComponent_resize_HostBindingHandler($event) {
        return ctx.onResize($event);
      }, false, ɵɵresolveWindow);
    }
    if (rf & 2) {
      ɵɵclassProp("window-mode", ctx.windowModeValue)("with-scroll", ctx.withScrollValue)("with-subheader", ctx.withSubheader);
    }
  },
  inputs: {
    center: "center",
    windowMode: "windowMode",
    withScroll: "withScroll",
    restoreScrollTop: "restoreScrollTop"
  },
  ngContentSelectors: _c16,
  decls: 12,
  vars: 2,
  consts: [[1, "scrollable-container", 3, "scroll"], ["scrollableContainer", ""], [1, "layout"], ["layoutContainer", ""], [1, "layout-container"], [1, "content"], [1, "columns"]],
  template: function NbLayoutComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c15);
      ɵɵelementStart(0, "div", 0, 1);
      ɵɵlistener("scroll", function NbLayoutComponent_Template_div_scroll_0_listener($event) {
        return ctx.onScroll($event);
      });
      ɵɵelementStart(2, "div", 2, 3);
      ɵɵprojection(4);
      ɵɵelementStart(5, "div", 4);
      ɵɵprojection(6, 1);
      ɵɵelementStart(7, "div", 5);
      ɵɵprojection(8, 2);
      ɵɵelementStart(9, "div", 6);
      ɵɵprojection(10, 3);
      ɵɵelementEnd();
      ɵɵprojection(11, 4);
      ɵɵelementEnd()()()();
    }
    if (rf & 2) {
      ɵɵadvance(7);
      ɵɵclassProp("center", ctx.centerValue);
    }
  },
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{-webkit-font-smoothing:antialiased}[dir=ltr]   [_nghost-%COMP%]{text-align:left}[dir=rtl]   [_nghost-%COMP%]{text-align:right}[_nghost-%COMP%]   .layout[_ngcontent-%COMP%]{display:flex;flex-direction:column}[_nghost-%COMP%]     nb-layout-header{display:block}[_nghost-%COMP%]     nb-layout-header nav{align-items:center;justify-content:flex-start;display:flex}[_nghost-%COMP%]     nb-layout-header.fixed{position:fixed;top:0;left:0;right:0;z-index:1040}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row}[dir=ltr]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.left{order:0}[dir=rtl]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.left{order:2}[dir=ltr]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.right{order:2}[dir=rtl]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.right{order:0}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.end{order:2}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar .fixed{position:fixed;width:100%;overflow-y:auto;height:100%}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:column;min-width:0}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content.center[_ngcontent-%COMP%]{max-width:100%;position:relative;margin-left:auto;margin-right:auto}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row;width:100%}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column{order:1;flex:1 0;min-width:0}[dir=ltr]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column.left{order:0}[dir=rtl]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column.left{order:2}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column.start{order:0}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]     nb-layout-footer{display:block;margin-top:auto}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]     nb-layout-footer nav{justify-content:center;display:flex}"]
});
var NbLayoutComponent = _NbLayoutComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutComponent, [{
    type: Component,
    args: [{
      selector: "nb-layout",
      template: `
    <div class="scrollable-container" #scrollableContainer (scroll)="onScroll($event)">
      <div class="layout" #layoutContainer>
        <ng-content select="nb-layout-header:not([subheader])"></ng-content>
        <div class="layout-container">
          <ng-content select="nb-sidebar"></ng-content>
          <div class="content" [class.center]="centerValue">
            <ng-content select="nb-layout-header[subheader]"></ng-content>
            <div class="columns">
              <ng-content select="nb-layout-column"></ng-content>
            </div>
            <ng-content select="nb-layout-footer"></ng-content>
          </div>
        </div>
      </div>
    </div>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{-webkit-font-smoothing:antialiased}[dir=ltr] :host{text-align:left}[dir=rtl] :host{text-align:right}:host .layout{display:flex;flex-direction:column}:host ::ng-deep nb-layout-header{display:block}:host ::ng-deep nb-layout-header nav{align-items:center;justify-content:flex-start;display:flex}:host ::ng-deep nb-layout-header.fixed{position:fixed;top:0;left:0;right:0;z-index:1040}:host .layout-container{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row}[dir=ltr] :host .layout-container ::ng-deep nb-sidebar.left{order:0}[dir=rtl] :host .layout-container ::ng-deep nb-sidebar.left{order:2}[dir=ltr] :host .layout-container ::ng-deep nb-sidebar.right{order:2}[dir=rtl] :host .layout-container ::ng-deep nb-sidebar.right{order:0}:host .layout-container ::ng-deep nb-sidebar.end{order:2}:host .layout-container ::ng-deep nb-sidebar .fixed{position:fixed;width:100%;overflow-y:auto;height:100%}:host .layout-container .content{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:column;min-width:0}:host .layout-container .content.center{max-width:100%;position:relative;margin-left:auto;margin-right:auto}:host .layout-container .content .columns{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row;width:100%}:host .layout-container .content .columns ::ng-deep nb-layout-column{order:1;flex:1 0;min-width:0}[dir=ltr] :host .layout-container .content .columns ::ng-deep nb-layout-column.left{order:0}[dir=rtl] :host .layout-container .content .columns ::ng-deep nb-layout-column.left{order:2}:host .layout-container .content .columns ::ng-deep nb-layout-column.start{order:0}:host .layout-container .content ::ng-deep nb-layout-footer{display:block;margin-top:auto}:host .layout-container .content ::ng-deep nb-layout-footer nav{justify-content:center;display:flex}\n"]
    }]
  }], () => [{
    type: NbThemeService
  }, {
    type: NbSpinnerService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: Object,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: NbLayoutDirectionService
  }, {
    type: NbLayoutScrollService
  }, {
    type: NbLayoutRulerService
  }, {
    type: NbRestoreScrollTopHelper
  }, {
    type: NbOverlayContainerAdapter
  }], {
    windowModeValue: [{
      type: HostBinding,
      args: ["class.window-mode"]
    }],
    withScrollValue: [{
      type: HostBinding,
      args: ["class.with-scroll"]
    }],
    withSubheader: [{
      type: HostBinding,
      args: ["class.with-subheader"]
    }],
    center: [{
      type: Input
    }],
    windowMode: [{
      type: Input
    }],
    withScroll: [{
      type: Input
    }],
    restoreScrollTop: [{
      type: Input
    }],
    veryTopRef: [{
      type: ViewChild,
      args: ["layoutTopDynamicArea", {
        read: ViewContainerRef
      }]
    }],
    scrollableContainerRef: [{
      type: ViewChild,
      args: ["scrollableContainer", {
        read: ElementRef,
        static: true
      }]
    }],
    layoutContainerRef: [{
      type: ViewChild,
      args: ["layoutContainer", {
        read: ElementRef
      }]
    }],
    onScroll: [{
      type: HostListener,
      args: ["window:scroll", ["$event"]]
    }],
    onResize: [{
      type: HostListener,
      args: ["window:resize", ["$event"]]
    }]
  });
})();
var _NbLayoutColumnComponent = class _NbLayoutColumnComponent {
  /**
   * Move the column to the very left position in the layout.
   * @param {boolean} val
   */
  set left(val) {
    this.leftValue = convertToBoolProperty(val);
    this.startValue = false;
  }
  /**
   * Make column first in the layout.
   * @param {boolean} val
   */
  set start(val) {
    this.startValue = convertToBoolProperty(val);
    this.leftValue = false;
  }
};
_NbLayoutColumnComponent.ɵfac = function NbLayoutColumnComponent_Factory(t) {
  return new (t || _NbLayoutColumnComponent)();
};
_NbLayoutColumnComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbLayoutColumnComponent,
  selectors: [["nb-layout-column"]],
  hostVars: 4,
  hostBindings: function NbLayoutColumnComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("left", ctx.leftValue)("start", ctx.startValue);
    }
  },
  inputs: {
    left: "left",
    start: "start"
  },
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function NbLayoutColumnComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
var NbLayoutColumnComponent = _NbLayoutColumnComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutColumnComponent, [{
    type: Component,
    args: [{
      selector: "nb-layout-column",
      template: `<ng-content></ng-content>`
    }]
  }], null, {
    leftValue: [{
      type: HostBinding,
      args: ["class.left"]
    }],
    startValue: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    left: [{
      type: Input
    }],
    start: [{
      type: Input
    }]
  });
})();
var _NbLayoutHeaderComponent = class _NbLayoutHeaderComponent {
  constructor(layout) {
    this.layout = layout;
  }
  /**
   * Makes the header sticky to the top of the nb-layout.
   * @param {boolean} val
   */
  set fixed(val) {
    this.fixedValue = convertToBoolProperty(val);
  }
  /**
   * Places header on a side of the sidebar, and not above.
   * Disables fixed mode for this header and remove a shadow from the sidebar.
   * @param {boolean} val
   */
  set subheader(val) {
    this.subheaderValue = convertToBoolProperty(val);
    this.fixedValue = false;
    this.layout.withSubheader = this.subheaderValue;
  }
};
_NbLayoutHeaderComponent.ɵfac = function NbLayoutHeaderComponent_Factory(t) {
  return new (t || _NbLayoutHeaderComponent)(ɵɵdirectiveInject(NbLayoutComponent));
};
_NbLayoutHeaderComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbLayoutHeaderComponent,
  selectors: [["nb-layout-header"]],
  hostVars: 4,
  hostBindings: function NbLayoutHeaderComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("fixed", ctx.fixedValue)("subheader", ctx.subheaderValue);
    }
  },
  inputs: {
    fixed: "fixed",
    subheader: "subheader"
  },
  ngContentSelectors: _c02,
  decls: 2,
  vars: 2,
  template: function NbLayoutHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "nav");
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("fixed", ctx.fixedValue);
    }
  },
  encapsulation: 2
});
var NbLayoutHeaderComponent = _NbLayoutHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutHeaderComponent, [{
    type: Component,
    args: [{
      selector: "nb-layout-header",
      template: `
    <nav [class.fixed]="fixedValue">
      <ng-content></ng-content>
    </nav>
  `
    }]
  }], () => [{
    type: NbLayoutComponent
  }], {
    fixedValue: [{
      type: HostBinding,
      args: ["class.fixed"]
    }],
    subheaderValue: [{
      type: HostBinding,
      args: ["class.subheader"]
    }],
    fixed: [{
      type: Input
    }],
    subheader: [{
      type: Input
    }]
  });
})();
var _NbLayoutFooterComponent = class _NbLayoutFooterComponent {
  /**
   * Makes the footer sticky to the bottom of the window.
   * @param {boolean} val
   */
  set fixed(val) {
    this.fixedValue = convertToBoolProperty(val);
  }
};
_NbLayoutFooterComponent.ɵfac = function NbLayoutFooterComponent_Factory(t) {
  return new (t || _NbLayoutFooterComponent)();
};
_NbLayoutFooterComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbLayoutFooterComponent,
  selectors: [["nb-layout-footer"]],
  hostVars: 2,
  hostBindings: function NbLayoutFooterComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("fixed", ctx.fixedValue);
    }
  },
  inputs: {
    fixed: "fixed"
  },
  ngContentSelectors: _c02,
  decls: 2,
  vars: 2,
  template: function NbLayoutFooterComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "nav");
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("fixed", ctx.fixedValue);
    }
  },
  encapsulation: 2
});
var NbLayoutFooterComponent = _NbLayoutFooterComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutFooterComponent, [{
    type: Component,
    args: [{
      selector: "nb-layout-footer",
      template: `
    <nav [class.fixed]="fixedValue">
      <ng-content></ng-content>
    </nav>
  `
    }]
  }], null, {
    fixedValue: [{
      type: HostBinding,
      args: ["class.fixed"]
    }],
    fixed: [{
      type: Input
    }]
  });
})();
var _NbBaseLayoutDirectionDirective = class _NbBaseLayoutDirectionDirective {
  constructor(templateRef, viewContainer, cd, directionService, directionToShow) {
    this.templateRef = templateRef;
    this.viewContainer = viewContainer;
    this.cd = cd;
    this.directionService = directionService;
    this.directionToShow = directionToShow;
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.directionService.onDirectionChange().pipe(map((layoutDirection) => layoutDirection === this.directionToShow), distinctUntilChanged(), takeUntil(this.destroy$)).subscribe((shouldShow) => this.updateView(shouldShow));
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  updateView(shouldShow) {
    if (shouldShow && !this.viewContainer.length) {
      this.viewContainer.createEmbeddedView(this.templateRef);
      this.cd.markForCheck();
    } else if (!shouldShow && this.viewContainer.length) {
      this.viewContainer.clear();
    }
  }
};
_NbBaseLayoutDirectionDirective.ɵfac = function NbBaseLayoutDirectionDirective_Factory(t) {
  return new (t || _NbBaseLayoutDirectionDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbLayoutDirectionService), ɵɵdirectiveInject(NbLayoutDirection));
};
_NbBaseLayoutDirectionDirective.ɵdir = ɵɵdefineDirective({
  type: _NbBaseLayoutDirectionDirective
});
var NbBaseLayoutDirectionDirective = _NbBaseLayoutDirectionDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBaseLayoutDirectionDirective, [{
    type: Directive
  }], () => [{
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbLayoutDirectionService
  }, {
    type: NbLayoutDirection
  }], null);
})();
var _NbLtrDirective = class _NbLtrDirective extends NbBaseLayoutDirectionDirective {
  constructor(templateRef, viewContainer, cd, directionService) {
    super(templateRef, viewContainer, cd, directionService, NbLayoutDirection.LTR);
    this.templateRef = templateRef;
    this.viewContainer = viewContainer;
    this.cd = cd;
    this.directionService = directionService;
  }
};
_NbLtrDirective.ɵfac = function NbLtrDirective_Factory(t) {
  return new (t || _NbLtrDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbLayoutDirectionService));
};
_NbLtrDirective.ɵdir = ɵɵdefineDirective({
  type: _NbLtrDirective,
  selectors: [["", "nbLtr", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
var NbLtrDirective = _NbLtrDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLtrDirective, [{
    type: Directive,
    args: [{
      selector: "[nbLtr]"
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbLayoutDirectionService
  }], null);
})();
var _NbRtlDirective = class _NbRtlDirective extends NbBaseLayoutDirectionDirective {
  constructor(templateRef, viewContainer, cd, directionService) {
    super(templateRef, viewContainer, cd, directionService, NbLayoutDirection.RTL);
    this.templateRef = templateRef;
    this.viewContainer = viewContainer;
    this.cd = cd;
    this.directionService = directionService;
  }
};
_NbRtlDirective.ɵfac = function NbRtlDirective_Factory(t) {
  return new (t || _NbRtlDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbLayoutDirectionService));
};
_NbRtlDirective.ɵdir = ɵɵdefineDirective({
  type: _NbRtlDirective,
  selectors: [["", "nbRtl", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
var NbRtlDirective = _NbRtlDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRtlDirective, [{
    type: Directive,
    args: [{
      selector: "[nbRtl]"
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: ViewContainerRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbLayoutDirectionService
  }], null);
})();
var NB_LAYOUT_COMPONENTS = [NbLayoutComponent, NbLayoutColumnComponent, NbLayoutFooterComponent, NbLayoutHeaderComponent];
var NB_LAYOUT_DIRECTIVES = [NbLtrDirective, NbRtlDirective];
var _NbLayoutModule = class _NbLayoutModule {
};
_NbLayoutModule.ɵfac = function NbLayoutModule_Factory(t) {
  return new (t || _NbLayoutModule)();
};
_NbLayoutModule.ɵmod = ɵɵdefineNgModule({
  type: _NbLayoutModule,
  declarations: [NbLayoutComponent, NbLayoutColumnComponent, NbLayoutFooterComponent, NbLayoutHeaderComponent, NbLtrDirective, NbRtlDirective],
  imports: [NbSharedModule],
  exports: [NbLayoutComponent, NbLayoutColumnComponent, NbLayoutFooterComponent, NbLayoutHeaderComponent, NbLtrDirective, NbRtlDirective]
});
_NbLayoutModule.ɵinj = ɵɵdefineInjector({
  providers: [NbRestoreScrollTopHelper],
  imports: [NbSharedModule]
});
var NbLayoutModule = _NbLayoutModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbLayoutModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [...NB_LAYOUT_COMPONENTS, ...NB_LAYOUT_DIRECTIVES],
      providers: [NbRestoreScrollTopHelper],
      exports: [...NB_LAYOUT_COMPONENTS, ...NB_LAYOUT_DIRECTIVES]
    }]
  }], null, null);
})();
var itemClick$ = new Subject();
var addItems$ = new ReplaySubject(1);
var navigateHome$ = new ReplaySubject(1);
var getSelectedItem$ = new ReplaySubject(1);
var itemSelect$ = new ReplaySubject(1);
var itemHover$ = new ReplaySubject(1);
var submenuToggle$ = new ReplaySubject(1);
var collapseAll$ = new ReplaySubject(1);
var NbMenuItem = class {
  constructor() {
    this.pathMatch = "full";
  }
  /**
   * @returns item parents in top-down order
   */
  static getParents(item) {
    const parents = [];
    let parent = item.parent;
    while (parent) {
      parents.unshift(parent);
      parent = parent.parent;
    }
    return parents;
  }
  static isParent(item, possibleChild) {
    return possibleChild.parent ? possibleChild.parent === item || this.isParent(item, possibleChild.parent) : false;
  }
};
var _NbMenuService = class _NbMenuService {
  /**
   * Add items to the end of the menu items list
   * @param {List<NbMenuItem>} items
   * @param {string} tag
   */
  addItems(items, tag) {
    addItems$.next({
      tag,
      items
    });
  }
  /**
   * Collapses all menu items
   * @param {string} tag
   */
  collapseAll(tag) {
    collapseAll$.next({
      tag
    });
  }
  /**
   * Navigate to the home menu item
   * @param {string} tag
   */
  navigateHome(tag) {
    navigateHome$.next({
      tag
    });
  }
  /**
   * Returns currently selected item. Won't subscribe to the future events.
   * @param {string} tag
   * @returns {Observable<{tag: string; item: NbMenuItem}>}
   */
  getSelectedItem(tag) {
    const listener = new BehaviorSubject(null);
    getSelectedItem$.next({
      tag,
      listener
    });
    return listener.asObservable();
  }
  onItemClick() {
    return itemClick$.pipe(share());
  }
  onItemSelect() {
    return itemSelect$.pipe(share());
  }
  onItemHover() {
    return itemHover$.pipe(share());
  }
  onSubmenuToggle() {
    return submenuToggle$.pipe(share());
  }
};
_NbMenuService.ɵfac = function NbMenuService_Factory(t) {
  return new (t || _NbMenuService)();
};
_NbMenuService.ɵprov = ɵɵdefineInjectable({
  token: _NbMenuService,
  factory: _NbMenuService.ɵfac
});
var NbMenuService = _NbMenuService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuService, [{
    type: Injectable
  }], null, null);
})();
var _NbMenuInternalService = class _NbMenuInternalService {
  constructor(location) {
    this.location = location;
  }
  prepareItems(items) {
    const defaultItem = new NbMenuItem();
    items.forEach((i) => {
      this.applyDefaults(i, defaultItem);
      this.setParent(i);
    });
  }
  selectFromUrl(items, tag, collapseOther = false) {
    const selectedItem = this.findItemByUrl(items);
    if (selectedItem) {
      this.selectItem(selectedItem, items, collapseOther, tag);
    }
  }
  selectItem(item, items, collapseOther = false, tag) {
    const unselectedItems = this.resetSelection(items);
    const collapsedItems = collapseOther ? this.collapseItems(items) : [];
    for (const parent of NbMenuItem.getParents(item)) {
      parent.selected = true;
      if (!unselectedItems.includes(parent)) {
        this.itemSelect(parent, tag);
      }
      const wasNotExpanded = !parent.expanded;
      parent.expanded = true;
      const i = collapsedItems.indexOf(parent);
      if (i === -1 && wasNotExpanded) {
        this.submenuToggle(parent, tag);
      } else {
        collapsedItems.splice(i, 1);
      }
    }
    item.selected = true;
    if (!unselectedItems.includes(item)) {
      this.itemSelect(item, tag);
    }
    for (const collapsedItem of collapsedItems) {
      this.submenuToggle(collapsedItem, tag);
    }
  }
  collapseAll(items, tag, except) {
    const collapsedItems = this.collapseItems(items, except);
    for (const item of collapsedItems) {
      this.submenuToggle(item, tag);
    }
  }
  onAddItem() {
    return addItems$.pipe(share());
  }
  onNavigateHome() {
    return navigateHome$.pipe(share());
  }
  onCollapseAll() {
    return collapseAll$.pipe(share());
  }
  onGetSelectedItem() {
    return getSelectedItem$.pipe(share());
  }
  itemHover(item, tag) {
    itemHover$.next({
      tag,
      item
    });
  }
  submenuToggle(item, tag) {
    submenuToggle$.next({
      tag,
      item
    });
  }
  itemSelect(item, tag) {
    itemSelect$.next({
      tag,
      item
    });
  }
  itemClick(item, tag) {
    itemClick$.next({
      tag,
      item
    });
  }
  /**
   * Unselect all given items deeply.
   * @param items array of items to unselect.
   * @returns items which selected value was changed.
   */
  resetSelection(items) {
    const unselectedItems = [];
    for (const item of items) {
      if (item.selected) {
        unselectedItems.push(item);
      }
      item.selected = false;
      if (item.children) {
        unselectedItems.push(...this.resetSelection(item.children));
      }
    }
    return unselectedItems;
  }
  /**
   * Collapse all given items deeply.
   * @param items array of items to collapse.
   * @param except menu item which shouldn't be collapsed, also disables collapsing for parents of this item.
   * @returns items which expanded value was changed.
   */
  collapseItems(items, except) {
    const collapsedItems = [];
    for (const item of items) {
      if (except && (item === except || NbMenuItem.isParent(item, except))) {
        continue;
      }
      if (item.expanded) {
        collapsedItems.push(item);
      }
      item.expanded = false;
      if (item.children) {
        collapsedItems.push(...this.collapseItems(item.children));
      }
    }
    return collapsedItems;
  }
  applyDefaults(item, defaultItem) {
    const menuItem = __spreadValues({}, item);
    Object.assign(item, defaultItem, menuItem);
    item.children && item.children.forEach((child) => {
      this.applyDefaults(child, defaultItem);
    });
  }
  setParent(item) {
    item.children && item.children.forEach((child) => {
      child.parent = item;
      this.setParent(child);
    });
  }
  /**
   * Find deepest item which link matches current URL path.
   * @param items array of items to search in.
   * @returns found item of undefined.
   */
  findItemByUrl(items) {
    let selectedItem;
    items.some((item) => {
      if (item.children) {
        selectedItem = this.findItemByUrl(item.children);
      }
      if (!selectedItem && this.isSelectedInUrl(item)) {
        selectedItem = item;
      }
      return selectedItem;
    });
    return selectedItem;
  }
  isSelectedInUrl(item) {
    const exact = item.pathMatch === "full";
    const link = item.link;
    const isSelectedInPath = exact ? isUrlPathEqual(this.location.path(), link) : isUrlPathContain(this.location.path(), link);
    if (isSelectedInPath && item.fragment != null) {
      return exact ? isFragmentEqual(this.location.path(true), item.fragment) : isFragmentContain(this.location.path(true), item.fragment);
    }
    return isSelectedInPath;
  }
};
_NbMenuInternalService.ɵfac = function NbMenuInternalService_Factory(t) {
  return new (t || _NbMenuInternalService)(ɵɵinject(Location));
};
_NbMenuInternalService.ɵprov = ɵɵdefineInjectable({
  token: _NbMenuInternalService,
  factory: _NbMenuInternalService.ɵfac
});
var NbMenuInternalService = _NbMenuInternalService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuInternalService, [{
    type: Injectable
  }], () => [{
    type: Location
  }], null);
})();
var _NbBadgeComponent = class _NbBadgeComponent {
  /**
   * Badge position
   *
   * Can be set to any class or to one of predefined positions:
   * 'top left', 'top right', 'bottom left', 'bottom right',
   * 'top start', 'top end', 'bottom start', 'bottom end'
   * @type string
   */
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value || this._defaultPosition;
  }
  /**
   * Shows badge as a dot. No text is shown.
   * @type boolean
   */
  get dotMode() {
    return this._dotMode;
  }
  set dotMode(value) {
    this._dotMode = convertToBoolProperty(value);
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get top() {
    return this.position.includes("top");
  }
  get right() {
    return this.position.includes("right");
  }
  get bottom() {
    return this.position.includes("bottom");
  }
  get left() {
    return this.position.includes("left");
  }
  get start() {
    return this.position.includes("start");
  }
  get end() {
    return this.position.includes("end");
  }
  get center() {
    return this.position.includes("center");
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.text = "";
    this._defaultPosition = "top right";
    this._position = this._defaultPosition;
    this.status = "basic";
  }
};
_NbBadgeComponent.ɵfac = function NbBadgeComponent_Factory(t) {
  return new (t || _NbBadgeComponent)(ɵɵdirectiveInject(NbStatusService));
};
_NbBadgeComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbBadgeComponent,
  selectors: [["nb-badge"]],
  hostVars: 32,
  hostBindings: function NbBadgeComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("dot-mode", ctx.dotMode)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("position-top", ctx.top)("position-right", ctx.right)("position-bottom", ctx.bottom)("position-left", ctx.left)("position-start", ctx.start)("position-end", ctx.end)("position-center", ctx.center);
    }
  },
  inputs: {
    text: "text",
    position: "position",
    dotMode: "dotMode",
    status: "status"
  },
  decls: 1,
  vars: 1,
  template: function NbBadgeComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtext(0);
    }
    if (rf & 2) {
      ɵɵtextInterpolate(ctx.dotMode ? "" : ctx.text);
    }
  },
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{position:absolute;text-align:center;white-space:nowrap;vertical-align:baseline}.position-top[_nghost-%COMP%]{top:0}.position-right[_nghost-%COMP%]{right:0}.position-bottom[_nghost-%COMP%]{bottom:0}.position-left[_nghost-%COMP%]{left:0}.position-center[_nghost-%COMP%]{top:50%;transform:translateY(-50%)}[dir=ltr]   .position-start[_nghost-%COMP%]{left:0}[dir=rtl]   .position-start[_nghost-%COMP%]{right:0}[dir=ltr]   .position-end[_nghost-%COMP%]{right:0}[dir=rtl]   .position-end[_nghost-%COMP%]{left:0}"]
});
var NbBadgeComponent = _NbBadgeComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBadgeComponent, [{
    type: Component,
    args: [{
      selector: "nb-badge",
      template: `{{dotMode ? '' : text}}`,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{position:absolute;text-align:center;white-space:nowrap;vertical-align:baseline}:host(.position-top){top:0}:host(.position-right){right:0}:host(.position-bottom){bottom:0}:host(.position-left){left:0}:host(.position-center){top:50%;transform:translateY(-50%)}[dir=ltr] :host(.position-start){left:0}[dir=rtl] :host(.position-start){right:0}[dir=ltr] :host(.position-end){right:0}[dir=rtl] :host(.position-end){left:0}\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    text: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    dotMode: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.dot-mode"]
    }],
    status: [{
      type: Input
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    top: [{
      type: HostBinding,
      args: ["class.position-top"]
    }],
    right: [{
      type: HostBinding,
      args: ["class.position-right"]
    }],
    bottom: [{
      type: HostBinding,
      args: ["class.position-bottom"]
    }],
    left: [{
      type: HostBinding,
      args: ["class.position-left"]
    }],
    start: [{
      type: HostBinding,
      args: ["class.position-start"]
    }],
    end: [{
      type: HostBinding,
      args: ["class.position-end"]
    }],
    center: [{
      type: HostBinding,
      args: ["class.position-center"]
    }]
  });
})();
var NbToggleStates;
(function(NbToggleStates2) {
  NbToggleStates2["Expanded"] = "expanded";
  NbToggleStates2["Collapsed"] = "collapsed";
})(NbToggleStates || (NbToggleStates = {}));
var _NbMenuItemComponent = class _NbMenuItemComponent {
  constructor(menuService, directionService) {
    this.menuService = menuService;
    this.directionService = directionService;
    this.menuItem = null;
    this.hoverItem = new EventEmitter();
    this.toggleSubMenu = new EventEmitter();
    this.selectItem = new EventEmitter();
    this.itemClick = new EventEmitter();
    this.destroy$ = new Subject();
  }
  ngDoCheck() {
    this.toggleState = this.menuItem.expanded ? NbToggleStates.Expanded : NbToggleStates.Collapsed;
  }
  ngAfterViewInit() {
    this.menuService.onSubmenuToggle().pipe(filter(({
      item
    }) => item === this.menuItem), map(({
      item
    }) => item.expanded), takeUntil(this.destroy$)).subscribe((isExpanded) => this.toggleState = isExpanded ? NbToggleStates.Expanded : NbToggleStates.Collapsed);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  onToggleSubMenu(item) {
    this.toggleSubMenu.emit(item);
  }
  onHoverItem(item) {
    this.hoverItem.emit(item);
  }
  onSelectItem(item) {
    this.selectItem.emit(item);
  }
  onItemClick(item) {
    this.itemClick.emit(item);
  }
  getExpandStateIcon() {
    if (this.menuItem.expanded) {
      return "chevron-down-outline";
    }
    return this.directionService.isLtr() ? "chevron-left-outline" : "chevron-right-outline";
  }
};
_NbMenuItemComponent.ɵfac = function NbMenuItemComponent_Factory(t) {
  return new (t || _NbMenuItemComponent)(ɵɵdirectiveInject(NbMenuService), ɵɵdirectiveInject(NbLayoutDirectionService));
};
_NbMenuItemComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbMenuItemComponent,
  selectors: [["", "nbMenuItem", ""]],
  inputs: {
    menuItem: "menuItem",
    badge: "badge"
  },
  outputs: {
    hoverItem: "hoverItem",
    toggleSubMenu: "toggleSubMenu",
    selectItem: "selectItem",
    itemClick: "itemClick"
  },
  attrs: _c17,
  decls: 8,
  vars: 6,
  consts: [[4, "ngIf"], [3, "routerLink", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "active", "mouseenter", "click", 4, "ngIf"], [3, "active", "mouseenter", "click", 4, "ngIf"], ["href", "#", 3, "active", "click", "mouseenter", 4, "ngIf"], ["class", "menu-items", 3, "collapsed", "expanded", 4, "ngIf"], ["badgeTemplate", ""], ["class", "menu-icon", 3, "config", 4, "ngIf"], [1, "menu-icon", 3, "config"], [3, "routerLink", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "mouseenter", "click"], [1, "menu-title"], [3, "ngTemplateOutlet", 4, "ngIf"], [3, "ngTemplateOutlet"], [3, "mouseenter", "click"], ["href", "#", 3, "click", "mouseenter"], ["pack", "nebular-essentials", 1, "expand-state", 3, "icon"], [1, "menu-items"], [4, "ngFor", "ngForOf"], ["nbMenuItem", "", "class", "menu-item", 3, "menuItem", "badge", "menu-group", "hoverItem", "toggleSubMenu", "selectItem", "itemClick", 4, "ngIf"], ["nbMenuItem", "", 1, "menu-item", 3, "menuItem", "badge", "hoverItem", "toggleSubMenu", "selectItem", "itemClick"], [3, "text", "dotMode", "status"]],
  template: function NbMenuItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbMenuItemComponent_span_0_Template, 3, 2, "span", 0)(1, NbMenuItemComponent_a_1_Template, 5, 14, "a", 1)(2, NbMenuItemComponent_a_2_Template, 5, 9, "a", 2)(3, NbMenuItemComponent_a_3_Template, 5, 8, "a", 2)(4, NbMenuItemComponent_a_4_Template, 6, 10, "a", 3)(5, NbMenuItemComponent_ul_5_Template, 2, 6, "ul", 4)(6, NbMenuItemComponent_ng_template_6_Template, 1, 3, "ng-template", null, 5, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.menuItem.group);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.menuItem.link && !ctx.menuItem.url && !ctx.menuItem.children && !ctx.menuItem.group);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.menuItem.url && !ctx.menuItem.children && !ctx.menuItem.link && !ctx.menuItem.group);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.menuItem.children && !ctx.menuItem.link && !ctx.menuItem.url && !ctx.menuItem.group);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.menuItem.children);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.menuItem.children);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, RouterLink, NbIconComponent, NbBadgeComponent, _NbMenuItemComponent],
  encapsulation: 2,
  data: {
    animation: [trigger("toggle", [state(NbToggleStates.Collapsed, style({
      height: "0",
      margin: "0"
    })), state(NbToggleStates.Expanded, style({
      height: "*"
    })), transition(`${NbToggleStates.Collapsed} <=> ${NbToggleStates.Expanded}`, animate(300))])]
  }
});
var NbMenuItemComponent = _NbMenuItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuItemComponent, [{
    type: Component,
    args: [{
      selector: "[nbMenuItem]",
      animations: [trigger("toggle", [state(NbToggleStates.Collapsed, style({
        height: "0",
        margin: "0"
      })), state(NbToggleStates.Expanded, style({
        height: "*"
      })), transition(`${NbToggleStates.Collapsed} <=> ${NbToggleStates.Expanded}`, animate(300))])],
      template: '<span *ngIf="menuItem.group">\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  {{ menuItem.title }}\n</span>\n<a\n  *ngIf="menuItem.link && !menuItem.url && !menuItem.children && !menuItem.group"\n  [routerLink]="menuItem.link"\n  [queryParams]="menuItem.queryParams"\n  [fragment]="menuItem.fragment"\n  [queryParamsHandling]="menuItem.queryParamsHandling"\n  [preserveFragment]="menuItem.preserveFragment"\n  [skipLocationChange]="menuItem.skipLocationChange"\n  [attr.target]="menuItem.target"\n  [attr.title]="menuItem.title"\n  [attr.role]="menuItem.ariaRole"\n  [class.active]="menuItem.selected"\n  (mouseenter)="onHoverItem(menuItem)"\n  (click)="onItemClick(menuItem)"\n>\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  <span class="menu-title">{{ menuItem.title }}</span>\n  <ng-container *ngIf="badge" [ngTemplateOutlet]="badgeTemplate"></ng-container>\n</a>\n<a\n  *ngIf="menuItem.url && !menuItem.children && !menuItem.link && !menuItem.group"\n  [attr.href]="menuItem.url"\n  [attr.target]="menuItem.target"\n  [attr.title]="menuItem.title"\n  [attr.role]="menuItem.ariaRole"\n  [class.active]="menuItem.selected"\n  (mouseenter)="onHoverItem(menuItem)"\n  (click)="onSelectItem(menuItem)"\n>\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  <span class="menu-title">{{ menuItem.title }}</span>\n  <ng-container *ngIf="badge" [ngTemplateOutlet]="badgeTemplate"></ng-container>\n</a>\n<a\n  *ngIf="!menuItem.children && !menuItem.link && !menuItem.url && !menuItem.group"\n  [attr.target]="menuItem.target"\n  [attr.title]="menuItem.title"\n  [attr.role]="menuItem.ariaRole"\n  [class.active]="menuItem.selected"\n  (mouseenter)="onHoverItem(menuItem)"\n  (click)="$event.preventDefault(); onItemClick(menuItem)"\n>\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  <span class="menu-title">{{ menuItem.title }}</span>\n  <ng-container *ngIf="badge" [ngTemplateOutlet]="badgeTemplate"></ng-container>\n</a>\n<a\n  *ngIf="menuItem.children"\n  (click)="$event.preventDefault(); onToggleSubMenu(menuItem)"\n  [attr.target]="menuItem.target"\n  [attr.title]="menuItem.title"\n  [attr.aria-expanded]="menuItem.expanded ?? false"\n  [attr.role]="menuItem.ariaRole"\n  [class.active]="menuItem.selected"\n  (mouseenter)="onHoverItem(menuItem)"\n  href="#"\n>\n  <nb-icon class="menu-icon" [config]="menuItem.icon" *ngIf="menuItem.icon"></nb-icon>\n  <span class="menu-title">{{ menuItem.title }}</span>\n  <ng-container *ngIf="badge" [ngTemplateOutlet]="badgeTemplate"></ng-container>\n  <nb-icon class="expand-state" [icon]="getExpandStateIcon()" pack="nebular-essentials"></nb-icon>\n</a>\n<ul\n  *ngIf="menuItem.children"\n  [class.collapsed]="!(menuItem.children && menuItem.expanded)"\n  [class.expanded]="menuItem.expanded"\n  [@toggle]="toggleState"\n  class="menu-items"\n>\n  <ng-container *ngFor="let item of menuItem.children">\n    <li\n      nbMenuItem\n      *ngIf="!item.hidden"\n      [menuItem]="item"\n      [badge]="item.badge"\n      [class.menu-group]="item.group"\n      (hoverItem)="onHoverItem($event)"\n      (toggleSubMenu)="onToggleSubMenu($event)"\n      (selectItem)="onSelectItem($event)"\n      (itemClick)="onItemClick($event)"\n      class="menu-item"\n    ></li>\n  </ng-container>\n</ul>\n\n<ng-template #badgeTemplate>\n  <nb-badge [text]="badge.text" [dotMode]="badge.dotMode" [status]="badge.status"> </nb-badge>\n</ng-template>\n'
    }]
  }], () => [{
    type: NbMenuService
  }, {
    type: NbLayoutDirectionService
  }], {
    menuItem: [{
      type: Input
    }],
    badge: [{
      type: Input
    }],
    hoverItem: [{
      type: Output
    }],
    toggleSubMenu: [{
      type: Output
    }],
    selectItem: [{
      type: Output
    }],
    itemClick: [{
      type: Output
    }]
  });
})();
var _NbMenuComponent = class _NbMenuComponent {
  /**
   * Collapse all opened submenus on the toggle event
   * Default value is "false"
   * @type boolean
   */
  get autoCollapse() {
    return this._autoCollapse;
  }
  set autoCollapse(value) {
    this._autoCollapse = convertToBoolProperty(value);
  }
  constructor(window2, platformId, menuInternalService, router) {
    this.window = window2;
    this.platformId = platformId;
    this.menuInternalService = menuInternalService;
    this.router = router;
    this._autoCollapse = false;
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.menuInternalService.prepareItems(this.items);
    this.menuInternalService.onAddItem().pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$)).subscribe((data) => this.onAddItem(data));
    this.menuInternalService.onNavigateHome().pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$)).subscribe(() => this.navigateHome());
    this.menuInternalService.onGetSelectedItem().pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$)).subscribe((data) => {
      data.listener.next({
        tag: this.tag,
        item: this.getSelectedItem(this.items)
      });
    });
    this.menuInternalService.onCollapseAll().pipe(filter((data) => this.compareTag(data.tag)), takeUntil(this.destroy$)).subscribe(() => this.collapseAll());
    this.router.events.pipe(filter((event) => event instanceof NavigationEnd), takeUntil(this.destroy$)).subscribe(() => {
      this.menuInternalService.selectFromUrl(this.items, this.tag, this.autoCollapse);
    });
  }
  ngAfterViewInit() {
    setTimeout(() => this.menuInternalService.selectFromUrl(this.items, this.tag, this.autoCollapse));
  }
  onAddItem(data) {
    this.items.push(...data.items);
    this.menuInternalService.prepareItems(this.items);
    this.menuInternalService.selectFromUrl(this.items, this.tag, this.autoCollapse);
  }
  onHoverItem(item) {
    this.menuInternalService.itemHover(item, this.tag);
  }
  onToggleSubMenu(item) {
    if (this.autoCollapse) {
      this.menuInternalService.collapseAll(this.items, this.tag, item);
    }
    item.expanded = !item.expanded;
    this.menuInternalService.submenuToggle(item, this.tag);
  }
  // TODO: is not fired on page reload
  onSelectItem(item) {
    this.menuInternalService.selectItem(item, this.items, this.autoCollapse, this.tag);
  }
  onItemClick(item) {
    this.menuInternalService.itemClick(item, this.tag);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  navigateHome() {
    const homeItem = this.getHomeItem(this.items);
    if (homeItem) {
      if (homeItem.link) {
        const extras = {
          queryParams: homeItem.queryParams,
          queryParamsHandling: homeItem.queryParamsHandling,
          fragment: homeItem.fragment,
          preserveFragment: homeItem.preserveFragment
        };
        this.router.navigate([homeItem.link], extras);
      }
      if (homeItem.url && isPlatformBrowser(this.platformId)) {
        this.window.location.href = homeItem.url;
      }
    }
  }
  collapseAll() {
    this.menuInternalService.collapseAll(this.items, this.tag);
  }
  getHomeItem(items) {
    for (const item of items) {
      if (item.home) {
        return item;
      }
      const homeItem = item.children && this.getHomeItem(item.children);
      if (homeItem) {
        return homeItem;
      }
    }
    return void 0;
  }
  compareTag(tag) {
    return !tag || tag === this.tag;
  }
  getSelectedItem(items) {
    let selected = null;
    items.forEach((item) => {
      if (item.selected) {
        selected = item;
      }
      if (item.selected && item.children && item.children.length > 0) {
        selected = this.getSelectedItem(item.children);
      }
    });
    return selected;
  }
};
_NbMenuComponent.ɵfac = function NbMenuComponent_Factory(t) {
  return new (t || _NbMenuComponent)(ɵɵdirectiveInject(NB_WINDOW), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(NbMenuInternalService), ɵɵdirectiveInject(Router));
};
_NbMenuComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbMenuComponent,
  selectors: [["nb-menu"]],
  inputs: {
    tag: "tag",
    items: "items",
    autoCollapse: "autoCollapse"
  },
  decls: 2,
  vars: 1,
  consts: [[1, "menu-items"], [4, "ngFor", "ngForOf"], ["nbMenuItem", "", "class", "menu-item", 3, "menuItem", "badge", "menu-group", "hoverItem", "toggleSubMenu", "selectItem", "itemClick", 4, "ngIf"], ["nbMenuItem", "", 1, "menu-item", 3, "menuItem", "badge", "hoverItem", "toggleSubMenu", "selectItem", "itemClick"]],
  template: function NbMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "ul", 0);
      ɵɵtemplate(1, NbMenuComponent_ng_container_1_Template, 2, 1, "ng-container", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.items);
    }
  },
  dependencies: [NgForOf, NgIf, NbMenuItemComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]    {display:block}[_nghost-%COMP%]     .menu-items, [_nghost-%COMP%]     .menu-item>.menu-items{list-style-type:none;overflow:hidden}[_nghost-%COMP%]     .menu-item a{display:flex;text-decoration:none;align-items:center}[_nghost-%COMP%]     .menu-item a .menu-title{flex:1 0 auto;pointer-events:none}[dir=rtl]   [_nghost-%COMP%]     .menu-item a .menu-title{text-align:right}[_nghost-%COMP%]     .menu-item nb-badge{position:static}[_nghost-%COMP%]     .menu-group span{display:flex}"]
});
var NbMenuComponent = _NbMenuComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuComponent, [{
    type: Component,
    args: [{
      selector: "nb-menu",
      template: `
    <ul class="menu-items">
      <ng-container *ngFor="let item of items">
        <li nbMenuItem *ngIf="!item.hidden"
            [menuItem]="item"
            [badge]="item.badge"
            [class.menu-group]="item.group"
            (hoverItem)="onHoverItem($event)"
            (toggleSubMenu)="onToggleSubMenu($event)"
            (selectItem)="onSelectItem($event)"
            (itemClick)="onItemClick($event)"
            class="menu-item">
        </li>
      </ng-container>
    </ul>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host ::ng-deep{display:block}:host ::ng-deep .menu-items,:host ::ng-deep .menu-item>.menu-items{list-style-type:none;overflow:hidden}:host ::ng-deep .menu-item a{display:flex;text-decoration:none;align-items:center}:host ::ng-deep .menu-item a .menu-title{flex:1 0 auto;pointer-events:none}[dir=rtl] :host ::ng-deep .menu-item a .menu-title{text-align:right}:host ::ng-deep .menu-item nb-badge{position:static}:host ::ng-deep .menu-group span{display:flex}\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: NbMenuInternalService
  }, {
    type: Router
  }], {
    tag: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    autoCollapse: [{
      type: Input
    }]
  });
})();
var _NbBadgeModule = class _NbBadgeModule {
};
_NbBadgeModule.ɵfac = function NbBadgeModule_Factory(t) {
  return new (t || _NbBadgeModule)();
};
_NbBadgeModule.ɵmod = ɵɵdefineNgModule({
  type: _NbBadgeModule,
  declarations: [NbBadgeComponent],
  exports: [NbBadgeComponent]
});
_NbBadgeModule.ɵinj = ɵɵdefineInjector({});
var NbBadgeModule = _NbBadgeModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBadgeModule, [{
    type: NgModule,
    args: [{
      exports: [NbBadgeComponent],
      declarations: [NbBadgeComponent]
    }]
  }], null, null);
})();
var nbMenuComponents = [NbMenuComponent, NbMenuItemComponent];
var NB_MENU_PROVIDERS = [NbMenuService, NbMenuInternalService];
var _NbMenuModule = class _NbMenuModule {
  static forRoot() {
    return {
      ngModule: _NbMenuModule,
      providers: [...NB_MENU_PROVIDERS]
    };
  }
};
_NbMenuModule.ɵfac = function NbMenuModule_Factory(t) {
  return new (t || _NbMenuModule)();
};
_NbMenuModule.ɵmod = ɵɵdefineNgModule({
  type: _NbMenuModule,
  declarations: [NbMenuComponent, NbMenuItemComponent],
  imports: [NbSharedModule, NbIconModule, NbBadgeModule],
  exports: [NbMenuComponent, NbMenuItemComponent]
});
_NbMenuModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbIconModule, NbBadgeModule]
});
var NbMenuModule = _NbMenuModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMenuModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule, NbBadgeModule],
      declarations: [...nbMenuComponents],
      exports: [...nbMenuComponents]
    }]
  }], null, null);
})();
var _NbMergeConfigsPipe = class _NbMergeConfigsPipe {
  transform(...configs) {
    return Object.assign({}, ...configs);
  }
};
_NbMergeConfigsPipe.ɵfac = function NbMergeConfigsPipe_Factory(t) {
  return new (t || _NbMergeConfigsPipe)();
};
_NbMergeConfigsPipe.ɵpipe = ɵɵdefinePipe({
  name: "nbMergeConfigs",
  type: _NbMergeConfigsPipe,
  pure: true
});
var NbMergeConfigsPipe = _NbMergeConfigsPipe;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbMergeConfigsPipe, [{
    type: Pipe,
    args: [{
      name: "nbMergeConfigs"
    }]
  }], null, null);
})();
var _NbRouteTabsetComponent = class _NbRouteTabsetComponent {
  constructor() {
    this.fullWidthValue = false;
    this.activeLinkOptions = {
      exact: true
    };
    this.changeTab = new EventEmitter();
  }
  /**
   * Take full width of a parent
   * @param {boolean} val
   */
  set fullWidth(val) {
    this.fullWidthValue = convertToBoolProperty(val);
  }
  selectTab(tab) {
    this.changeTab.emit(tab);
  }
};
_NbRouteTabsetComponent.ɵfac = function NbRouteTabsetComponent_Factory(t) {
  return new (t || _NbRouteTabsetComponent)();
};
_NbRouteTabsetComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbRouteTabsetComponent,
  selectors: [["nb-route-tabset"]],
  hostVars: 2,
  hostBindings: function NbRouteTabsetComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("full-width", ctx.fullWidthValue);
    }
  },
  inputs: {
    tabs: "tabs",
    activeLinkOptions: "activeLinkOptions",
    fullWidth: "fullWidth"
  },
  outputs: {
    changeTab: "changeTab"
  },
  decls: 3,
  vars: 1,
  consts: [[1, "route-tabset"], [4, "ngFor", "ngForOf"], ["class", "route-tab disabled", "tabindex", "-1", 3, "responsive", 4, "ngIf", "ngIfElse"], ["enabled", ""], ["tabindex", "-1", 1, "route-tab", "disabled"], ["tabindex", "-1", 1, "tab-link"], [3, "config", 4, "ngIf"], ["class", "tab-text", 4, "ngIf"], [3, "config"], [1, "tab-text"], ["routerLinkActive", "active", 1, "route-tab", 3, "routerLinkActiveOptions"], [1, "tab-link", 3, "routerLink", "queryParams", "queryParamsHandling", "fragment", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "click"]],
  template: function NbRouteTabsetComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "ul", 0);
      ɵɵtemplate(1, NbRouteTabsetComponent_ng_container_1_Template, 4, 2, "ng-container", 1);
      ɵɵelementEnd();
      ɵɵelement(2, "router-outlet");
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.tabs);
    }
  },
  dependencies: [NgForOf, NgIf, RouterOutlet, RouterLink, RouterLinkActive, NbIconComponent, NbMergeConfigsPipe],
  styles: ['\n\n\n\n\n.route-tabset[_ngcontent-%COMP%]{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]{margin-bottom:-1px;text-align:center;padding:0}.route-tabset[_ngcontent-%COMP%]   .route-tab.active[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:before{display:block}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{position:relative;text-decoration:none;display:inline-block}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:before{position:absolute;content:"";width:100%;border-radius:3px;bottom:-2px;left:0}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{vertical-align:middle}[dir=ltr]   [_nghost-%COMP%]   .tab-link[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .tab-link[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-right:.5rem}.full-width[_nghost-%COMP%]   .route-tabset[_ngcontent-%COMP%]{justify-content:space-around}']
});
var NbRouteTabsetComponent = _NbRouteTabsetComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRouteTabsetComponent, [{
    type: Component,
    args: [{
      selector: "nb-route-tabset",
      template: `
    <ul class="route-tabset">
      <ng-container *ngFor="let tab of tabs">
        <li
          *ngIf="tab.disabled; else enabled"
          [class.responsive]="tab.responsive"
          class="route-tab disabled"
          tabindex="-1"
        >
          <a tabindex="-1" class="tab-link">
            <nb-icon *ngIf="tab.icon" [config]="tab.icon"></nb-icon>
            <span *ngIf="tab.title" class="tab-text">{{ tab.title }}</span>
          </a>
        </li>

        <ng-template #enabled>
          <li
            routerLinkActive="active"
            [routerLinkActiveOptions]="activeLinkOptions | nbMergeConfigs: tab.activeLinkOptions"
            class="route-tab"
          >
            <a
              (click)="selectTab(tab)"
              [routerLink]="tab.route"
              [class.responsive]="tab.responsive"
              [queryParams]="tab.queryParams"
              [queryParamsHandling]="tab.queryParamsHandling"
              [fragment]="tab.fragment"
              [preserveFragment]="tab.preserveFragment"
              [skipLocationChange]="tab.skipLocationChange"
              [replaceUrl]="tab.replaceUrl"
              [state]="tab.state"
              class="tab-link"
            >
              <nb-icon *ngIf="tab.icon" [config]="tab.icon"></nb-icon>
              <span *ngIf="tab.title" class="tab-text">{{ tab.title }}</span>
            </a>
          </li>
        </ng-template>
      </ng-container>
    </ul>
    <router-outlet></router-outlet>
  `,
      styles: ['/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */.route-tabset{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}.route-tabset .route-tab{margin-bottom:-1px;text-align:center;padding:0}.route-tabset .route-tab.active a:before{display:block}.route-tabset .route-tab a{position:relative;text-decoration:none;display:inline-block}.route-tabset .route-tab a:before{position:absolute;content:"";width:100%;border-radius:3px;bottom:-2px;left:0}.route-tabset .route-tab a nb-icon{vertical-align:middle}[dir=ltr] :host .tab-link nb-icon+span{margin-left:.5rem}[dir=rtl] :host .tab-link nb-icon+span{margin-right:.5rem}:host(.full-width) .route-tabset{justify-content:space-around}\n']
    }]
  }], null, {
    fullWidthValue: [{
      type: HostBinding,
      args: ["class.full-width"]
    }],
    tabs: [{
      type: Input
    }],
    activeLinkOptions: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }],
    changeTab: [{
      type: Output
    }]
  });
})();
var _NbRouteTabsetModule = class _NbRouteTabsetModule {
};
_NbRouteTabsetModule.ɵfac = function NbRouteTabsetModule_Factory(t) {
  return new (t || _NbRouteTabsetModule)();
};
_NbRouteTabsetModule.ɵmod = ɵɵdefineNgModule({
  type: _NbRouteTabsetModule,
  declarations: [NbRouteTabsetComponent, NbMergeConfigsPipe],
  imports: [NbSharedModule, NbIconModule],
  exports: [NbRouteTabsetComponent]
});
_NbRouteTabsetModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbIconModule]
});
var NbRouteTabsetModule = _NbRouteTabsetModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRouteTabsetModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule],
      declarations: [NbRouteTabsetComponent, NbMergeConfigsPipe],
      exports: [NbRouteTabsetComponent]
    }]
  }], null, null);
})();
var getSidebarState$ = new Subject();
var getSidebarResponsiveState$ = new Subject();
var _NbSidebarService = class _NbSidebarService {
  constructor() {
    this.toggle$ = new Subject();
    this.expand$ = new Subject();
    this.collapse$ = new Subject();
    this.compact$ = new Subject();
  }
  /**
   * Subscribe to toggle events
   *
   * @returns Observable<{ compact: boolean, tag: string }>
   */
  onToggle() {
    return this.toggle$.pipe(share());
  }
  /**
   * Subscribe to expand events
   * @returns Observable<{ tag: string }>
   */
  onExpand() {
    return this.expand$.pipe(share());
  }
  /**
   * Subscribe to collapse evens
   * @returns Observable<{ tag: string }>
   */
  onCollapse() {
    return this.collapse$.pipe(share());
  }
  /**
   * Subscribe to compact evens
   * @returns Observable<{ tag: string }>
   */
  onCompact() {
    return this.compact$.pipe(share());
  }
  /**
   * Toggle a sidebar
   * @param {boolean} compact
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar you want to control
   */
  toggle(compact = false, tag) {
    this.toggle$.next({
      compact,
      tag
    });
  }
  /**
   * Expands a sidebar
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar you want to control
   */
  expand(tag) {
    this.expand$.next({
      tag
    });
  }
  /**
   * Collapses a sidebar
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar you want to control
   */
  collapse(tag) {
    this.collapse$.next({
      tag
    });
  }
  /**
   * Makes sidebar compact
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar you want to control
   */
  compact(tag) {
    this.compact$.next({
      tag
    });
  }
  /**
   * Returns sidebar state observable which emits once
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar state you need
   */
  getSidebarState(tag) {
    const observer = new ReplaySubject(1);
    getSidebarState$.next({
      observer,
      tag
    });
    return observer.pipe(publish(), refCount());
  }
  /**
   * Returns sidebar state observable which emits once
   * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
   * to specify which sidebar responsive state you need
   */
  getSidebarResponsiveState(tag) {
    const observer = new ReplaySubject();
    getSidebarResponsiveState$.next({
      observer,
      tag
    });
    return observer.pipe(publish(), refCount());
  }
};
_NbSidebarService.ɵfac = function NbSidebarService_Factory(t) {
  return new (t || _NbSidebarService)();
};
_NbSidebarService.ɵprov = ɵɵdefineInjectable({
  token: _NbSidebarService,
  factory: _NbSidebarService.ɵfac
});
var NbSidebarService = _NbSidebarService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarService, [{
    type: Injectable
  }], null, null);
})();
var _NbSidebarHeaderComponent = class _NbSidebarHeaderComponent {
};
_NbSidebarHeaderComponent.ɵfac = function NbSidebarHeaderComponent_Factory(t) {
  return new (t || _NbSidebarHeaderComponent)();
};
_NbSidebarHeaderComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSidebarHeaderComponent,
  selectors: [["nb-sidebar-header"]],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function NbSidebarHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
var NbSidebarHeaderComponent = _NbSidebarHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarHeaderComponent, [{
    type: Component,
    args: [{
      selector: "nb-sidebar-header",
      template: ` <ng-content></ng-content> `
    }]
  }], null, null);
})();
var _NbSidebarFooterComponent = class _NbSidebarFooterComponent {
};
_NbSidebarFooterComponent.ɵfac = function NbSidebarFooterComponent_Factory(t) {
  return new (t || _NbSidebarFooterComponent)();
};
_NbSidebarFooterComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSidebarFooterComponent,
  selectors: [["nb-sidebar-footer"]],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function NbSidebarFooterComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
var NbSidebarFooterComponent = _NbSidebarFooterComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarFooterComponent, [{
    type: Component,
    args: [{
      selector: "nb-sidebar-footer",
      template: ` <ng-content></ng-content> `
    }]
  }], null, null);
})();
var _NbSidebarComponent = class _NbSidebarComponent {
  get expanded() {
    return this.state === "expanded";
  }
  get collapsed() {
    return this.state === "collapsed";
  }
  get compacted() {
    return this.state === "compacted";
  }
  /**
   * Places sidebar on the right side
   * @type {boolean}
   */
  set right(val) {
    this.rightValue = convertToBoolProperty(val);
    this.leftValue = !this.rightValue;
    this.startValue = false;
    this.endValue = false;
  }
  /**
   * Places sidebar on the left side
   * @type {boolean}
   */
  set left(val) {
    this.leftValue = convertToBoolProperty(val);
    this.rightValue = !this.leftValue;
    this.startValue = false;
    this.endValue = false;
  }
  /**
   * Places sidebar on the start edge of layout
   * @type {boolean}
   */
  set start(val) {
    this.startValue = convertToBoolProperty(val);
    this.endValue = !this.startValue;
    this.leftValue = false;
    this.rightValue = false;
  }
  /**
   * Places sidebar on the end edge of layout
   * @type {boolean}
   */
  set end(val) {
    this.endValue = convertToBoolProperty(val);
    this.startValue = !this.endValue;
    this.leftValue = false;
    this.rightValue = false;
  }
  /**
   * Makes sidebar fixed (shown above the layout content)
   * @type {boolean}
   */
  set fixed(val) {
    this.fixedValue = convertToBoolProperty(val);
  }
  /**
   * Makes sidebar container fixed
   * @type {boolean}
   */
  set containerFixed(val) {
    this.containerFixedValue = convertToBoolProperty(val);
  }
  /**
   * Initial sidebar state, `expanded`|`collapsed`|`compacted`
   * @type {string}
   */
  get state() {
    return this._state;
  }
  set state(value) {
    this._state = value;
  }
  /**
   * Makes sidebar listen to media query events and change its behaviour
   * @type {boolean}
   */
  get responsive() {
    return this._responsive;
  }
  set responsive(value) {
    if (this.responsive !== convertToBoolProperty(value)) {
      this._responsive = !this.responsive;
      this.responsiveValueChange$.next(this.responsive);
    }
  }
  constructor(sidebarService, themeService, element, cd) {
    this.sidebarService = sidebarService;
    this.themeService = themeService;
    this.element = element;
    this.cd = cd;
    this.responsiveValueChange$ = new Subject();
    this.responsiveState = "pc";
    this.destroy$ = new Subject();
    this.containerFixedValue = true;
    this.fixedValue = false;
    this.rightValue = false;
    this.leftValue = true;
    this.startValue = false;
    this.endValue = false;
    this._state = "expanded";
    this._responsive = false;
    this.compactedBreakpoints = ["xs", "is", "sm", "md", "lg"];
    this.collapsedBreakpoints = ["xs", "is"];
    this.stateChange = new EventEmitter();
    this.responsiveStateChange = new EventEmitter();
  }
  ngOnInit() {
    this.sidebarService.onToggle().pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(({
      compact
    }) => this.toggle(compact));
    this.sidebarService.onExpand().pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(() => this.expand());
    this.sidebarService.onCollapse().pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(() => this.collapse());
    this.sidebarService.onCompact().pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(() => this.compact());
    getSidebarState$.pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(({
      observer
    }) => observer.next(this.state));
    getSidebarResponsiveState$.pipe(filter(({
      tag
    }) => !this.tag || this.tag === tag), takeUntil(this.destroy$)).subscribe(({
      observer
    }) => observer.next(this.responsiveState));
    this.responsiveValueChange$.pipe(filter((responsive) => !responsive), takeUntil(this.destroy$)).subscribe(() => this.expand());
    this.subscribeToMediaQueryChange();
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  // TODO: this is more of a workaround, should be a better way to make components communicate to each other
  onClick(event) {
    const menu = this.element.nativeElement.querySelector("nb-menu");
    if (menu && menu.contains(event.target)) {
      const link = this.getMenuLink(event.target);
      if (link && link.nextElementSibling && link.nextElementSibling.classList.contains("menu-items")) {
        this.sidebarService.expand(this.tag);
      }
    }
  }
  /**
   * Collapses the sidebar
   */
  collapse() {
    this.updateState("collapsed");
  }
  /**
   * Expands the sidebar
   */
  expand() {
    this.updateState("expanded");
  }
  /**
   * Compacts the sidebar (minimizes)
   */
  compact() {
    this.updateState("compacted");
  }
  /**
   * Toggles sidebar state (expanded|collapsed|compacted)
   * @param {boolean} compact If true, then sidebar state will be changed between expanded & compacted,
   * otherwise - between expanded & collapsed. False by default.
   *
   * Toggle sidebar state
   *
   * ```ts
   * this.sidebar.toggle(true);
   * ```
   */
  toggle(compact = false) {
    if (this.responsive) {
      if (this.responsiveState === "mobile") {
        compact = false;
      }
    }
    if (this.state === "compacted" || this.state === "collapsed") {
      this.updateState("expanded");
    } else {
      this.updateState(compact ? "compacted" : "collapsed");
    }
  }
  subscribeToMediaQueryChange() {
    combineLatest([this.responsiveValueChange$.pipe(startWith(this.responsive)), this.themeService.onMediaQueryChange()]).pipe(filter(([responsive]) => responsive), map(([, breakpoints]) => breakpoints), takeUntil(this.destroy$)).subscribe(([prev, current]) => {
      const isCollapsed = this.collapsedBreakpoints.includes(current.name);
      const isCompacted = this.compactedBreakpoints.includes(current.name);
      let newResponsiveState;
      if (isCompacted) {
        this.fixed = this.containerFixedValue;
        this.compact();
        newResponsiveState = "tablet";
      }
      if (isCollapsed) {
        this.fixed = true;
        this.collapse();
        newResponsiveState = "mobile";
      }
      if (!isCollapsed && !isCompacted && (!prev.width || prev.width < current.width)) {
        this.expand();
        this.fixed = false;
        newResponsiveState = "pc";
      }
      if (newResponsiveState && newResponsiveState !== this.responsiveState) {
        this.responsiveState = newResponsiveState;
        this.responsiveStateChange.emit(this.responsiveState);
        this.cd.markForCheck();
      }
    });
  }
  getMenuLink(element) {
    if (!element || element.tagName.toLowerCase() === "nb-menu") {
      return void 0;
    }
    if (element.tagName.toLowerCase() === "a") {
      return element;
    }
    return this.getMenuLink(element.parentElement);
  }
  updateState(state2) {
    if (this.state !== state2) {
      this.state = state2;
      this.stateChange.emit(this.state);
      this.cd.markForCheck();
    }
  }
};
_NbSidebarComponent.ɵfac = function NbSidebarComponent_Factory(t) {
  return new (t || _NbSidebarComponent)(ɵɵdirectiveInject(NbSidebarService), ɵɵdirectiveInject(NbThemeService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbSidebarComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSidebarComponent,
  selectors: [["nb-sidebar"]],
  hostVars: 16,
  hostBindings: function NbSidebarComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("fixed", ctx.fixedValue)("right", ctx.rightValue)("left", ctx.leftValue)("start", ctx.startValue)("end", ctx.endValue)("expanded", ctx.expanded)("collapsed", ctx.collapsed)("compacted", ctx.compacted);
    }
  },
  inputs: {
    right: "right",
    left: "left",
    start: "start",
    end: "end",
    fixed: "fixed",
    containerFixed: "containerFixed",
    state: "state",
    responsive: "responsive",
    tag: "tag",
    compactedBreakpoints: "compactedBreakpoints",
    collapsedBreakpoints: "collapsedBreakpoints"
  },
  outputs: {
    stateChange: "stateChange",
    responsiveStateChange: "responsiveStateChange"
  },
  ngContentSelectors: _c19,
  decls: 5,
  vars: 2,
  consts: [[1, "main-container"], [1, "scrollable", 3, "click"]],
  template: function NbSidebarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c18);
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementStart(2, "div", 1);
      ɵɵlistener("click", function NbSidebarComponent_Template_div_click_2_listener($event) {
        return ctx.onClick($event);
      });
      ɵɵprojection(3, 1);
      ɵɵelementEnd();
      ɵɵprojection(4, 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("main-container-fixed", ctx.containerFixedValue);
    }
  },
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;flex-direction:column;overflow:hidden;z-index:auto;order:0}[_nghost-%COMP%]   .scrollable[_ngcontent-%COMP%]{overflow-y:auto;overflow-x:hidden;flex:1}[_nghost-%COMP%]   .main-container[_ngcontent-%COMP%]{transform:translateZ(0);display:flex;flex-direction:column}[_nghost-%COMP%]   .main-container-fixed[_ngcontent-%COMP%]{position:fixed}.right[_nghost-%COMP%]{margin-right:0;margin-left:auto}[dir=ltr]   .right[_nghost-%COMP%]{order:4}[dir=rtl]   .right[_nghost-%COMP%]{order:0}.end[_nghost-%COMP%]{order:4}[dir=ltr]   .end[_nghost-%COMP%]{margin-right:0;margin-left:auto}[dir=rtl]   .end[_nghost-%COMP%]{margin-left:0;margin-right:auto}.fixed[_nghost-%COMP%]{position:fixed;height:100%;z-index:999;top:0;bottom:0;left:0}.fixed.right[_nghost-%COMP%]{right:0}[dir=ltr]   .fixed.start[_nghost-%COMP%]{left:0}[dir=rtl]   .fixed.start[_nghost-%COMP%]{right:0}[dir=ltr]   .fixed.end[_nghost-%COMP%]{right:0}[dir=rtl]   .fixed.end[_nghost-%COMP%]{left:0}[_nghost-%COMP%]     nb-sidebar-footer{margin-top:auto;display:block}[_nghost-%COMP%]     nb-sidebar-header{display:block}"],
  changeDetection: 0
});
var NbSidebarComponent = _NbSidebarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarComponent, [{
    type: Component,
    args: [{
      selector: "nb-sidebar",
      template: `
    <div class="main-container" [class.main-container-fixed]="containerFixedValue">
      <ng-content select="nb-sidebar-header"></ng-content>
      <div class="scrollable" (click)="onClick($event)">
        <ng-content></ng-content>
      </div>
      <ng-content select="nb-sidebar-footer"></ng-content>
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;flex-direction:column;overflow:hidden;z-index:auto;order:0}:host .scrollable{overflow-y:auto;overflow-x:hidden;flex:1}:host .main-container{transform:translateZ(0);display:flex;flex-direction:column}:host .main-container-fixed{position:fixed}:host.right{margin-right:0;margin-left:auto}[dir=ltr] :host.right{order:4}[dir=rtl] :host.right{order:0}:host.end{order:4}[dir=ltr] :host.end{margin-right:0;margin-left:auto}[dir=rtl] :host.end{margin-left:0;margin-right:auto}:host.fixed{position:fixed;height:100%;z-index:999;top:0;bottom:0;left:0}:host.fixed.right{right:0}[dir=ltr] :host.fixed.start{left:0}[dir=rtl] :host.fixed.start{right:0}[dir=ltr] :host.fixed.end{right:0}[dir=rtl] :host.fixed.end{left:0}:host ::ng-deep nb-sidebar-footer{margin-top:auto;display:block}:host ::ng-deep nb-sidebar-header{display:block}\n"]
    }]
  }], () => [{
    type: NbSidebarService
  }, {
    type: NbThemeService
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }], {
    fixedValue: [{
      type: HostBinding,
      args: ["class.fixed"]
    }],
    rightValue: [{
      type: HostBinding,
      args: ["class.right"]
    }],
    leftValue: [{
      type: HostBinding,
      args: ["class.left"]
    }],
    startValue: [{
      type: HostBinding,
      args: ["class.start"]
    }],
    endValue: [{
      type: HostBinding,
      args: ["class.end"]
    }],
    expanded: [{
      type: HostBinding,
      args: ["class.expanded"]
    }],
    collapsed: [{
      type: HostBinding,
      args: ["class.collapsed"]
    }],
    compacted: [{
      type: HostBinding,
      args: ["class.compacted"]
    }],
    right: [{
      type: Input
    }],
    left: [{
      type: Input
    }],
    start: [{
      type: Input
    }],
    end: [{
      type: Input
    }],
    fixed: [{
      type: Input
    }],
    containerFixed: [{
      type: Input
    }],
    state: [{
      type: Input
    }],
    responsive: [{
      type: Input
    }],
    tag: [{
      type: Input
    }],
    compactedBreakpoints: [{
      type: Input
    }],
    collapsedBreakpoints: [{
      type: Input
    }],
    stateChange: [{
      type: Output
    }],
    responsiveStateChange: [{
      type: Output
    }]
  });
})();
var NB_SIDEBAR_COMPONENTS = [NbSidebarComponent, NbSidebarFooterComponent, NbSidebarHeaderComponent];
var NB_SIDEBAR_PROVIDERS = [NbSidebarService];
var _NbSidebarModule = class _NbSidebarModule {
  static forRoot() {
    return {
      ngModule: _NbSidebarModule,
      providers: [...NB_SIDEBAR_PROVIDERS]
    };
  }
};
_NbSidebarModule.ɵfac = function NbSidebarModule_Factory(t) {
  return new (t || _NbSidebarModule)();
};
_NbSidebarModule.ɵmod = ɵɵdefineNgModule({
  type: _NbSidebarModule,
  declarations: [NbSidebarComponent, NbSidebarFooterComponent, NbSidebarHeaderComponent],
  imports: [NbSharedModule],
  exports: [NbSidebarComponent, NbSidebarFooterComponent, NbSidebarHeaderComponent]
});
_NbSidebarModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule]
});
var NbSidebarModule = _NbSidebarModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSidebarModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [...NB_SIDEBAR_COMPONENTS],
      exports: [...NB_SIDEBAR_COMPONENTS]
    }]
  }], null, null);
})();
var _NbTabContentDirective = class _NbTabContentDirective {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
_NbTabContentDirective.ɵfac = function NbTabContentDirective_Factory(t) {
  return new (t || _NbTabContentDirective)(ɵɵdirectiveInject(TemplateRef));
};
_NbTabContentDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTabContentDirective,
  selectors: [["", "nbTabContent", ""]]
});
var NbTabContentDirective = _NbTabContentDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabContentDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTabContent]"
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _NbTabTitleDirective = class _NbTabTitleDirective {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
_NbTabTitleDirective.ɵfac = function NbTabTitleDirective_Factory(t) {
  return new (t || _NbTabTitleDirective)(ɵɵdirectiveInject(TemplateRef));
};
_NbTabTitleDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTabTitleDirective,
  selectors: [["", "nbTabTitle", ""]]
});
var NbTabTitleDirective = _NbTabTitleDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabTitleDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTabTitle]"
    }]
  }], () => [{
    type: TemplateRef
  }], null);
})();
var _NbTabComponent = class _NbTabComponent {
  constructor() {
    this.activeValue = false;
    this.responsiveValue = false;
    this.disabledValue = false;
    this.badgeStatus = "basic";
    this.init = false;
  }
  /**
   * Use badge dot mode
   * @type {boolean}
   */
  get badgeDot() {
    return this._badgeDot;
  }
  set badgeDot(val) {
    this._badgeDot = convertToBoolProperty(val);
  }
  /**
   * Item is disabled and cannot be opened.
   * @type {boolean}
   */
  get disabled() {
    return this.disabledValue;
  }
  set disabled(val) {
    this.disabledValue = convertToBoolProperty(val);
  }
  /**
   * Show only icons when width is smaller than `tabs-icon-only-max-width`
   * @type {boolean}
   */
  set responsive(val) {
    this.responsiveValue = convertToBoolProperty(val);
  }
  get responsive() {
    return this.responsiveValue;
  }
  /**
   * Specifies active tab
   * @returns {boolean}
   */
  get active() {
    return this.activeValue;
  }
  set active(val) {
    this.activeValue = convertToBoolProperty(val);
    if (this.activeValue) {
      this.init = true;
    }
  }
  /**
   * Lazy load content before tab selection
   * @docs-private
   * @deprecated This setting never worked. Wrap content into a `nbTabContent` to make it lazy.
   * @breaking-change Remove 12.0.0
   */
  set lazyLoad(val) {
    this.init = convertToBoolProperty(val);
  }
};
_NbTabComponent.ɵfac = function NbTabComponent_Factory(t) {
  return new (t || _NbTabComponent)();
};
_NbTabComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTabComponent,
  selectors: [["nb-tab"]],
  contentQueries: function NbTabComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbTabContentDirective, 5);
      ɵɵcontentQuery(dirIndex, NbTabTitleDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabContentDirective = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabTitleDirective = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function NbTabComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("disabled", ctx.disabled)("content-active", ctx.activeValue);
    }
  },
  inputs: {
    tabTitle: "tabTitle",
    tabId: "tabId",
    badgeDot: "badgeDot",
    tabIcon: "tabIcon",
    disabled: "disabled",
    responsive: "responsive",
    route: "route",
    active: "active",
    lazyLoad: "lazyLoad",
    badgeText: "badgeText",
    badgeStatus: "badgeStatus",
    badgePosition: "badgePosition"
  },
  ngContentSelectors: _c02,
  decls: 3,
  vars: 2,
  consts: [[3, "ngTemplateOutlet", 4, "ngIf", "ngIfElse"], ["projectedContent", ""], [3, "ngTemplateOutlet"]],
  template: function NbTabComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, NbTabComponent_ng_container_0_Template, 1, 1, "ng-container", 0)(1, NbTabComponent_ng_template_1_Template, 1, 0, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = ɵɵreference(2);
      ɵɵproperty("ngIf", ctx.tabContentDirective)("ngIfElse", _r2);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  encapsulation: 2
});
var NbTabComponent = _NbTabComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabComponent, [{
    type: Component,
    args: [{
      selector: "nb-tab",
      template: `
    <ng-container
      *ngIf="tabContentDirective; else projectedContent"
      [ngTemplateOutlet]="tabContentDirective.templateRef"
    ></ng-container>

    <ng-template #projectedContent>
      <ng-content></ng-content>
    </ng-template>
  `
    }]
  }], null, {
    tabContentDirective: [{
      type: ContentChild,
      args: [NbTabContentDirective]
    }],
    tabTitleDirective: [{
      type: ContentChild,
      args: [NbTabTitleDirective]
    }],
    tabTitle: [{
      type: Input
    }],
    tabId: [{
      type: Input
    }],
    badgeDot: [{
      type: Input
    }],
    tabIcon: [{
      type: Input
    }],
    disabled: [{
      type: Input,
      args: ["disabled"]
    }, {
      type: HostBinding,
      args: ["class.disabled"]
    }],
    responsive: [{
      type: Input
    }],
    route: [{
      type: Input
    }],
    activeValue: [{
      type: HostBinding,
      args: ["class.content-active"]
    }],
    active: [{
      type: Input
    }],
    lazyLoad: [{
      type: Input
    }],
    badgeText: [{
      type: Input
    }],
    badgeStatus: [{
      type: Input
    }],
    badgePosition: [{
      type: Input
    }]
  });
})();
var _NbTabsetComponent = class _NbTabsetComponent {
  /**
   * Take full width of a parent
   * @param {boolean} val
   */
  set fullWidth(val) {
    this.fullWidthValue = convertToBoolProperty(val);
  }
  constructor(route, changeDetectorRef) {
    this.route = route;
    this.changeDetectorRef = changeDetectorRef;
    this.fullWidthValue = false;
    this.changeTab = new EventEmitter();
    this.destroy$ = new Subject();
  }
  // TODO: refactoring this component, avoid change detection loop
  ngAfterContentInit() {
    this.route.params.pipe(map((params) => this.tabs.find((tab) => this.routeParam ? tab.route === params[this.routeParam] : tab.active)), delay(0), map((tab) => tab || this.tabs.first), filter((tab) => !!tab), takeUntil(this.destroy$)).subscribe((tabToSelect) => {
      this.selectTab(tabToSelect);
      this.changeDetectorRef.markForCheck();
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  // TODO: navigate to routeParam
  selectTab(selectedTab) {
    if (!selectedTab.disabled) {
      this.tabs.forEach((tab) => tab.active = tab === selectedTab);
      this.changeTab.emit(selectedTab);
    }
  }
};
_NbTabsetComponent.ɵfac = function NbTabsetComponent_Factory(t) {
  return new (t || _NbTabsetComponent)(ɵɵdirectiveInject(ActivatedRoute), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbTabsetComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTabsetComponent,
  selectors: [["nb-tabset"]],
  contentQueries: function NbTabsetComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbTabComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabs = _t);
    }
  },
  hostVars: 2,
  hostBindings: function NbTabsetComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("full-width", ctx.fullWidthValue);
    }
  },
  inputs: {
    fullWidth: "fullWidth",
    routeParam: "routeParam"
  },
  outputs: {
    changeTab: "changeTab"
  },
  ngContentSelectors: _c21,
  decls: 3,
  vars: 1,
  consts: [[1, "tabset"], ["class", "tab", 3, "responsive", "active", "disabled", "click", "keyup.space", "keyup.enter", 4, "ngFor", "ngForOf"], [1, "tab", 3, "click", "keyup.space", "keyup.enter"], ["href", "", "tabindex", "-1", 1, "tab-link", 3, "click"], [3, "config", 4, "ngIf"], [3, "ngTemplateOutlet", 4, "ngIf", "ngIfElse"], ["textTitleTemplate", ""], [3, "text", "dotMode", "status", "position", 4, "ngIf"], [3, "config"], [3, "ngTemplateOutlet"], [1, "tab-text"], [3, "text", "dotMode", "status", "position"]],
  template: function NbTabsetComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c20);
      ɵɵelementStart(0, "ul", 0);
      ɵɵtemplate(1, NbTabsetComponent_li_1_Template, 7, 12, "li", 1);
      ɵɵelementEnd();
      ɵɵprojection(2);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.tabs);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, NbBadgeComponent, NbIconComponent],
  styles: ['\n\n\n\n\n[_nghost-%COMP%]{display:block}.full-width[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]{justify-content:space-around}[_nghost-%COMP%]     nb-tab{flex:1;-ms-flex:1 1 auto;overflow:auto;display:none}[_nghost-%COMP%]     nb-tab.content-active{display:block}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]{margin-bottom:-1px;text-align:center;position:relative}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab.active[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:before{display:block}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{display:flex;position:relative;text-decoration:none}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:before{position:absolute;content:"";width:100%;border-radius:3px;bottom:-2px;left:0}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{vertical-align:middle}[dir=ltr]   [_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-right:.5rem}']
});
var NbTabsetComponent = _NbTabsetComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabsetComponent, [{
    type: Component,
    args: [{
      selector: "nb-tabset",
      template: `
    <ul class="tabset">
      <li
        *ngFor="let tab of tabs"
        (click)="selectTab(tab)"
        (keyup.space)="selectTab(tab)"
        (keyup.enter)="selectTab(tab)"
        [class.responsive]="tab.responsive"
        [class.active]="tab.active"
        [class.disabled]="tab.disabled"
        [attr.tabindex]="tab.disabled ? -1 : 0"
        [attr.data-tab-id]="tab.tabId"
        class="tab"
      >
        <a href (click)="$event.preventDefault()" tabindex="-1" class="tab-link">
          <nb-icon *ngIf="tab.tabIcon" [config]="tab.tabIcon"></nb-icon>
          <ng-container
            *ngIf="tab.tabTitleDirective; else textTitleTemplate"
            [ngTemplateOutlet]="tab.tabTitleDirective.templateRef"
          ></ng-container>
          <ng-template #textTitleTemplate>
            <span class="tab-text">{{ tab.tabTitle }}</span>
          </ng-template>
        </a>
        <nb-badge
          *ngIf="tab.badgeText || tab.badgeDot"
          [text]="tab.badgeText"
          [dotMode]="tab.badgeDot"
          [status]="tab.badgeStatus"
          [position]="tab.badgePosition"
        >
        </nb-badge>
      </li>
    </ul>
    <ng-content select="nb-tab"></ng-content>
  `,
      styles: ['/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:block}:host.full-width .tabset{justify-content:space-around}:host ::ng-deep nb-tab{flex:1;-ms-flex:1 1 auto;overflow:auto;display:none}:host ::ng-deep nb-tab.content-active{display:block}:host .tabset{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}:host .tabset .tab{margin-bottom:-1px;text-align:center;position:relative}:host .tabset .tab.active a:before{display:block}:host .tabset .tab a{display:flex;position:relative;text-decoration:none}:host .tabset .tab a:before{position:absolute;content:"";width:100%;border-radius:3px;bottom:-2px;left:0}:host .tabset .tab a nb-icon{vertical-align:middle}[dir=ltr] :host .tabset .tab a nb-icon+span{margin-left:.5rem}[dir=rtl] :host .tabset .tab a nb-icon+span{margin-right:.5rem}\n']
    }]
  }], () => [{
    type: ActivatedRoute
  }, {
    type: ChangeDetectorRef
  }], {
    tabs: [{
      type: ContentChildren,
      args: [NbTabComponent]
    }],
    fullWidthValue: [{
      type: HostBinding,
      args: ["class.full-width"]
    }],
    fullWidth: [{
      type: Input
    }],
    routeParam: [{
      type: Input
    }],
    changeTab: [{
      type: Output
    }]
  });
})();
var NB_TABSET_COMPONENTS = [NbTabsetComponent, NbTabComponent];
var NB_TABSET_DIRECTIVES = [NbTabContentDirective, NbTabTitleDirective];
var _NbTabsetModule = class _NbTabsetModule {
};
_NbTabsetModule.ɵfac = function NbTabsetModule_Factory(t) {
  return new (t || _NbTabsetModule)();
};
_NbTabsetModule.ɵmod = ɵɵdefineNgModule({
  type: _NbTabsetModule,
  declarations: [NbTabsetComponent, NbTabComponent, NbTabContentDirective, NbTabTitleDirective],
  imports: [NbSharedModule, NbBadgeModule, NbIconModule],
  exports: [NbTabsetComponent, NbTabComponent, NbTabContentDirective, NbTabTitleDirective]
});
_NbTabsetModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbBadgeModule, NbIconModule]
});
var NbTabsetModule = _NbTabsetModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTabsetModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbBadgeModule, NbIconModule],
      declarations: [...NB_TABSET_COMPONENTS, ...NB_TABSET_DIRECTIVES],
      exports: [...NB_TABSET_COMPONENTS, ...NB_TABSET_DIRECTIVES]
    }]
  }], null, null);
})();
var _NbUserComponent = class _NbUserComponent {
  /**
   * Absolute path to a user picture or base64 image.
   * User name initials will be shown if no picture specified (JD for John Doe).
   * @type string
   */
  set picture(value) {
    this.imageBackgroundStyle = value ? this.domSanitizer.bypassSecurityTrustStyle(`url(${value})`) : null;
  }
  /**
   * Whether to show a user name or not
   */
  get showName() {
    return this._showName;
  }
  set showName(val) {
    this._showName = convertToBoolProperty(val);
  }
  /**
   * Whether to show a user title or not
   * @type boolean
   */
  get showTitle() {
    return this._showTitle;
  }
  set showTitle(val) {
    this._showTitle = convertToBoolProperty(val);
  }
  /**
   * Whether to show a user initials (if no picture specified) or not
   * @type boolean
   */
  get showInitials() {
    return this._showInitials;
  }
  set showInitials(val) {
    this._showInitials = convertToBoolProperty(val);
  }
  /**
   * Whether to show only a picture or also show the name and title
   * @type boolean
   */
  get onlyPicture() {
    return !this.showName && !this.showTitle;
  }
  set onlyPicture(val) {
    this.showName = this.showTitle = !convertToBoolProperty(val);
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
  get round() {
    return this.shape === "round";
  }
  constructor(domSanitizer) {
    this.domSanitizer = domSanitizer;
    this.name = "Anonymous";
    this.size = "medium";
    this.shape = "round";
    this._showName = true;
    this._showTitle = true;
    this._showInitials = true;
    this.badgeStatus = "basic";
  }
  getInitials() {
    if (this.name) {
      const names = this.name.split(" ");
      return names.map((n) => n.charAt(0)).splice(0, 2).join("").toUpperCase();
    }
    return "";
  }
};
_NbUserComponent.ɵfac = function NbUserComponent_Factory(t) {
  return new (t || _NbUserComponent)(ɵɵdirectiveInject(DomSanitizer));
};
_NbUserComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbUserComponent,
  selectors: [["nb-user"]],
  hostVars: 16,
  hostBindings: function NbUserComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("shape-rectangle", ctx.rectangle)("shape-semi-round", ctx.semiRound)("shape-round", ctx.round);
    }
  },
  inputs: {
    name: "name",
    title: "title",
    picture: "picture",
    color: "color",
    size: "size",
    shape: "shape",
    showName: "showName",
    showTitle: "showTitle",
    showInitials: "showInitials",
    onlyPicture: "onlyPicture",
    badgeText: "badgeText",
    badgeStatus: "badgeStatus",
    badgePosition: "badgePosition"
  },
  decls: 6,
  vars: 4,
  consts: [[1, "user-container"], ["class", "user-picture image", 3, "background-image", 4, "ngIf"], ["class", "user-picture initials", 3, "background-color", 4, "ngIf"], [1, "info-container"], ["class", "user-name", 4, "ngIf"], ["class", "user-title", 4, "ngIf"], [1, "user-picture", "image"], [3, "text", "status", "position", 4, "ngIf"], [3, "text", "status", "position"], [1, "user-picture", "initials"], [4, "ngIf"], [1, "user-name"], [1, "user-title"]],
  template: function NbUserComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, NbUserComponent_div_1_Template, 2, 3, "div", 1)(2, NbUserComponent_div_2_Template, 3, 4, "div", 2);
      ɵɵelementStart(3, "div", 3);
      ɵɵtemplate(4, NbUserComponent_div_4_Template, 2, 1, "div", 4)(5, NbUserComponent_div_5_Template, 2, 1, "div", 5);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.imageBackgroundStyle);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.imageBackgroundStyle);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.showName && ctx.name);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showTitle && ctx.title);
    }
  },
  dependencies: [NgIf, NbBadgeComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex}[_nghost-%COMP%]   .user-container[_ngcontent-%COMP%]{position:relative;display:flex;align-items:center}[_nghost-%COMP%]   .user-picture[_ngcontent-%COMP%]{position:relative;flex-shrink:0}[_nghost-%COMP%]   .user-picture.image[_ngcontent-%COMP%]{background-size:cover;background-repeat:no-repeat}[_nghost-%COMP%]   .user-picture.initials[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center}[dir=rtl]   [_nghost-%COMP%]   .user-name[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .user-title[_ngcontent-%COMP%]{text-align:right}[dir=ltr]   [_nghost-%COMP%]   .info-container[_ngcontent-%COMP%]{margin-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .info-container[_ngcontent-%COMP%]{margin-right:.5rem}"]
});
var NbUserComponent = _NbUserComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbUserComponent, [{
    type: Component,
    args: [{
      selector: "nb-user",
      template: '<div class="user-container">\n  <div *ngIf="imageBackgroundStyle" class="user-picture image" [style.background-image]="imageBackgroundStyle">\n    <nb-badge *ngIf="badgeText" [text]="badgeText" [status]="badgeStatus" [position]="badgePosition"></nb-badge>\n  </div>\n  <div *ngIf="!imageBackgroundStyle" class="user-picture initials" [style.background-color]="color">\n    <ng-container *ngIf="showInitials">\n      {{ getInitials() }}\n    </ng-container>\n    <nb-badge *ngIf="badgeText" [text]="badgeText" [status]="badgeStatus" [position]="badgePosition"></nb-badge>\n  </div>\n\n  <div class="info-container">\n    <div *ngIf="showName && name" class="user-name">{{ name }}</div>\n    <div *ngIf="showTitle && title" class="user-title">{{ title }}</div>\n  </div>\n</div>\n',
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex}:host .user-container{position:relative;display:flex;align-items:center}:host .user-picture{position:relative;flex-shrink:0}:host .user-picture.image{background-size:cover;background-repeat:no-repeat}:host .user-picture.initials{display:flex;align-items:center;justify-content:center}[dir=rtl] :host .user-name,[dir=rtl] :host .user-title{text-align:right}[dir=ltr] :host .info-container{margin-left:.5rem}[dir=rtl] :host .info-container{margin-right:.5rem}\n"]
    }]
  }], () => [{
    type: DomSanitizer
  }], {
    name: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    picture: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    showName: [{
      type: Input
    }],
    showTitle: [{
      type: Input
    }],
    showInitials: [{
      type: Input
    }],
    onlyPicture: [{
      type: Input
    }],
    badgeText: [{
      type: Input
    }],
    badgeStatus: [{
      type: Input
    }],
    badgePosition: [{
      type: Input
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }]
  });
})();
var NB_USER_COMPONENTS = [NbUserComponent];
var _NbUserModule = class _NbUserModule {
};
_NbUserModule.ɵfac = function NbUserModule_Factory(t) {
  return new (t || _NbUserModule)();
};
_NbUserModule.ɵmod = ɵɵdefineNgModule({
  type: _NbUserModule,
  declarations: [NbUserComponent],
  imports: [NbSharedModule, NbBadgeModule],
  exports: [NbUserComponent]
});
_NbUserModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbBadgeModule]
});
var NbUserModule = _NbUserModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbUserModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbBadgeModule],
      declarations: [...NB_USER_COMPONENTS],
      exports: [...NB_USER_COMPONENTS]
    }]
  }], null, null);
})();
var _NbActionComponent = class _NbActionComponent {
  constructor() {
    this.title = "";
    this._disabled = false;
    this.badgeStatus = "basic";
  }
  /**
   * Visually disables the item
   * @type boolean
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  /**
   * Use badge dot mode
   * @type boolean
   */
  get badgeDot() {
    return this._badgeDot;
  }
  set badgeDot(value) {
    this._badgeDot = convertToBoolProperty(value);
  }
};
_NbActionComponent.ɵfac = function NbActionComponent_Factory(t) {
  return new (t || _NbActionComponent)();
};
_NbActionComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbActionComponent,
  selectors: [["nb-action"]],
  hostVars: 2,
  hostBindings: function NbActionComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("disabled", ctx.disabled);
    }
  },
  inputs: {
    link: "link",
    href: "href",
    title: "title",
    icon: "icon",
    disabled: "disabled",
    badgeDot: "badgeDot",
    badgeText: "badgeText",
    badgeStatus: "badgeStatus",
    badgePosition: "badgePosition"
  },
  ngContentSelectors: _c02,
  decls: 5,
  vars: 2,
  consts: [[4, "ngIf", "ngIfElse"], ["projectedContent", ""], ["badgeTemplate", ""], ["class", "icon-container", 3, "routerLink", "title", 4, "ngIf"], ["class", "icon-container", 3, "href", "title", 4, "ngIf"], ["class", "icon-container", "href", "#", 3, "title", "click", 4, "ngIf"], [1, "icon-container", 3, "routerLink", "title"], [3, "config"], [3, "ngTemplateOutlet"], [1, "icon-container", 3, "href", "title"], ["href", "#", 1, "icon-container", 3, "title", "click"], [3, "text", "dotMode", "status", "position", 4, "ngIf"], [3, "text", "dotMode", "status", "position"]],
  template: function NbActionComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, NbActionComponent_ng_container_0_Template, 4, 3, "ng-container", 0)(1, NbActionComponent_ng_template_1_Template, 2, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor)(3, NbActionComponent_ng_template_3_Template, 1, 1, "ng-template", null, 2, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = ɵɵreference(2);
      ɵɵproperty("ngIf", ctx.icon)("ngIfElse", _r2);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, RouterLink, NbBadgeComponent, NbIconComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{background:transparent;display:flex;align-items:center;position:relative}.disabled[_nghost-%COMP%]{cursor:not-allowed}.disabled[_nghost-%COMP%]   a[_ngcontent-%COMP%], .disabled[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]{cursor:not-allowed}nb-actions.full-width[_nghost-%COMP%], nb-actions.full-width   [_nghost-%COMP%]{justify-content:center;width:100%}a.icon-container[_ngcontent-%COMP%]{position:relative}a.icon-container[_ngcontent-%COMP%]:hover, a.icon-container[_ngcontent-%COMP%]:focus{text-decoration:none}nb-icon[_ngcontent-%COMP%]:hover{cursor:pointer}"]
});
var NbActionComponent = _NbActionComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbActionComponent, [{
    type: Component,
    args: [{
      selector: "nb-action",
      template: `
    <ng-container *ngIf="icon; else projectedContent">
      <a class="icon-container"
         [routerLink]="link"
         [title]="title"
         *ngIf="link">
        <nb-icon [config]="icon"></nb-icon>
        <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
      </a>
      <a class="icon-container"
         [href]="href"
         [title]="title"
         *ngIf="href && !link">
        <nb-icon [config]="icon"></nb-icon>
        <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
      </a>
      <a class="icon-container"
         href="#"
         [title]="title"
         *ngIf="!href && !link"
         (click)="$event.preventDefault()">
        <nb-icon [config]="icon"></nb-icon>
        <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
      </a>
    </ng-container>

    <ng-template #projectedContent>
      <ng-content></ng-content>
      <ng-container [ngTemplateOutlet]="badgeTemplate"></ng-container>
    </ng-template>
    <ng-template #badgeTemplate>
      <nb-badge *ngIf="badgeText || badgeDot"
                [text]="badgeText"
                [dotMode]="badgeDot"
                [status]="badgeStatus"
                [position]="badgePosition">
      </nb-badge>
    </ng-template>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{background:transparent;display:flex;align-items:center;position:relative}:host(.disabled){cursor:not-allowed}:host(.disabled) a,:host(.disabled) nb-icon{cursor:not-allowed}:host-context(nb-actions.full-width){justify-content:center;width:100%}a.icon-container{position:relative}a.icon-container:hover,a.icon-container:focus{text-decoration:none}nb-icon:hover{cursor:pointer}\n"]
    }]
  }], null, {
    link: [{
      type: Input
    }],
    href: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.disabled"]
    }],
    badgeDot: [{
      type: Input
    }],
    badgeText: [{
      type: Input
    }],
    badgeStatus: [{
      type: Input
    }],
    badgePosition: [{
      type: Input
    }]
  });
})();
var _NbActionsComponent = class _NbActionsComponent {
  constructor() {
    this._size = "small";
    this._fullWidth = false;
  }
  /**
   * Size of the component: 'tiny', 'small' (default), 'medium', 'large', 'giant'
   */
  get size() {
    return this._size;
  }
  set size(value) {
    this._size = value;
  }
  /**
   * Component will fill full width of the container
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
};
_NbActionsComponent.ɵfac = function NbActionsComponent_Factory(t) {
  return new (t || _NbActionsComponent)();
};
_NbActionsComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbActionsComponent,
  selectors: [["nb-actions"]],
  hostVars: 12,
  hostBindings: function NbActionsComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("full-width", ctx.fullWidth)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant);
    }
  },
  inputs: {
    size: "size",
    fullWidth: "fullWidth"
  },
  ngContentSelectors: _c23,
  decls: 1,
  vars: 0,
  template: function NbActionsComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c22);
      ɵɵprojection(0);
    }
  },
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;align-items:center}"]
});
var NbActionsComponent = _NbActionsComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbActionsComponent, [{
    type: Component,
    args: [{
      selector: "nb-actions",
      template: `
    <ng-content select="nb-action"></ng-content>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;align-items:center}\n"]
    }]
  }], null, {
    size: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.full-width"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }]
  });
})();
var NB_ACTIONS_COMPONENTS = [NbActionComponent, NbActionsComponent];
var _NbActionsModule = class _NbActionsModule {
};
_NbActionsModule.ɵfac = function NbActionsModule_Factory(t) {
  return new (t || _NbActionsModule)();
};
_NbActionsModule.ɵmod = ɵɵdefineNgModule({
  type: _NbActionsModule,
  declarations: [NbActionComponent, NbActionsComponent],
  imports: [NbSharedModule, NbBadgeModule, NbIconModule],
  exports: [NbActionComponent, NbActionsComponent]
});
_NbActionsModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbBadgeModule, NbIconModule]
});
var NbActionsModule = _NbActionsModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbActionsModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbBadgeModule, NbIconModule],
      declarations: [...NB_ACTIONS_COMPONENTS],
      exports: [...NB_ACTIONS_COMPONENTS]
    }]
  }], null, null);
})();
var _NbSearchService = class _NbSearchService {
  constructor() {
    this.searchSubmittings$ = new Subject();
    this.searchActivations$ = new Subject();
    this.searchDeactivations$ = new Subject();
    this.searchInput$ = new Subject();
  }
  /***
   * Activate (open) search component
   * @param {string} searchType
   * @param {string} tag
   */
  activateSearch(searchType, tag) {
    this.searchActivations$.next({
      searchType,
      tag
    });
  }
  /**
   * Deactibate (close) search component
   * @param {string} searchType
   * @param {string} tag
   */
  deactivateSearch(searchType, tag) {
    this.searchDeactivations$.next({
      searchType,
      tag
    });
  }
  /**
   * Trigger search submit
   * @param {string} term
   * @param {string} tag
   */
  submitSearch(term, tag) {
    this.searchSubmittings$.next({
      term,
      tag
    });
  }
  /**
   * Trigger search submit by input event
   * @param {string} term
   * @param {string} tag
   */
  searchInput(term, tag) {
    this.searchInput$.next({
      term,
      tag
    });
  }
  /**
   * Subscribe to 'activate' event
   * @returns Observable<{searchType: string; tag?: string}>
   */
  onSearchActivate() {
    return this.searchActivations$.pipe(share());
  }
  /**
   * Subscribe to 'deactivate' event
   * @returns Observable<{searchType: string; tag?: string}>
   */
  onSearchDeactivate() {
    return this.searchDeactivations$.pipe(share());
  }
  /**
   * Subscribe to 'submit' event (when submit button clicked)
   * @returns Observable<{term: string; tag?: string}>
   */
  onSearchSubmit() {
    return this.searchSubmittings$.pipe(share());
  }
  /**
   * Subscribe to input event
   * @returns Observable<{term: string; tag?: string}>
   */
  onSearchInput() {
    return this.searchInput$.pipe(share());
  }
};
_NbSearchService.ɵfac = function NbSearchService_Factory(t) {
  return new (t || _NbSearchService)();
};
_NbSearchService.ɵprov = ɵɵdefineInjectable({
  token: _NbSearchService,
  factory: _NbSearchService.ɵfac
});
var NbSearchService = _NbSearchService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSearchService, [{
    type: Injectable
  }], null, null);
})();
var _NbSearchFieldComponent = class _NbSearchFieldComponent {
  constructor() {
    this.show = false;
    this.close = new EventEmitter();
    this.search = new EventEmitter();
    this.searchInput = new EventEmitter();
  }
  get showClass() {
    return this.show;
  }
  get modalZoomin() {
    return this.type === _NbSearchFieldComponent.TYPE_MODAL_ZOOMIN;
  }
  get rotateLayout() {
    return this.type === _NbSearchFieldComponent.TYPE_ROTATE_LAYOUT;
  }
  get modalMove() {
    return this.type === _NbSearchFieldComponent.TYPE_MODAL_MOVE;
  }
  get curtain() {
    return this.type === _NbSearchFieldComponent.TYPE_CURTAIN;
  }
  get columnCurtain() {
    return this.type === _NbSearchFieldComponent.TYPE_COLUMN_CURTAIN;
  }
  get modalDrop() {
    return this.type === _NbSearchFieldComponent.TYPE_MODAL_DROP;
  }
  get modalHalf() {
    return this.type === _NbSearchFieldComponent.TYPE_MODAL_HALF;
  }
  ngOnChanges({
    show
  }) {
    const becameHidden = !show.isFirstChange() && show.currentValue === false;
    if (becameHidden && this.inputElement) {
      this.inputElement.nativeElement.value = "";
    }
    this.focusInput();
  }
  ngAfterViewInit() {
    this.focusInput();
  }
  emitClose() {
    this.close.emit();
  }
  submitSearch(term) {
    if (term) {
      this.search.emit(term);
    }
  }
  emitSearchInput(term) {
    this.searchInput.emit(term);
  }
  focusInput() {
    if (this.show && this.inputElement) {
      this.inputElement.nativeElement.focus();
    }
  }
};
_NbSearchFieldComponent.TYPE_MODAL_ZOOMIN = "modal-zoomin";
_NbSearchFieldComponent.TYPE_ROTATE_LAYOUT = "rotate-layout";
_NbSearchFieldComponent.TYPE_MODAL_MOVE = "modal-move";
_NbSearchFieldComponent.TYPE_CURTAIN = "curtain";
_NbSearchFieldComponent.TYPE_COLUMN_CURTAIN = "column-curtain";
_NbSearchFieldComponent.TYPE_MODAL_DROP = "modal-drop";
_NbSearchFieldComponent.TYPE_MODAL_HALF = "modal-half";
_NbSearchFieldComponent.ɵfac = function NbSearchFieldComponent_Factory(t) {
  return new (t || _NbSearchFieldComponent)();
};
_NbSearchFieldComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSearchFieldComponent,
  selectors: [["nb-search-field"]],
  viewQuery: function NbSearchFieldComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c24, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputElement = _t.first);
    }
  },
  hostVars: 16,
  hostBindings: function NbSearchFieldComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("show", ctx.showClass)("modal-zoomin", ctx.modalZoomin)("rotate-layout", ctx.rotateLayout)("modal-move", ctx.modalMove)("curtain", ctx.curtain)("column-curtain", ctx.columnCurtain)("modal-drop", ctx.modalDrop)("modal-half", ctx.modalHalf);
    }
  },
  inputs: {
    type: "type",
    placeholder: "placeholder",
    hint: "hint",
    show: "show"
  },
  outputs: {
    close: "close",
    search: "search",
    searchInput: "searchInput"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 10,
  vars: 2,
  consts: [[1, "search", 3, "keyup.esc"], ["nbButton", "", "ghost", "", 1, "close-button", 3, "click"], ["icon", "close-outline", "pack", "nebular-essentials"], [1, "form-wrapper"], [1, "form", 3, "keyup.enter"], [1, "form-content"], ["autocomplete", "off", "tabindex", "-1", 1, "search-input", 3, "input", "blur"], ["searchInput", ""], [1, "info"]],
  template: function NbSearchFieldComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 0);
      ɵɵlistener("keyup.esc", function NbSearchFieldComponent_Template_div_keyup_esc_0_listener() {
        return ctx.emitClose();
      });
      ɵɵelementStart(1, "button", 1);
      ɵɵlistener("click", function NbSearchFieldComponent_Template_button_click_1_listener() {
        return ctx.emitClose();
      });
      ɵɵelement(2, "nb-icon", 2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "div", 3)(4, "form", 4);
      ɵɵlistener("keyup.enter", function NbSearchFieldComponent_Template_form_keyup_enter_4_listener() {
        ɵɵrestoreView(_r1);
        const _r0 = ɵɵreference(7);
        return ɵɵresetView(ctx.submitSearch(_r0.value));
      });
      ɵɵelementStart(5, "div", 5)(6, "input", 6, 7);
      ɵɵlistener("input", function NbSearchFieldComponent_Template_input_input_6_listener() {
        ɵɵrestoreView(_r1);
        const _r0 = ɵɵreference(7);
        return ɵɵresetView(ctx.emitSearchInput(_r0.value));
      })("blur", function NbSearchFieldComponent_Template_input_blur_6_listener() {
        return ctx.focusInput();
      });
      ɵɵelementEnd()();
      ɵɵelementStart(8, "span", 8);
      ɵɵtext(9);
      ɵɵelementEnd()()()();
    }
    if (rf & 2) {
      ɵɵadvance(6);
      ɵɵattribute("placeholder", ctx.placeholder);
      ɵɵadvance(3);
      ɵɵtextInterpolate(ctx.hint);
    }
  },
  dependencies: [ɵNgNoValidate, NgControlStatusGroup, NgForm, NbIconComponent, NbButtonComponent],
  styles: ['\n\n\n\n\n\n\n\n\n\n[_nghost-%COMP%]   button[_ngcontent-%COMP%]{margin:0;padding:0;cursor:pointer;border:none;background:none}[_nghost-%COMP%]   button[_ngcontent-%COMP%]:focus{box-shadow:none;outline:none}[_nghost-%COMP%]   input[_ngcontent-%COMP%]{border-top:0;border-right:0;border-left:0;background:transparent;border-radius:0;line-height:1;display:inline-block;box-sizing:border-box;padding:.05rem 0;-webkit-appearance:none}[_nghost-%COMP%]   input[_ngcontent-%COMP%]:focus{outline:none}[_nghost-%COMP%]   input[_ngcontent-%COMP%]::placeholder{opacity:.3}[_nghost-%COMP%]   span[_ngcontent-%COMP%]{font-size:90%;font-weight:700;display:block;width:75%;margin:0 auto;padding:.85rem 0;text-align:right}.modal-zoomin[_nghost-%COMP%]{display:block}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity .5s}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before, .modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{content:"";position:absolute;width:calc(100% + 15px);height:calc(100% + 15px);pointer-events:none}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{top:0;left:0;border-right-width:0;border-bottom-width:0;transform:translate3d(-15px,-15px,0)}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{right:0;bottom:0;border-top-width:0;border-left-width:0;transform:translate3d(15px,15px,0)}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:3rem;font-size:2.5rem}[dir=ltr]   .modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:10vw;width:75%}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto;opacity:1}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before, .modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{transform:translateZ(0);transition:transform .5s}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}@media screen and (max-width: 40rem){.modal-zoomin[_nghost-%COMP%]   form[_ngcontent-%COMP%]{margin:5rem 0 1rem}.modal-zoomin[_nghost-%COMP%]   span[_ngcontent-%COMP%]{text-align:left}}', "\n\n\n\n\n  nb-layout.rotate-layout{position:fixed;overflow:hidden;width:100%}  nb-layout.rotate-layout .scrollable-container{position:relative;z-index:10001;transition:transform .5s cubic-bezier(.2,1,.3,1)}  nb-layout.rotate-layout.with-search .scrollable-container{transition:transform .5s cubic-bezier(.2,1,.3,1);transform-origin:50vw 50vh;transform:perspective(1000px) translate3d(0,50vh,0) rotateX(30deg);pointer-events:none}.rotate-layout[_nghost-%COMP%]{position:absolute;display:block;width:100vw;height:100vh;pointer-events:none;opacity:0;transition-property:opacity;transition-delay:.4s}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:50vh;pointer-events:none;opacity:0;transition:opacity .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}[dir=ltr]   .rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{margin:5rem 0;opacity:0;transform:scale3d(.7,.7,1);transition:opacity .5s,transform .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:7vw;width:75%}.rotate-layout.show[_nghost-%COMP%]{opacity:1;transition-delay:0s}.rotate-layout.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto;opacity:1}.rotate-layout.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.rotate-layout.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}", "\n\n\n\n\n  nb-layout.modal-move .layout{transition:transform .5s}  nb-layout.modal-move.with-search .layout{transform:scale3d(.8,.8,1);pointer-events:none}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity .5s}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transition:opacity .5s}[dir=ltr]   .modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{margin:5rem 0;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:10vw;width:75%;transform:scale3d(0,1,1);transform-origin:0 50%;transition:transform .3s}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto;opacity:1}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{transform:scaleZ(1);transition-duration:.5s}@media screen and (max-width: 40rem){.modal-move[_nghost-%COMP%]   span[_ngcontent-%COMP%]{text-align:left}}", '\n\n\n\n\n\n\n\n\n\n.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{position:fixed;z-index:1050;top:0;left:100%;overflow:hidden;height:100vh;width:100%;padding:3rem;pointer-events:none;transition:transform .3s;transition-delay:.4s;transition-timing-function:ease-out}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;transition:transform .3s;transition-timing-function:ease-out}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{font-size:2.5rem;position:absolute;top:3rem;transition:opacity .1s;transition-delay:.3s}[dir=ltr]   .curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{width:50%;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{width:100%;font-size:6vw}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{width:100%;pointer-events:auto;transform:translate3d(-100%,0,0);transition-delay:0s}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:after{transform:translate3d(100%,0,0);transition-delay:.4s}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}@media screen and (max-width: 40em){.curtain[_nghost-%COMP%]   span[_ngcontent-%COMP%]{width:90%}.curtain[_nghost-%COMP%]   input[_ngcontent-%COMP%]{font-size:2em;width:90%}}  nb-layout.curtain .scrollable-container{position:relative;z-index:0}', '\n\n\n\n\n\n\n\n\n\n  nb-layout.column-curtain.with-search .layout{pointer-events:none}.column-curtain[_nghost-%COMP%]{display:block;position:fixed;z-index:1050;top:0;left:50%;overflow:hidden;width:50%;height:100vh;pointer-events:none}.column-curtain[_nghost-%COMP%]:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;transform:scale3d(0,1,1);transform-origin:0 50%;transition:transform .3s;transition-timing-function:cubic-bezier(.86,0,.07,1)}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{position:relative;padding:2.5rem 1.5rem 0;background:transparent}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:2rem;font-size:2.5rem;opacity:0;transition:opacity .5s}[dir=ltr]   .column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:2rem}[dir=rtl]   .column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:2rem}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{width:85%;transform:translate3d(-150%,0,0);transition:transform .3s}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:2.5rem;width:100%}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{font-size:85%}.column-curtain.show[_nghost-%COMP%]{pointer-events:auto}.column-curtain.show[_nghost-%COMP%]:before{transform:scaleZ(1)}.column-curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{transform:translateZ(0);transition-delay:.15s;transition-timing-function:cubic-bezier(.86,0,.07,1)}.column-curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;z-index:100}@media screen and (max-width: 40rem){.column-curtain[_nghost-%COMP%]   span[_ngcontent-%COMP%]{width:90%}.column-curtain[_nghost-%COMP%]   input[_ngcontent-%COMP%]{font-size:2rem;width:90%}}', '\n\n\n\n\n  nb-layout.modal-drop .layout{position:relative;transition:transform .4s,opacity .4s;transition-timing-function:cubic-bezier(.4,0,.2,1)}  nb-layout.modal-drop.with-search .layout{opacity:0;transform:scale3d(.9,.9,1);pointer-events:none}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:100vh;background:none;pointer-events:none}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{content:"";position:absolute;top:0;right:0;width:100%;height:100%;opacity:0;transition:opacity .4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{font-size:2.5rem;position:absolute;top:3rem;display:block;opacity:0;transition:opacity .4s}[dir=ltr]   .modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{position:relative;margin:5rem 0 2rem}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:6vw;width:60%;padding:.25rem;text-align:center;opacity:0;transition:opacity .4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{position:relative;z-index:9;display:block;width:60%;padding:.85rem 0;opacity:0;transform:translate3d(0,-50px,0);transition:opacity .4s,transform .4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]{position:relative;z-index:10;overflow:hidden;transform:translate3d(0,-50px,0);transition:transform .4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]:after{content:"";position:absolute;top:0;left:20%;width:60%;height:105%;opacity:0;transform-origin:50% 0}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{opacity:1}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]{transform:translateZ(0);transition:none}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]:after{animation:_ngcontent-%COMP%_scaleUpDown .8s cubic-bezier(.4,0,.2,1) forwards}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{opacity:1;transition:opacity 0s .4s}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{opacity:1;transform:translateZ(0);transition-delay:.4s;transition-timing-function:ease-out}@keyframes _ngcontent-%COMP%_scaleUpDown{0%{opacity:1;transform:scale3d(1,0,1)}50%{transform:scaleZ(1);transform-origin:50% 0;transition-timing-function:ease-out}50.1%{transform-origin:50% 100%;transition-timing-function:ease-out}to{opacity:1;transform:scale3d(1,0,1);transform-origin:50% 100%;transition-timing-function:ease-out}}@media screen and (max-width: 40rem){.modal-drop[_nghost-%COMP%]   form[_ngcontent-%COMP%]{margin:2rem 0}.modal-drop[_nghost-%COMP%]   input[_ngcontent-%COMP%]{width:100%;left:0}}', '\n\n\n\n\n  nb-layout.modal-half .layout{transition:transform .6s,opacity .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}  nb-layout.modal-half.with-search .layout{transform:scale3d(.8,.8,1);pointer-events:none}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{text-align:center;position:fixed;z-index:1050;top:0;left:0;overflow:hidden;width:100%;height:100vh;background:none;pointer-events:none}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0;transition:opacity .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{font-size:2.5rem;position:absolute;top:3rem;display:block;z-index:100;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .6s,transform .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}[dir=ltr]   .modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-wrapper[_ngcontent-%COMP%]{position:absolute;display:flex;justify-content:center;align-items:center;width:100%;height:50%;transition:transform .6s;transition-timing-function:cubic-bezier(.2,1,.3,1);transform:translate3d(0,-100%,0)}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{width:75%;margin:0 auto}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:7vw;width:100%}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]:before{opacity:1}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scaleZ(1)}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-wrapper[_ngcontent-%COMP%]{transform:translateZ(0)}'],
  changeDetection: 0
});
var NbSearchFieldComponent = _NbSearchFieldComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSearchFieldComponent, [{
    type: Component,
    args: [{
      selector: "nb-search-field",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <div class="search" (keyup.esc)="emitClose()">
      <button (click)="emitClose()" nbButton ghost class="close-button">
        <nb-icon icon="close-outline" pack="nebular-essentials"></nb-icon>
      </button>
      <div class="form-wrapper">
        <form class="form" (keyup.enter)="submitSearch(searchInput.value)">
          <div class="form-content">
            <input class="search-input"
                   #searchInput
                   (input)="emitSearchInput(searchInput.value)"
                   autocomplete="off"
                   [attr.placeholder]="placeholder"
                   tabindex="-1"
                   (blur)="focusInput()"/>
          </div>
          <span class="info">{{ hint }}</span>
        </form>
      </div>
    </div>
  `,
      styles: ['/**\n* @license\n* Copyright Akveo. All Rights Reserved.\n* Licensed under the MIT License. See License.txt in the project root for license information.\n*//**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host button{margin:0;padding:0;cursor:pointer;border:none;background:none}:host button:focus{box-shadow:none;outline:none}:host input{border-top:0;border-right:0;border-left:0;background:transparent;border-radius:0;line-height:1;display:inline-block;box-sizing:border-box;padding:.05rem 0;-webkit-appearance:none}:host input:focus{outline:none}:host input::placeholder{opacity:.3}:host span{font-size:90%;font-weight:700;display:block;width:75%;margin:0 auto;padding:.85rem 0;text-align:right}:host.modal-zoomin{display:block}:host.modal-zoomin .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity .5s}:host.modal-zoomin .search:before,:host.modal-zoomin .search:after{content:"";position:absolute;width:calc(100% + 15px);height:calc(100% + 15px);pointer-events:none}:host.modal-zoomin .search:before{top:0;left:0;border-right-width:0;border-bottom-width:0;transform:translate3d(-15px,-15px,0)}:host.modal-zoomin .search:after{right:0;bottom:0;border-top-width:0;border-left-width:0;transform:translate3d(15px,15px,0)}:host.modal-zoomin .search button{position:absolute;top:3rem;font-size:2.5rem}[dir=ltr] :host.modal-zoomin .search button{right:3rem}[dir=rtl] :host.modal-zoomin .search button{left:3rem}:host.modal-zoomin .search input{font-size:10vw;width:75%}:host.modal-zoomin .search button{opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}:host.modal-zoomin .search form{opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}:host.modal-zoomin.show .search{pointer-events:auto;opacity:1}:host.modal-zoomin.show .search:before,:host.modal-zoomin.show .search:after{transform:translateZ(0);transition:transform .5s}:host.modal-zoomin.show .search button{opacity:1;transform:scaleZ(1)}:host.modal-zoomin.show .search form{opacity:1;transform:scaleZ(1)}@media screen and (max-width: 40rem){:host.modal-zoomin form{margin:5rem 0 1rem}:host.modal-zoomin span{text-align:left}}\n', "/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */::ng-deep nb-layout.rotate-layout{position:fixed;overflow:hidden;width:100%}::ng-deep nb-layout.rotate-layout .scrollable-container{position:relative;z-index:10001;transition:transform .5s cubic-bezier(.2,1,.3,1)}::ng-deep nb-layout.rotate-layout.with-search .scrollable-container{transition:transform .5s cubic-bezier(.2,1,.3,1);transform-origin:50vw 50vh;transform:perspective(1000px) translate3d(0,50vh,0) rotateX(30deg);pointer-events:none}:host.rotate-layout{position:absolute;display:block;width:100vw;height:100vh;pointer-events:none;opacity:0;transition-property:opacity;transition-delay:.4s}:host.rotate-layout .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:50vh;pointer-events:none;opacity:0;transition:opacity .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}:host.rotate-layout .search button{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}[dir=ltr] :host.rotate-layout .search button{right:3rem}[dir=rtl] :host.rotate-layout .search button{left:3rem}:host.rotate-layout .search form{margin:5rem 0;opacity:0;transform:scale3d(.7,.7,1);transition:opacity .5s,transform .5s;transition-timing-function:cubic-bezier(.2,1,.3,1)}:host.rotate-layout .search input{font-size:7vw;width:75%}:host.rotate-layout.show{opacity:1;transition-delay:0s}:host.rotate-layout.show .search{pointer-events:auto;opacity:1}:host.rotate-layout.show .search button{opacity:1;transform:scaleZ(1)}:host.rotate-layout.show .search form{opacity:1;transform:scaleZ(1)}\n", "/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */::ng-deep nb-layout.modal-move .layout{transition:transform .5s}::ng-deep nb-layout.modal-move.with-search .layout{transform:scale3d(.8,.8,1);pointer-events:none}:host.modal-move .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity .5s}:host.modal-move .search button{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transition:opacity .5s}[dir=ltr] :host.modal-move .search button{right:3rem}[dir=rtl] :host.modal-move .search button{left:3rem}:host.modal-move .search form{margin:5rem 0;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}:host.modal-move .search input{font-size:10vw;width:75%;transform:scale3d(0,1,1);transform-origin:0 50%;transition:transform .3s}:host.modal-move.show .search{pointer-events:auto;opacity:1}:host.modal-move.show .search button{opacity:1}:host.modal-move.show .search form{opacity:1;transform:scaleZ(1)}:host.modal-move.show .search input{transform:scaleZ(1);transition-duration:.5s}@media screen and (max-width: 40rem){:host.modal-move span{text-align:left}}\n", '/**\n* @license\n* Copyright Akveo. All Rights Reserved.\n* Licensed under the MIT License. See License.txt in the project root for license information.\n*//**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host.curtain .search{position:fixed;z-index:1050;top:0;left:100%;overflow:hidden;height:100vh;width:100%;padding:3rem;pointer-events:none;transition:transform .3s;transition-delay:.4s;transition-timing-function:ease-out}:host.curtain .search:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;transition:transform .3s;transition-timing-function:ease-out}:host.curtain .search button{font-size:2.5rem;position:absolute;top:3rem;transition:opacity .1s;transition-delay:.3s}[dir=ltr] :host.curtain .search button{right:3rem}[dir=rtl] :host.curtain .search button{left:3rem}:host.curtain .search form{width:50%;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .5s,transform .5s}:host.curtain .search input{width:100%;font-size:6vw}:host.curtain.show .search{width:100%;pointer-events:auto;transform:translate3d(-100%,0,0);transition-delay:0s}:host.curtain.show .search:after{transform:translate3d(100%,0,0);transition-delay:.4s}:host.curtain.show .search button{opacity:1;transform:scaleZ(1)}:host.curtain.show .search form{opacity:1;transform:scaleZ(1)}@media screen and (max-width: 40em){:host.curtain span{width:90%}:host.curtain input{font-size:2em;width:90%}}::ng-deep nb-layout.curtain .scrollable-container{position:relative;z-index:0}\n', '/**\n* @license\n* Copyright Akveo. All Rights Reserved.\n* Licensed under the MIT License. See License.txt in the project root for license information.\n*//**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */::ng-deep nb-layout.column-curtain.with-search .layout{pointer-events:none}:host.column-curtain{display:block;position:fixed;z-index:1050;top:0;left:50%;overflow:hidden;width:50%;height:100vh;pointer-events:none}:host.column-curtain:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;transform:scale3d(0,1,1);transform-origin:0 50%;transition:transform .3s;transition-timing-function:cubic-bezier(.86,0,.07,1)}:host.column-curtain .search{position:relative;padding:2.5rem 1.5rem 0;background:transparent}:host.column-curtain .search button{position:absolute;top:2rem;font-size:2.5rem;opacity:0;transition:opacity .5s}[dir=ltr] :host.column-curtain .search button{right:2rem}[dir=rtl] :host.column-curtain .search button{left:2rem}:host.column-curtain .search form{width:85%;transform:translate3d(-150%,0,0);transition:transform .3s}:host.column-curtain .search input{font-size:2.5rem;width:100%}:host.column-curtain .search span{font-size:85%}:host.column-curtain.show{pointer-events:auto}:host.column-curtain.show:before{transform:scaleZ(1)}:host.column-curtain.show .search form{transform:translateZ(0);transition-delay:.15s;transition-timing-function:cubic-bezier(.86,0,.07,1)}:host.column-curtain.show .search button{opacity:1;z-index:100}@media screen and (max-width: 40rem){:host.column-curtain span{width:90%}:host.column-curtain input{font-size:2rem;width:90%}}\n', '/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */::ng-deep nb-layout.modal-drop .layout{position:relative;transition:transform .4s,opacity .4s;transition-timing-function:cubic-bezier(.4,0,.2,1)}::ng-deep nb-layout.modal-drop.with-search .layout{opacity:0;transform:scale3d(.9,.9,1);pointer-events:none}:host.modal-drop .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:100vh;background:none;pointer-events:none}:host.modal-drop .search:before{content:"";position:absolute;top:0;right:0;width:100%;height:100%;opacity:0;transition:opacity .4s}:host.modal-drop .search button{font-size:2.5rem;position:absolute;top:3rem;display:block;opacity:0;transition:opacity .4s}[dir=ltr] :host.modal-drop .search button{right:3rem}[dir=rtl] :host.modal-drop .search button{left:3rem}:host.modal-drop .search form{position:relative;margin:5rem 0 2rem}:host.modal-drop .search input{font-size:6vw;width:60%;padding:.25rem;text-align:center;opacity:0;transition:opacity .4s}:host.modal-drop .search span{position:relative;z-index:9;display:block;width:60%;padding:.85rem 0;opacity:0;transform:translate3d(0,-50px,0);transition:opacity .4s,transform .4s}:host.modal-drop .search .form-content{position:relative;z-index:10;overflow:hidden;transform:translate3d(0,-50px,0);transition:transform .4s}:host.modal-drop .search .form-content:after{content:"";position:absolute;top:0;left:20%;width:60%;height:105%;opacity:0;transform-origin:50% 0}:host.modal-drop.show .search{pointer-events:auto}:host.modal-drop.show .search:before{opacity:1}:host.modal-drop.show .search button{opacity:1}:host.modal-drop.show .search .form-content{transform:translateZ(0);transition:none}:host.modal-drop.show .search .form-content:after{animation:scaleUpDown .8s cubic-bezier(.4,0,.2,1) forwards}:host.modal-drop.show .search input{opacity:1;transition:opacity 0s .4s}:host.modal-drop.show .search span{opacity:1;transform:translateZ(0);transition-delay:.4s;transition-timing-function:ease-out}@keyframes scaleUpDown{0%{opacity:1;transform:scale3d(1,0,1)}50%{transform:scaleZ(1);transform-origin:50% 0;transition-timing-function:ease-out}50.1%{transform-origin:50% 100%;transition-timing-function:ease-out}to{opacity:1;transform:scale3d(1,0,1);transform-origin:50% 100%;transition-timing-function:ease-out}}@media screen and (max-width: 40rem){:host.modal-drop form{margin:2rem 0}:host.modal-drop input{width:100%;left:0}}\n', '/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */::ng-deep nb-layout.modal-half .layout{transition:transform .6s,opacity .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}::ng-deep nb-layout.modal-half.with-search .layout{transform:scale3d(.8,.8,1);pointer-events:none}:host.modal-half .search{text-align:center;position:fixed;z-index:1050;top:0;left:0;overflow:hidden;width:100%;height:100vh;background:none;pointer-events:none}:host.modal-half .search:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0;transition:opacity .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}:host.modal-half .search button{font-size:2.5rem;position:absolute;top:3rem;display:block;z-index:100;opacity:0;transform:scale3d(.8,.8,1);transition:opacity .6s,transform .6s;transition-timing-function:cubic-bezier(.2,1,.3,1)}[dir=ltr] :host.modal-half .search button{right:3rem}[dir=rtl] :host.modal-half .search button{left:3rem}:host.modal-half .search .form-wrapper{position:absolute;display:flex;justify-content:center;align-items:center;width:100%;height:50%;transition:transform .6s;transition-timing-function:cubic-bezier(.2,1,.3,1);transform:translate3d(0,-100%,0)}:host.modal-half .search form{width:75%;margin:0 auto}:host.modal-half .search input{font-size:7vw;width:100%}:host.modal-half.show .search{pointer-events:auto}:host.modal-half.show .search:before{opacity:1}:host.modal-half.show .search button{opacity:1;transform:scaleZ(1)}:host.modal-half.show .search .form-wrapper{transform:translateZ(0)}\n']
    }]
  }], null, {
    type: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    hint: [{
      type: Input
    }],
    show: [{
      type: Input
    }],
    close: [{
      type: Output
    }],
    search: [{
      type: Output
    }],
    searchInput: [{
      type: Output
    }],
    inputElement: [{
      type: ViewChild,
      args: ["searchInput"]
    }],
    showClass: [{
      type: HostBinding,
      args: ["class.show"]
    }],
    modalZoomin: [{
      type: HostBinding,
      args: ["class.modal-zoomin"]
    }],
    rotateLayout: [{
      type: HostBinding,
      args: ["class.rotate-layout"]
    }],
    modalMove: [{
      type: HostBinding,
      args: ["class.modal-move"]
    }],
    curtain: [{
      type: HostBinding,
      args: ["class.curtain"]
    }],
    columnCurtain: [{
      type: HostBinding,
      args: ["class.column-curtain"]
    }],
    modalDrop: [{
      type: HostBinding,
      args: ["class.modal-drop"]
    }],
    modalHalf: [{
      type: HostBinding,
      args: ["class.modal-half"]
    }]
  });
})();
var _NbSearchComponent = class _NbSearchComponent {
  constructor(searchService, themeService, router, overlayService, changeDetector) {
    this.searchService = searchService;
    this.themeService = themeService;
    this.router = router;
    this.overlayService = overlayService;
    this.changeDetector = changeDetector;
    this.destroy$ = new Subject();
    this.showSearchField = false;
    this.placeholder = "Search...";
    this.hint = "Hit enter to search";
  }
  ngOnInit() {
    this.router.events.pipe(filter((event) => event instanceof NavigationEnd), takeUntil(this.destroy$)).subscribe(() => this.hideSearch());
    this.searchService.onSearchActivate().pipe(filter((data) => !this.tag || data.tag === this.tag), takeUntil(this.destroy$)).subscribe(() => this.openSearch());
    this.searchService.onSearchDeactivate().pipe(filter((data) => !this.tag || data.tag === this.tag), takeUntil(this.destroy$)).subscribe(() => this.hideSearch());
  }
  ngOnDestroy() {
    if (this.overlayRef && this.overlayRef.hasAttached()) {
      this.removeLayoutClasses();
      this.overlayRef.detach();
    }
    this.destroy$.next();
    this.destroy$.complete();
  }
  openSearch() {
    if (!this.overlayRef) {
      this.overlayRef = this.overlayService.create();
      this.overlayRef.attach(this.searchFieldPortal);
    }
    this.themeService.appendLayoutClass(this.type);
    of(null).pipe(delay(0)).subscribe(() => {
      this.themeService.appendLayoutClass("with-search");
      this.showSearchField = true;
      this.changeDetector.detectChanges();
    });
  }
  hideSearch() {
    this.removeLayoutClasses();
    this.showSearchField = false;
    this.changeDetector.detectChanges();
    this.searchButton.nativeElement.focus();
  }
  search(term) {
    this.searchService.submitSearch(term, this.tag);
    this.hideSearch();
  }
  emitInput(term) {
    this.searchService.searchInput(term, this.tag);
  }
  emitActivate() {
    this.searchService.activateSearch(this.type, this.tag);
  }
  emitDeactivate() {
    this.searchService.deactivateSearch(this.type, this.tag);
  }
  removeLayoutClasses() {
    this.themeService.removeLayoutClass("with-search");
    of(null).pipe(delay(500)).subscribe(() => {
      this.themeService.removeLayoutClass(this.type);
    });
  }
};
_NbSearchComponent.ɵfac = function NbSearchComponent_Factory(t) {
  return new (t || _NbSearchComponent)(ɵɵdirectiveInject(NbSearchService), ɵɵdirectiveInject(NbThemeService), ɵɵdirectiveInject(Router), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbSearchComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSearchComponent,
  selectors: [["nb-search"]],
  viewQuery: function NbSearchComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbPortalDirective, 5);
      ɵɵviewQuery(_c25, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.searchFieldPortal = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.searchButton = _t.first);
    }
  },
  inputs: {
    tag: "tag",
    placeholder: "placeholder",
    hint: "hint",
    type: "type"
  },
  decls: 4,
  vars: 0,
  consts: [["nbButton", "", "ghost", "", 1, "start-search", 3, "click"], ["searchButton", ""], ["icon", "search-outline", "pack", "nebular-essentials"], [3, "show", "type", "placeholder", "hint", "search", "searchInput", "close", 4, "nbPortal"], [3, "show", "type", "placeholder", "hint", "search", "searchInput", "close"]],
  template: function NbSearchComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "button", 0, 1);
      ɵɵlistener("click", function NbSearchComponent_Template_button_click_0_listener() {
        return ctx.emitActivate();
      });
      ɵɵelement(2, "nb-icon", 2);
      ɵɵelementEnd();
      ɵɵtemplate(3, NbSearchComponent_nb_search_field_3_Template, 1, 4, "nb-search-field", 3);
    }
  },
  dependencies: [NbPortalDirective, NbIconComponent, NbButtonComponent, NbSearchFieldComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]   button[_ngcontent-%COMP%]{font-size:2rem;margin:0 auto;padding:0;cursor:pointer;border:none;background:none}[_nghost-%COMP%]   button[_ngcontent-%COMP%]:focus{box-shadow:none;outline:none}  nb-layout.with-search .scrollable-container{position:relative;z-index:0}"],
  changeDetection: 0
});
var NbSearchComponent = _NbSearchComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSearchComponent, [{
    type: Component,
    args: [{
      selector: "nb-search",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <button #searchButton class="start-search" (click)="emitActivate()" nbButton ghost>
      <nb-icon icon="search-outline" pack="nebular-essentials"></nb-icon>
    </button>
    <nb-search-field
      *nbPortal
      [show]="showSearchField"
      [type]="type"
      [placeholder]="placeholder"
      [hint]="hint"
      (search)="search($event)"
      (searchInput)="emitInput($event)"
      (close)="emitDeactivate()">
    </nb-search-field>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host button{font-size:2rem;margin:0 auto;padding:0;cursor:pointer;border:none;background:none}:host button:focus{box-shadow:none;outline:none}::ng-deep nb-layout.with-search .scrollable-container{position:relative;z-index:0}\n"]
    }]
  }], () => [{
    type: NbSearchService
  }, {
    type: NbThemeService
  }, {
    type: Router
  }, {
    type: NbOverlayService
  }, {
    type: ChangeDetectorRef
  }], {
    tag: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    hint: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    searchFieldPortal: [{
      type: ViewChild,
      args: [NbPortalDirective]
    }],
    searchButton: [{
      type: ViewChild,
      args: ["searchButton", {
        read: ElementRef
      }]
    }]
  });
})();
var _NbSearchModule = class _NbSearchModule {
};
_NbSearchModule.ɵfac = function NbSearchModule_Factory(t) {
  return new (t || _NbSearchModule)();
};
_NbSearchModule.ɵmod = ɵɵdefineNgModule({
  type: _NbSearchModule,
  declarations: [NbSearchComponent, NbSearchFieldComponent],
  imports: [NbSharedModule, NbOverlayModule, NbIconModule, NbButtonModule],
  exports: [NbSearchComponent, NbSearchFieldComponent]
});
_NbSearchModule.ɵinj = ɵɵdefineInjector({
  providers: [NbSearchService],
  imports: [NbSharedModule, NbOverlayModule, NbIconModule, NbButtonModule]
});
var NbSearchModule = _NbSearchModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSearchModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbIconModule, NbButtonModule],
      declarations: [NbSearchComponent, NbSearchFieldComponent],
      exports: [NbSearchComponent, NbSearchFieldComponent],
      providers: [NbSearchService]
    }]
  }], null, null);
})();
var _NbCheckboxComponent = class _NbCheckboxComponent {
  get checked() {
    return this._checked;
  }
  set checked(value) {
    this._checked = convertToBoolProperty(value);
  }
  /**
   * Controls input disabled state
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  /**
   * Controls checkbox indeterminate state
   */
  get indeterminate() {
    return this._indeterminate;
  }
  set indeterminate(value) {
    this._indeterminate = convertToBoolProperty(value);
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get info() {
    return this.status === "info";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(changeDetector, renderer, hostElement, zone, statusService) {
    this.changeDetector = changeDetector;
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.zone = zone;
    this.statusService = statusService;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this._checked = false;
    this._disabled = false;
    this.status = "basic";
    this._indeterminate = false;
    this.checkedChange = new EventEmitter();
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostElement.nativeElement, "nb-transition");
    }));
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  writeValue(val) {
    this._checked = val;
    this.changeDetector.markForCheck();
  }
  setDisabledState(val) {
    this.disabled = convertToBoolProperty(val);
    this.changeDetector.markForCheck();
  }
  setTouched() {
    this.onTouched();
  }
  updateValueAndIndeterminate(event) {
    const input = event.target;
    this.checked = input.checked;
    this.checkedChange.emit(this.checked);
    this.onChange(this.checked);
    this.indeterminate = input.indeterminate;
  }
};
_NbCheckboxComponent.ɵfac = function NbCheckboxComponent_Factory(t) {
  return new (t || _NbCheckboxComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
};
_NbCheckboxComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbCheckboxComponent,
  selectors: [["nb-checkbox"]],
  hostVars: 16,
  hostBindings: function NbCheckboxComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("status-primary", ctx.primary)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-info", ctx.info)("status-basic", ctx.basic)("status-control", ctx.control);
    }
  },
  inputs: {
    checked: "checked",
    disabled: "disabled",
    status: "status",
    indeterminate: "indeterminate"
  },
  outputs: {
    checkedChange: "checkedChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbCheckboxComponent),
    multi: true
  }])],
  ngContentSelectors: _c02,
  decls: 7,
  vars: 9,
  consts: [[1, "label"], ["type", "checkbox", 1, "native-input", "visually-hidden", 3, "disabled", "checked", "indeterminate", "change", "blur", "click"], [1, "custom-checkbox"], ["icon", "minus-bold-outline", "pack", "nebular-essentials", "class", "custom-checkbox-icon", 4, "ngIf"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials", "class", "custom-checkbox-icon", 4, "ngIf"], [1, "text"], ["icon", "minus-bold-outline", "pack", "nebular-essentials", 1, "custom-checkbox-icon"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials", 1, "custom-checkbox-icon"]],
  template: function NbCheckboxComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "label", 0)(1, "input", 1);
      ɵɵlistener("change", function NbCheckboxComponent_Template_input_change_1_listener($event) {
        return ctx.updateValueAndIndeterminate($event);
      })("blur", function NbCheckboxComponent_Template_input_blur_1_listener() {
        return ctx.setTouched();
      })("click", function NbCheckboxComponent_Template_input_click_1_listener($event) {
        return $event.stopPropagation();
      });
      ɵɵelementEnd();
      ɵɵelementStart(2, "span", 2);
      ɵɵtemplate(3, NbCheckboxComponent_nb_icon_3_Template, 1, 0, "nb-icon", 3)(4, NbCheckboxComponent_nb_icon_4_Template, 1, 0, "nb-icon", 4);
      ɵɵelementEnd();
      ɵɵelementStart(5, "span", 5);
      ɵɵprojection(6);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("disabled", ctx.disabled)("checked", ctx.checked)("indeterminate", ctx.indeterminate);
      ɵɵadvance();
      ɵɵclassProp("indeterminate", ctx.indeterminate)("checked", ctx.checked);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.indeterminate);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.checked && !ctx.indeterminate);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]   .label[_ngcontent-%COMP%]{position:relative;display:inline-flex;align-items:center;margin:0;min-height:inherit}[_nghost-%COMP%]   .custom-checkbox[_ngcontent-%COMP%]{flex-shrink:0}.nb-transition[_nghost-%COMP%]   .custom-checkbox[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}.nb-transition[_nghost-%COMP%]   .text[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:color;transition-timing-function:ease-in}"],
  changeDetection: 0
});
var NbCheckboxComponent = _NbCheckboxComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCheckboxComponent, [{
    type: Component,
    args: [{
      selector: "nb-checkbox",
      template: `
    <label class="label">
      <input type="checkbox" class="native-input visually-hidden"
             [disabled]="disabled"
             [checked]="checked"
             (change)="updateValueAndIndeterminate($event)"
             (blur)="setTouched()"
             (click)="$event.stopPropagation()"
             [indeterminate]="indeterminate">
      <span [class.indeterminate]="indeterminate" [class.checked]="checked" class="custom-checkbox">
        <nb-icon *ngIf="indeterminate" icon="minus-bold-outline" pack="nebular-essentials" class="custom-checkbox-icon"></nb-icon>
        <nb-icon *ngIf="checked && !indeterminate" icon="checkmark-bold-outline" pack="nebular-essentials" class="custom-checkbox-icon"></nb-icon>
      </span>
      <span class="text">
        <ng-content></ng-content>
      </span>
    </label>
  `,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbCheckboxComponent),
        multi: true
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host .label{position:relative;display:inline-flex;align-items:center;margin:0;min-height:inherit}:host .custom-checkbox{flex-shrink:0}:host(.nb-transition) .custom-checkbox{transition-duration:.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}:host(.nb-transition) .text{transition-duration:.15s;transition-property:color;transition-timing-function:ease-in}\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    checked: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    indeterminate: [{
      type: Input
    }],
    checkedChange: [{
      type: Output
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbCheckboxModule = class _NbCheckboxModule {
};
_NbCheckboxModule.ɵfac = function NbCheckboxModule_Factory(t) {
  return new (t || _NbCheckboxModule)();
};
_NbCheckboxModule.ɵmod = ɵɵdefineNgModule({
  type: _NbCheckboxModule,
  declarations: [NbCheckboxComponent],
  imports: [NbSharedModule, NbIconModule],
  exports: [NbCheckboxComponent]
});
_NbCheckboxModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbIconModule]
});
var NbCheckboxModule = _NbCheckboxModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCheckboxModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule],
      declarations: [NbCheckboxComponent],
      exports: [NbCheckboxComponent]
    }]
  }], null, null);
})();
var _NbDynamicOverlay = class _NbDynamicOverlay {
  get isAttached() {
    return this.ref && this.ref.hasAttached();
  }
  get isShown() {
    return this.isShown$.pipe(distinctUntilChanged());
  }
  constructor(overlay, componentFactoryResolver, zone, overlayContainer) {
    this.overlay = overlay;
    this.componentFactoryResolver = componentFactoryResolver;
    this.zone = zone;
    this.overlayContainer = overlayContainer;
    this.context = {};
    this.overlayConfig = {};
    this.disabled = false;
    this.positionStrategyChange$ = new Subject();
    this.isShown$ = new BehaviorSubject(false);
    this.destroy$ = new Subject();
    this.overlayDestroy$ = new Subject();
  }
  create(componentType, content, context, positionStrategy, overlayConfig = {}, disabled = false) {
    this.setContentAndContext(content, context);
    this.setComponent(componentType);
    this.setPositionStrategy(positionStrategy);
    this.setOverlayConfig(overlayConfig);
    this.setDisabled(disabled);
    return this;
  }
  setContent(content) {
    this.content = content;
    if (this.container) {
      this.updateContext();
    }
    this.updatePosition();
  }
  setContext(context) {
    this.context = context;
    if (this.container) {
      this.updateContext();
    }
    this.updatePosition();
  }
  setContentAndContext(content, context) {
    this.content = content;
    this.context = context;
    if (this.container) {
      this.updateContext();
    }
    this.updatePosition();
  }
  setComponent(componentType) {
    this.componentType = componentType;
    const wasAttached = this.isAttached;
    this.disposeOverlayRef();
    if (wasAttached) {
      this.show();
    }
  }
  setPositionStrategy(positionStrategy) {
    this.positionStrategyChange$.next();
    this.positionStrategy = positionStrategy;
    this.positionStrategy.positionChange.pipe(filter(() => !!this.container), takeUntil(merge(this.positionStrategyChange$, this.destroy$))).subscribe((position) => {
      this.lastAppliedPosition = position;
      patch(this.container, {
        position
      });
    });
    if (this.ref) {
      this.ref.updatePositionStrategy(this.positionStrategy);
    }
  }
  setOverlayConfig(overlayConfig) {
    this.overlayConfig = overlayConfig;
    const wasAttached = this.isAttached;
    this.disposeOverlayRef();
    if (wasAttached) {
      this.show();
    }
  }
  setDisabled(disabled) {
    if (disabled && this.isShown$.value) {
      this.hide();
    }
    this.disabled = disabled;
  }
  show() {
    if (this.disabled) {
      return;
    }
    if (!this.ref) {
      this.createOverlay();
    }
    this.renderContainer();
    if (!this.hasOverlayInContainer()) {
      this.disposeOverlayRef();
      return this.show();
    }
    this.isShown$.next(true);
  }
  hide() {
    if (!this.ref) {
      return;
    }
    this.ref.detach();
    this.container = null;
    this.isShown$.next(false);
  }
  toggle() {
    if (this.isAttached) {
      this.hide();
    } else {
      this.show();
    }
  }
  dispose() {
    this.destroy$.next();
    this.destroy$.complete();
    this.hide();
    this.disposeOverlayRef();
    this.isShown$.complete();
    this.positionStrategyChange$.complete();
    this.overlayDestroy$.complete();
  }
  getContainer() {
    return this.container;
  }
  createOverlay() {
    this.ref = this.overlay.create(__spreadValues({
      positionStrategy: this.positionStrategy,
      scrollStrategy: this.overlay.scrollStrategies.reposition()
    }, this.overlayConfig));
    this.updatePositionWhenStable(this.ref);
  }
  renderContainer() {
    const containerContext = this.createContainerContext();
    if (!this.container) {
      this.container = createContainer(this.ref, this.componentType, containerContext, this.componentFactoryResolver);
    }
    this.container.instance.renderContent();
  }
  updateContext() {
    const containerContext = this.createContainerContext();
    Object.assign(this.container.instance, containerContext);
    this.container.instance.renderContent();
    this.container.changeDetectorRef.detectChanges();
  }
  createContainerContext() {
    return {
      content: this.content,
      context: this.context,
      cfr: this.componentFactoryResolver,
      position: this.lastAppliedPosition
    };
  }
  /**
   * Dimensions of the container may change after content update. So we listen to zone.stable event to
   * reposition the container.
   */
  updatePositionWhenStable(overlay) {
    const overlayDestroy$ = this.overlayDestroy$.pipe(filter((destroyedOverlay) => destroyedOverlay === overlay));
    this.zone.onStable.pipe(take(1), takeUntil(merge(this.destroy$, overlayDestroy$))).subscribe(() => this.updatePosition());
  }
  updatePosition() {
    if (this.ref) {
      this.ref.updatePosition();
    }
  }
  hasOverlayInContainer() {
    return this.overlayContainer.getContainerElement().contains(this.ref.hostElement);
  }
  disposeOverlayRef() {
    if (this.ref) {
      this.ref.dispose();
      this.overlayDestroy$.next(this.ref);
      this.ref = null;
      this.container = null;
    }
  }
};
_NbDynamicOverlay.ɵfac = function NbDynamicOverlay_Factory(t) {
  return new (t || _NbDynamicOverlay)(ɵɵinject(NbOverlayService), ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(NgZone), ɵɵinject(NbOverlayContainer));
};
_NbDynamicOverlay.ɵprov = ɵɵdefineInjectable({
  token: _NbDynamicOverlay,
  factory: _NbDynamicOverlay.ɵfac
});
var NbDynamicOverlay = _NbDynamicOverlay;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDynamicOverlay, [{
    type: Injectable
  }], () => [{
    type: NbOverlayService
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: NgZone
  }, {
    type: NbOverlayContainer
  }], null);
})();
var NbDynamicOverlayChange = class extends SimpleChange {
  constructor(previousValue, currentValue, firstChange = false) {
    super(previousValue, currentValue, firstChange);
  }
  isChanged() {
    return this.currentValue !== this.previousValue;
  }
};
var _NbDynamicOverlayHandler = class _NbDynamicOverlayHandler {
  constructor(positionBuilder, triggerStrategyBuilder, dynamicOverlayService, directionService) {
    this.positionBuilder = positionBuilder;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.dynamicOverlayService = dynamicOverlayService;
    this.directionService = directionService;
    this._context = {};
    this._trigger = NbTrigger.NOOP;
    this._disabled = false;
    this._position = NbPosition.TOP;
    this._adjustment = NbAdjustment.NOOP;
    this._offset = 15;
    this._overlayConfig = {};
    this.changes = {};
    this.destroy$ = new Subject();
  }
  host(host) {
    this.changes.host = new NbDynamicOverlayChange(this._host, host);
    this._host = host;
    return this;
  }
  trigger(trigger2) {
    this.changes.trigger = new NbDynamicOverlayChange(this._trigger, trigger2);
    this._trigger = trigger2;
    return this;
  }
  disabled(disabled) {
    this.changes.disabled = new NbDynamicOverlayChange(this._disabled, disabled);
    this._disabled = disabled;
    return this;
  }
  position(position) {
    this.changes.position = new NbDynamicOverlayChange(this._position, position);
    this._position = position;
    return this;
  }
  adjustment(adjustment) {
    this.changes.adjustment = new NbDynamicOverlayChange(this._adjustment, adjustment);
    this._adjustment = adjustment;
    return this;
  }
  componentType(componentType) {
    this.changes.componentType = new NbDynamicOverlayChange(this._componentType, componentType);
    this._componentType = componentType;
    return this;
  }
  content(content) {
    this.changes.content = new NbDynamicOverlayChange(this._content, content);
    this._content = content;
    return this;
  }
  context(context) {
    this.changes.context = new NbDynamicOverlayChange(this._context, context);
    this._context = context;
    return this;
  }
  offset(offset) {
    this.changes.offset = new NbDynamicOverlayChange(this._offset, offset);
    this._offset = offset;
    return this;
  }
  overlayConfig(overlayConfig) {
    this.changes.overlayConfig = new NbDynamicOverlayChange(this._overlayConfig, overlayConfig);
    this._overlayConfig = overlayConfig;
    return this;
  }
  build() {
    if (!this._componentType || !this._host) {
      throw Error(`NbDynamicOverlayHandler: at least 'componentType' and 'host' should be
      passed before building a dynamic overlay.`);
    }
    this.dynamicOverlay = this.dynamicOverlayService.create(this._componentType, this._content, this._context, this.createPositionStrategy(), this._overlayConfig, this._disabled);
    this.connect();
    this.clearChanges();
    return this.dynamicOverlay;
  }
  rebuild() {
    if (!this.dynamicOverlay) {
      return void 0;
    }
    if (this.isPositionStrategyUpdateRequired()) {
      this.dynamicOverlay.setPositionStrategy(this.createPositionStrategy());
    }
    if (this.isTriggerStrategyUpdateRequired()) {
      this.connect();
    }
    if (this.isContainerRerenderRequired()) {
      this.dynamicOverlay.setContentAndContext(this._content, this._context);
    }
    if (this.isComponentTypeUpdateRequired()) {
      this.dynamicOverlay.setComponent(this._componentType);
    }
    if (this.isOverlayConfigUpdateRequired()) {
      this.dynamicOverlay.setOverlayConfig(this._overlayConfig);
    }
    if (this.isDisabledUpdated()) {
      this.dynamicOverlay.setDisabled(this._disabled);
    }
    this.clearChanges();
    return this.dynamicOverlay;
  }
  connect() {
    if (!this.dynamicOverlay) {
      throw new Error(`NbDynamicOverlayHandler: cannot connect to DynamicOverlay
      as it is not created yet. Call build() first`);
    }
    this.disconnect();
    this.subscribeOnTriggers(this.dynamicOverlay);
    this.subscribeOnDirectionChange();
  }
  disconnect() {
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
  }
  destroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.disconnect();
    this.clearChanges();
    if (this.dynamicOverlay) {
      this.dynamicOverlay.dispose();
    }
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this._host).position(this._position).adjustment(this._adjustment).offset(this._offset).direction(this.directionService.getDirection());
  }
  subscribeOnTriggers(dynamicOverlay) {
    this.triggerStrategy = this.triggerStrategyBuilder.trigger(this._trigger).host(this._host.nativeElement).container(() => dynamicOverlay.getContainer()).build();
    this.triggerStrategy.show$.subscribe(() => dynamicOverlay.show());
    this.triggerStrategy.hide$.subscribe(() => dynamicOverlay.hide());
  }
  subscribeOnDirectionChange() {
    this.directionService.onDirectionChange().pipe(skip(1), takeUntil(this.destroy$)).subscribe(() => {
      this.dynamicOverlay.setPositionStrategy(this.createPositionStrategy());
    });
  }
  isContainerRerenderRequired() {
    return this.isContentUpdated() || this.isContextUpdated() || this.isPositionStrategyUpdateRequired();
  }
  isPositionStrategyUpdateRequired() {
    return this.isAdjustmentUpdated() || this.isPositionUpdated() || this.isOffsetUpdated() || this.isHostUpdated();
  }
  isTriggerStrategyUpdateRequired() {
    return this.isTriggerUpdated() || this.isHostUpdated();
  }
  isComponentTypeUpdateRequired() {
    return this.isComponentTypeUpdated();
  }
  isOverlayConfigUpdateRequired() {
    return this.isOverlayConfigUpdated();
  }
  isComponentTypeUpdated() {
    return this.changes.componentType && this.changes.componentType.isChanged();
  }
  isContentUpdated() {
    return this.changes.content && this.changes.content.isChanged();
  }
  isContextUpdated() {
    return this.changes.context && this.changes.context.isChanged();
  }
  isAdjustmentUpdated() {
    return this.changes.adjustment && this.changes.adjustment.isChanged();
  }
  isPositionUpdated() {
    return this.changes.position && this.changes.position.isChanged();
  }
  isHostUpdated() {
    return this.changes.host && this.changes.host.isChanged();
  }
  isTriggerUpdated() {
    return this.changes.trigger && this.changes.trigger.isChanged();
  }
  isOffsetUpdated() {
    return this.changes.offset && this.changes.offset.isChanged();
  }
  isOverlayConfigUpdated() {
    return this.changes.overlayConfig && this.changes.overlayConfig.isChanged();
  }
  isDisabledUpdated() {
    return this.changes.disabled && this.changes.disabled.isChanged();
  }
  clearChanges() {
    this.changes = {};
  }
};
_NbDynamicOverlayHandler.ɵfac = function NbDynamicOverlayHandler_Factory(t) {
  return new (t || _NbDynamicOverlayHandler)(ɵɵinject(NbPositionBuilderService), ɵɵinject(NbTriggerStrategyBuilderService), ɵɵinject(NbDynamicOverlay), ɵɵinject(NbLayoutDirectionService));
};
_NbDynamicOverlayHandler.ɵprov = ɵɵdefineInjectable({
  token: _NbDynamicOverlayHandler,
  factory: _NbDynamicOverlayHandler.ɵfac
});
var NbDynamicOverlayHandler = _NbDynamicOverlayHandler;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDynamicOverlayHandler, [{
    type: Injectable
  }], () => [{
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbDynamicOverlay
  }, {
    type: NbLayoutDirectionService
  }], null);
})();
var _NbPopoverComponent = class _NbPopoverComponent extends NbPositionedContainerComponent {
  renderContent() {
    this.detachContent();
    this.attachContent();
  }
  detachContent() {
    this.overlayContainer.detach();
  }
  attachContent() {
    if (this.content instanceof TemplateRef) {
      this.attachTemplate();
    } else if (this.content instanceof Type) {
      this.attachComponent();
    } else {
      this.attachString();
    }
  }
  attachTemplate() {
    this.overlayContainer.attachTemplatePortal(new NbTemplatePortal(this.content, null, {
      $implicit: this.context
    }));
  }
  attachComponent() {
    const portal = new NbComponentPortal(this.content, null, null, this.cfr);
    const ref = this.overlayContainer.attachComponentPortal(portal, this.context);
    ref.changeDetectorRef.detectChanges();
  }
  attachString() {
    this.overlayContainer.attachStringContent(this.content);
  }
};
_NbPopoverComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbPopoverComponent_BaseFactory;
  return function NbPopoverComponent_Factory(t) {
    return (ɵNbPopoverComponent_BaseFactory || (ɵNbPopoverComponent_BaseFactory = ɵɵgetInheritedFactory(_NbPopoverComponent)))(t || _NbPopoverComponent);
  };
})();
_NbPopoverComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbPopoverComponent,
  selectors: [["nb-popover"]],
  viewQuery: function NbPopoverComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbOverlayContainerComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.overlayContainer = _t.first);
    }
  },
  inputs: {
    content: "content",
    context: "context",
    cfr: "cfr"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 2,
  vars: 0,
  consts: [[1, "arrow"]],
  template: function NbPopoverComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "span", 0)(1, "nb-overlay-container");
    }
  },
  dependencies: [NbOverlayContainerComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{position:absolute;width:0;height:0}"]
});
var NbPopoverComponent = _NbPopoverComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPopoverComponent, [{
    type: Component,
    args: [{
      selector: "nb-popover",
      template: `
    <span class="arrow"></span>
    <nb-overlay-container></nb-overlay-container>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host .arrow{position:absolute;width:0;height:0}\n"]
    }]
  }], null, {
    overlayContainer: [{
      type: ViewChild,
      args: [NbOverlayContainerComponent]
    }],
    content: [{
      type: Input
    }],
    context: [{
      type: Input
    }],
    cfr: [{
      type: Input
    }]
  });
})();
var _NbPopoverDirective = class _NbPopoverDirective {
  /**
   * Container position will be changes automatically based on this strategy if container can't fit view port.
   * Set this property to `noop` value if you want to disable automatically adjustment.
   * Available values: `clockwise` (default), `counterclockwise`, `vertical`, `horizontal`, `noop`.
   * */
  get adjustment() {
    return this._adjustment;
  }
  set adjustment(value) {
    this._adjustment = value;
  }
  get popoverClass() {
    return this._popoverClass;
  }
  set popoverClass(value) {
    if (value !== this.popoverClass) {
      this._popoverClass = value;
      this.overlayConfig = {
        panelClass: this.popoverClass
      };
    }
  }
  get isShown() {
    return !!(this.dynamicOverlay && this.dynamicOverlay.isAttached);
  }
  constructor(hostRef, dynamicOverlayHandler) {
    this.hostRef = hostRef;
    this.dynamicOverlayHandler = dynamicOverlayHandler;
    this.popoverComponent = NbPopoverComponent;
    this.destroy$ = new Subject();
    this.context = {};
    this.position = NbPosition.TOP;
    this._adjustment = NbAdjustment.CLOCKWISE;
    this.trigger = NbTrigger.CLICK;
    this.offset = 15;
    this.disabled = false;
    this._popoverClass = "";
    this.nbPopoverShowStateChange = new EventEmitter();
    this.overlayConfig = {
      panelClass: this.popoverClass
    };
  }
  ngOnInit() {
    this.dynamicOverlayHandler.host(this.hostRef).componentType(this.popoverComponent);
  }
  ngOnChanges() {
    this.rebuild();
  }
  ngAfterViewInit() {
    this.dynamicOverlay = this.configureDynamicOverlay().build();
    this.dynamicOverlay.isShown.pipe(skip(1), takeUntil(this.destroy$)).subscribe((isShown) => this.nbPopoverShowStateChange.emit({
      isShown
    }));
  }
  rebuild() {
    this.dynamicOverlay = this.configureDynamicOverlay().rebuild();
  }
  show() {
    this.dynamicOverlay.show();
  }
  hide() {
    this.dynamicOverlay.hide();
  }
  toggle() {
    this.dynamicOverlay.toggle();
  }
  ngOnDestroy() {
    this.dynamicOverlayHandler.destroy();
    this.destroy$.next();
    this.destroy$.complete();
  }
  configureDynamicOverlay() {
    return this.dynamicOverlayHandler.position(this.position).trigger(this.trigger).disabled(this.disabled).offset(this.offset).adjustment(this.adjustment).content(this.content).context(this.context).overlayConfig(this.overlayConfig);
  }
};
_NbPopoverDirective.ɵfac = function NbPopoverDirective_Factory(t) {
  return new (t || _NbPopoverDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbDynamicOverlayHandler));
};
_NbPopoverDirective.ɵdir = ɵɵdefineDirective({
  type: _NbPopoverDirective,
  selectors: [["", "nbPopover", ""]],
  inputs: {
    content: [InputFlags.None, "nbPopover", "content"],
    context: [InputFlags.None, "nbPopoverContext", "context"],
    position: [InputFlags.None, "nbPopoverPlacement", "position"],
    adjustment: [InputFlags.None, "nbPopoverAdjustment", "adjustment"],
    trigger: [InputFlags.None, "nbPopoverTrigger", "trigger"],
    offset: [InputFlags.None, "nbPopoverOffset", "offset"],
    disabled: [InputFlags.None, "nbTooltipDisabled", "disabled"],
    popoverClass: [InputFlags.None, "nbPopoverClass", "popoverClass"]
  },
  outputs: {
    nbPopoverShowStateChange: "nbPopoverShowStateChange"
  },
  exportAs: ["nbPopover"],
  features: [ɵɵProvidersFeature([NbDynamicOverlayHandler, NbDynamicOverlay]), ɵɵNgOnChangesFeature]
});
var NbPopoverDirective = _NbPopoverDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPopoverDirective, [{
    type: Directive,
    args: [{
      selector: "[nbPopover]",
      exportAs: "nbPopover",
      providers: [NbDynamicOverlayHandler, NbDynamicOverlay]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbDynamicOverlayHandler
  }], {
    content: [{
      type: Input,
      args: ["nbPopover"]
    }],
    context: [{
      type: Input,
      args: ["nbPopoverContext"]
    }],
    position: [{
      type: Input,
      args: ["nbPopoverPlacement"]
    }],
    adjustment: [{
      type: Input,
      args: ["nbPopoverAdjustment"]
    }],
    trigger: [{
      type: Input,
      args: ["nbPopoverTrigger"]
    }],
    offset: [{
      type: Input,
      args: ["nbPopoverOffset"]
    }],
    disabled: [{
      type: Input,
      args: ["nbTooltipDisabled"]
    }],
    popoverClass: [{
      type: Input,
      args: ["nbPopoverClass"]
    }],
    nbPopoverShowStateChange: [{
      type: Output
    }]
  });
})();
var _NbPopoverModule = class _NbPopoverModule {
};
_NbPopoverModule.ɵfac = function NbPopoverModule_Factory(t) {
  return new (t || _NbPopoverModule)();
};
_NbPopoverModule.ɵmod = ɵɵdefineNgModule({
  type: _NbPopoverModule,
  declarations: [NbPopoverDirective, NbPopoverComponent],
  imports: [NbOverlayModule],
  exports: [NbPopoverDirective]
});
_NbPopoverModule.ɵinj = ɵɵdefineInjector({
  imports: [NbOverlayModule]
});
var NbPopoverModule = _NbPopoverModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPopoverModule, [{
    type: NgModule,
    args: [{
      imports: [NbOverlayModule],
      declarations: [NbPopoverDirective, NbPopoverComponent],
      exports: [NbPopoverDirective]
    }]
  }], null, null);
})();
var _NbContextMenuComponent = class _NbContextMenuComponent extends NbPositionedContainerComponent {
  constructor() {
    super(...arguments);
    this.items = [];
    this.context = {
      items: []
    };
  }
  /**
   * The method is empty since we don't need to do anything additionally
   * render is handled by change detection
   */
  renderContent() {
  }
};
_NbContextMenuComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbContextMenuComponent_BaseFactory;
  return function NbContextMenuComponent_Factory(t) {
    return (ɵNbContextMenuComponent_BaseFactory || (ɵNbContextMenuComponent_BaseFactory = ɵɵgetInheritedFactory(_NbContextMenuComponent)))(t || _NbContextMenuComponent);
  };
})();
_NbContextMenuComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbContextMenuComponent,
  selectors: [["nb-context-menu"]],
  inputs: {
    items: "items",
    tag: "tag",
    context: "context"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 1,
  vars: 2,
  consts: [[1, "context-menu", 3, "items", "tag"]],
  template: function NbContextMenuComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "nb-menu", 0);
    }
    if (rf & 2) {
      ɵɵproperty("items", ctx.context.items)("tag", ctx.context.tag);
    }
  },
  dependencies: [NbMenuComponent],
  encapsulation: 2
});
var NbContextMenuComponent = _NbContextMenuComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbContextMenuComponent, [{
    type: Component,
    args: [{
      selector: "nb-context-menu",
      template: `
    <nb-menu class="context-menu" [items]="context.items" [tag]="context.tag"></nb-menu>
  `
    }]
  }], null, {
    items: [{
      type: Input
    }],
    tag: [{
      type: Input
    }],
    context: [{
      type: Input
    }]
  });
})();
var _NbContextMenuDirective = class _NbContextMenuDirective {
  /**
   * Position will be calculated relatively host element based on the position.
   * Can be top, right, bottom and left.
   * */
  get position() {
    return this._position;
  }
  set position(value) {
    if (value !== this.position) {
      this._position = value;
      this.updateOverlayContext();
    }
  }
  /**
   * Set NbMenu tag, which helps identify menu when working with NbMenuService.
   * */
  get tag() {
    return this._tag;
  }
  set tag(value) {
    if (value !== this.tag) {
      this._tag = value;
      this.updateOverlayContext();
    }
  }
  /**
   * Basic menu items, will be passed to the internal NbMenuComponent.
   * */
  get items() {
    return this._items;
  }
  set items(items) {
    this.validateItems(items);
    this._items = items;
    this.updateOverlayContext();
  }
  get contextMenuClass() {
    return this._contextMenuClass;
  }
  set contextMenuClass(value) {
    if (value !== this.contextMenuClass) {
      this._contextMenuClass = value;
      this.overlayConfig = {
        panelClass: this.contextMenuClass
      };
    }
  }
  constructor(hostRef, menuService, dynamicOverlayHandler) {
    this.hostRef = hostRef;
    this.menuService = menuService;
    this.dynamicOverlayHandler = dynamicOverlayHandler;
    this.contextMenuHost = true;
    this._position = NbPosition.BOTTOM;
    this.adjustment = NbAdjustment.CLOCKWISE;
    this.trigger = NbTrigger.CLICK;
    this._contextMenuClass = "";
    this.overlayConfig = {
      panelClass: this.contextMenuClass
    };
    this.overlayContext = {
      items: this.items,
      tag: this.tag,
      position: this.position
    };
    this.destroy$ = new Subject();
    this._items = [];
  }
  ngOnInit() {
    this.dynamicOverlayHandler.host(this.hostRef).componentType(NbContextMenuComponent);
  }
  ngOnChanges() {
    this.rebuild();
  }
  ngAfterViewInit() {
    this.dynamicOverlay = this.configureDynamicOverlay().build();
    this.subscribeOnItemClick();
  }
  rebuild() {
    this.dynamicOverlay = this.configureDynamicOverlay().rebuild();
  }
  show() {
    this.dynamicOverlay.show();
  }
  hide() {
    this.dynamicOverlay.hide();
  }
  toggle() {
    this.dynamicOverlay.toggle();
  }
  ngOnDestroy() {
    this.dynamicOverlayHandler.destroy();
    this.destroy$.next();
    this.destroy$.complete();
  }
  configureDynamicOverlay() {
    return this.dynamicOverlayHandler.position(this.position).trigger(this.trigger).adjustment(this.adjustment).context(this.overlayContext).overlayConfig(this.overlayConfig);
  }
  /*
   * NbMenuComponent will crash if don't pass menu items to it.
   * So, we just validating them and throw custom obvious error.
   * */
  validateItems(items) {
    if (!items || !items.length) {
      throw Error(`List of menu items expected, but given: ${items}`);
    }
  }
  subscribeOnItemClick() {
    this.menuService.onItemClick().pipe(filter(({
      tag
    }) => tag === this.tag && this.trigger !== NbTrigger.NOOP), takeUntil(this.destroy$)).subscribe(() => this.hide());
  }
  updateOverlayContext() {
    this.overlayContext = {
      items: this.items,
      position: this.position,
      tag: this.tag
    };
  }
};
_NbContextMenuDirective.ɵfac = function NbContextMenuDirective_Factory(t) {
  return new (t || _NbContextMenuDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbMenuService), ɵɵdirectiveInject(NbDynamicOverlayHandler));
};
_NbContextMenuDirective.ɵdir = ɵɵdefineDirective({
  type: _NbContextMenuDirective,
  selectors: [["", "nbContextMenu", ""]],
  hostVars: 2,
  hostBindings: function NbContextMenuDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("context-menu-host", ctx.contextMenuHost);
    }
  },
  inputs: {
    position: [InputFlags.None, "nbContextMenuPlacement", "position"],
    adjustment: [InputFlags.None, "nbContextMenuAdjustment", "adjustment"],
    tag: [InputFlags.None, "nbContextMenuTag", "tag"],
    items: [InputFlags.None, "nbContextMenu", "items"],
    trigger: [InputFlags.None, "nbContextMenuTrigger", "trigger"],
    contextMenuClass: [InputFlags.None, "nbContextMenuClass", "contextMenuClass"]
  },
  features: [ɵɵProvidersFeature([NbDynamicOverlayHandler, NbDynamicOverlay]), ɵɵNgOnChangesFeature]
});
var NbContextMenuDirective = _NbContextMenuDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbContextMenuDirective, [{
    type: Directive,
    args: [{
      selector: "[nbContextMenu]",
      providers: [NbDynamicOverlayHandler, NbDynamicOverlay]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbMenuService
  }, {
    type: NbDynamicOverlayHandler
  }], {
    contextMenuHost: [{
      type: HostBinding,
      args: ["class.context-menu-host"]
    }],
    position: [{
      type: Input,
      args: ["nbContextMenuPlacement"]
    }],
    adjustment: [{
      type: Input,
      args: ["nbContextMenuAdjustment"]
    }],
    tag: [{
      type: Input,
      args: ["nbContextMenuTag"]
    }],
    items: [{
      type: Input,
      args: ["nbContextMenu"]
    }],
    trigger: [{
      type: Input,
      args: ["nbContextMenuTrigger"]
    }],
    contextMenuClass: [{
      type: Input,
      args: ["nbContextMenuClass"]
    }]
  });
})();
var _NbContextMenuModule = class _NbContextMenuModule {
};
_NbContextMenuModule.ɵfac = function NbContextMenuModule_Factory(t) {
  return new (t || _NbContextMenuModule)();
};
_NbContextMenuModule.ɵmod = ɵɵdefineNgModule({
  type: _NbContextMenuModule,
  declarations: [NbContextMenuDirective, NbContextMenuComponent],
  imports: [CommonModule, NbOverlayModule, NbMenuModule],
  exports: [NbContextMenuDirective]
});
_NbContextMenuModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, NbOverlayModule, NbMenuModule]
});
var NbContextMenuModule = _NbContextMenuModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbContextMenuModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbOverlayModule, NbMenuModule],
      exports: [NbContextMenuDirective],
      declarations: [NbContextMenuDirective, NbContextMenuComponent]
    }]
  }], null, null);
})();
var _NbProgressBarComponent = class _NbProgressBarComponent {
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.value = 0;
    this.status = "basic";
    this.size = "medium";
    this.displayValue = false;
  }
};
_NbProgressBarComponent.ɵfac = function NbProgressBarComponent_Factory(t) {
  return new (t || _NbProgressBarComponent)(ɵɵdirectiveInject(NbStatusService));
};
_NbProgressBarComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbProgressBarComponent,
  selectors: [["nb-progress-bar"]],
  hostVars: 26,
  hostBindings: function NbProgressBarComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    }
  },
  inputs: {
    value: "value",
    status: "status",
    size: "size",
    displayValue: "displayValue"
  },
  ngContentSelectors: _c02,
  decls: 4,
  vars: 3,
  consts: [[1, "progress-container"], [1, "progress-value"], [4, "ngIf"]],
  template: function NbProgressBarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0)(1, "div", 1);
      ɵɵtemplate(2, NbProgressBarComponent_span_2_Template, 2, 1, "span", 2);
      ɵɵprojection(3);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵstyleProp("width", ctx.value, "%");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.displayValue);
    }
  },
  dependencies: [NgIf],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:block}.progress-container[_ngcontent-%COMP%]{overflow:hidden}.progress-value[_ngcontent-%COMP%]{height:100%;text-align:center;overflow:hidden}"]
});
var NbProgressBarComponent = _NbProgressBarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbProgressBarComponent, [{
    type: Component,
    args: [{
      selector: "nb-progress-bar",
      template: `
    <div class="progress-container">
      <div class="progress-value" [style.width.%]="value">
        <span *ngIf="displayValue">{{ value }}%</span>
        <ng-content></ng-content>
      </div>
    </div>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:block}.progress-container{overflow:hidden}.progress-value{height:100%;text-align:center;overflow:hidden}\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    value: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    displayValue: [{
      type: Input
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbProgressBarModule = class _NbProgressBarModule {
};
_NbProgressBarModule.ɵfac = function NbProgressBarModule_Factory(t) {
  return new (t || _NbProgressBarModule)();
};
_NbProgressBarModule.ɵmod = ɵɵdefineNgModule({
  type: _NbProgressBarModule,
  declarations: [NbProgressBarComponent],
  imports: [NbSharedModule],
  exports: [NbProgressBarComponent]
});
_NbProgressBarModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule]
});
var NbProgressBarModule = _NbProgressBarModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbProgressBarModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [NbProgressBarComponent],
      exports: [NbProgressBarComponent]
    }]
  }], null, null);
})();
var _NbAlertComponent = class _NbAlertComponent {
  /**
   * Shows `close` icon
   */
  get closable() {
    return this._closable;
  }
  set closable(value) {
    this._closable = convertToBoolProperty(value);
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.size = "";
    this.status = "basic";
    this.accent = "";
    this.outline = "";
    this._closable = false;
    this.close = new EventEmitter();
  }
  /**
   * Emits the removed chip event
   */
  onClose() {
    this.close.emit();
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get primaryAccent() {
    return this.accent === "primary";
  }
  get successAccent() {
    return this.accent === "success";
  }
  get infoAccent() {
    return this.accent === "info";
  }
  get warningAccent() {
    return this.accent === "warning";
  }
  get dangerAccent() {
    return this.accent === "danger";
  }
  get basicAccent() {
    return this.accent === "basic";
  }
  get controlAccent() {
    return this.accent === "control";
  }
  get primaryOutline() {
    return this.outline === "primary";
  }
  get successOutline() {
    return this.outline === "success";
  }
  get infoOutline() {
    return this.outline === "info";
  }
  get warningOutline() {
    return this.outline === "warning";
  }
  get dangerOutline() {
    return this.outline === "danger";
  }
  get basicOutline() {
    return this.outline === "basic";
  }
  get controlOutline() {
    return this.outline === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
};
_NbAlertComponent.ɵfac = function NbAlertComponent_Factory(t) {
  return new (t || _NbAlertComponent)(ɵɵdirectiveInject(NbStatusService));
};
_NbAlertComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbAlertComponent,
  selectors: [["nb-alert"]],
  hostVars: 56,
  hostBindings: function NbAlertComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("closable", ctx.closable)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("accent-primary", ctx.primaryAccent)("accent-success", ctx.successAccent)("accent-info", ctx.infoAccent)("accent-warning", ctx.warningAccent)("accent-danger", ctx.dangerAccent)("accent-basic", ctx.basicAccent)("accent-control", ctx.controlAccent)("outline-primary", ctx.primaryOutline)("outline-success", ctx.successOutline)("outline-info", ctx.infoOutline)("outline-warning", ctx.warningOutline)("outline-danger", ctx.dangerOutline)("outline-basic", ctx.basicOutline)("outline-control", ctx.controlOutline);
    }
  },
  inputs: {
    size: "size",
    status: "status",
    accent: "accent",
    outline: "outline",
    closable: "closable"
  },
  outputs: {
    close: "close"
  },
  ngContentSelectors: _c02,
  decls: 2,
  vars: 1,
  consts: [["type", "button", "class", "close", "aria-label", "Close", 3, "click", 4, "ngIf"], ["type", "button", "aria-label", "Close", 1, "close", 3, "click"], ["aria-hidden", "true"]],
  template: function NbAlertComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, NbAlertComponent_button_0_Template, 3, 0, "button", 0);
      ɵɵprojection(1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.closable);
    }
  },
  dependencies: [NgIf],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;flex-direction:column;position:relative}[dir=ltr]   [_nghost-%COMP%]   .close[_ngcontent-%COMP%]{right:0}[dir=rtl]   [_nghost-%COMP%]   .close[_ngcontent-%COMP%]{left:0}.close[_ngcontent-%COMP%]{position:absolute;top:0;color:inherit;background-color:transparent;border:0;appearance:none}"]
});
var NbAlertComponent = _NbAlertComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAlertComponent, [{
    type: Component,
    args: [{
      selector: "nb-alert",
      template: `
    <button *ngIf="closable" type="button" class="close" aria-label="Close" (click)="onClose()">
      <span aria-hidden="true">&times;</span>
    </button>
    <ng-content></ng-content>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;flex-direction:column;position:relative}[dir=ltr] :host .close{right:0}[dir=rtl] :host .close{left:0}.close{position:absolute;top:0;color:inherit;background-color:transparent;border:0;appearance:none}\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    accent: [{
      type: Input
    }],
    outline: [{
      type: Input
    }],
    closable: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.closable"]
    }],
    close: [{
      type: Output
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    primaryAccent: [{
      type: HostBinding,
      args: ["class.accent-primary"]
    }],
    successAccent: [{
      type: HostBinding,
      args: ["class.accent-success"]
    }],
    infoAccent: [{
      type: HostBinding,
      args: ["class.accent-info"]
    }],
    warningAccent: [{
      type: HostBinding,
      args: ["class.accent-warning"]
    }],
    dangerAccent: [{
      type: HostBinding,
      args: ["class.accent-danger"]
    }],
    basicAccent: [{
      type: HostBinding,
      args: ["class.accent-basic"]
    }],
    controlAccent: [{
      type: HostBinding,
      args: ["class.accent-control"]
    }],
    primaryOutline: [{
      type: HostBinding,
      args: ["class.outline-primary"]
    }],
    successOutline: [{
      type: HostBinding,
      args: ["class.outline-success"]
    }],
    infoOutline: [{
      type: HostBinding,
      args: ["class.outline-info"]
    }],
    warningOutline: [{
      type: HostBinding,
      args: ["class.outline-warning"]
    }],
    dangerOutline: [{
      type: HostBinding,
      args: ["class.outline-danger"]
    }],
    basicOutline: [{
      type: HostBinding,
      args: ["class.outline-basic"]
    }],
    controlOutline: [{
      type: HostBinding,
      args: ["class.outline-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbAlertModule = class _NbAlertModule {
};
_NbAlertModule.ɵfac = function NbAlertModule_Factory(t) {
  return new (t || _NbAlertModule)();
};
_NbAlertModule.ɵmod = ɵɵdefineNgModule({
  type: _NbAlertModule,
  declarations: [NbAlertComponent],
  imports: [NbSharedModule],
  exports: [NbAlertComponent]
});
_NbAlertModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule]
});
var NbAlertModule = _NbAlertModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAlertModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: [NbAlertComponent],
      exports: [NbAlertComponent]
    }]
  }], null, null);
})();
var _NbFormFieldControl = class _NbFormFieldControl {
};
_NbFormFieldControl.ɵfac = function NbFormFieldControl_Factory(t) {
  return new (t || _NbFormFieldControl)();
};
_NbFormFieldControl.ɵprov = ɵɵdefineInjectable({
  token: _NbFormFieldControl,
  factory: _NbFormFieldControl.ɵfac
});
var NbFormFieldControl = _NbFormFieldControl;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFormFieldControl, [{
    type: Injectable
  }], null, null);
})();
var _NbFormFieldControlConfig = class _NbFormFieldControlConfig {
  constructor() {
    this.supportsPrefix = true;
    this.supportsSuffix = true;
  }
};
_NbFormFieldControlConfig.ɵfac = function NbFormFieldControlConfig_Factory(t) {
  return new (t || _NbFormFieldControlConfig)();
};
_NbFormFieldControlConfig.ɵprov = ɵɵdefineInjectable({
  token: _NbFormFieldControlConfig,
  factory: _NbFormFieldControlConfig.ɵfac
});
var NbFormFieldControlConfig = _NbFormFieldControlConfig;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFormFieldControlConfig, [{
    type: Injectable
  }], null, null);
})();
var _NbInputDirective = class _NbInputDirective {
  /**
   * If set element will fill container. `false` by default.
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(elementRef, focusMonitor, renderer, zone, statusService) {
    this.elementRef = elementRef;
    this.focusMonitor = focusMonitor;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this.destroy$ = new Subject();
    this.fieldSize = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this._fullWidth = false;
    this.status$ = new BehaviorSubject(this.status);
    this.size$ = new BehaviorSubject(this.fieldSize);
    this.focused$ = new BehaviorSubject(false);
    this.disabled$ = new BehaviorSubject(false);
    this.fullWidth$ = new BehaviorSubject(this.fullWidth);
  }
  ngDoCheck() {
    const isDisabled = this.elementRef.nativeElement.disabled;
    if (isDisabled !== this.disabled$.value) {
      this.disabled$.next(isDisabled);
    }
  }
  ngOnChanges({
    status,
    fieldSize,
    fullWidth
  }) {
    if (status) {
      this.status$.next(this.status);
    }
    if (fieldSize) {
      this.size$.next(this.fieldSize);
    }
    if (fullWidth) {
      this.fullWidth$.next(this.fullWidth);
    }
  }
  ngOnInit() {
    this.focusMonitor.monitor(this.elementRef).pipe(map((origin) => !!origin), finalize(() => this.focusMonitor.stopMonitoring(this.elementRef)), takeUntil(this.destroy$)).subscribe(this.focused$);
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.elementRef.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
  get tiny() {
    return this.fieldSize === "tiny";
  }
  get small() {
    return this.fieldSize === "small";
  }
  get medium() {
    return this.fieldSize === "medium";
  }
  get large() {
    return this.fieldSize === "large";
  }
  get giant() {
    return this.fieldSize === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
  get round() {
    return this.shape === "round";
  }
};
_NbInputDirective.ɵfac = function NbInputDirective_Factory(t) {
  return new (t || _NbInputDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbFocusMonitor), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
};
_NbInputDirective.ɵdir = ɵɵdefineDirective({
  type: _NbInputDirective,
  selectors: [["input", "nbInput", ""], ["textarea", "nbInput", ""]],
  hostVars: 34,
  hostBindings: function NbInputDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("input-full-width", ctx.fullWidth)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("shape-rectangle", ctx.rectangle)("shape-semi-round", ctx.semiRound)("shape-round", ctx.round);
    }
  },
  inputs: {
    fieldSize: "fieldSize",
    status: "status",
    shape: "shape",
    fullWidth: "fullWidth"
  },
  features: [ɵɵProvidersFeature([{
    provide: NbFormFieldControl,
    useExisting: _NbInputDirective
  }]), ɵɵNgOnChangesFeature]
});
var NbInputDirective = _NbInputDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbInputDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbInput],textarea[nbInput]",
      providers: [{
        provide: NbFormFieldControl,
        useExisting: NbInputDirective
      }]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbFocusMonitor
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    fieldSize: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.input-full-width"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }]
  });
})();
var _NbChatFormComponent = class _NbChatFormComponent {
  constructor(cd, domSanitizer) {
    this.cd = cd;
    this.domSanitizer = domSanitizer;
    this.status = "basic";
    this.inputFocus = false;
    this.inputHover = false;
    this.droppedFiles = [];
    this.imgDropTypes = ["image/png", "image/jpeg", "image/gif"];
    this.message = "";
    this.messagePlaceholder = "Type a message";
    this.buttonTitle = "";
    this.buttonIcon = "paper-plane-outline";
    this.showButton = true;
    this.dropFiles = false;
    this.dropFilePlaceholder = "Drop file to send";
    this.send = new EventEmitter();
    this.onInputChange = new EventEmitter();
    this.fileOver = false;
  }
  onDrop(event) {
    if (this.dropFiles) {
      event.preventDefault();
      event.stopPropagation();
      this.fileOver = false;
      if (event.dataTransfer && event.dataTransfer.files) {
        for (const file of event.dataTransfer.files) {
          const res = file;
          if (this.imgDropTypes.includes(file.type)) {
            const fr = new FileReader();
            fr.onload = (e) => {
              res.src = e.target.result;
              res.urlStyle = this.domSanitizer.bypassSecurityTrustStyle(`url(${res.src})`);
              this.cd.detectChanges();
            };
            fr.readAsDataURL(file);
          }
          this.droppedFiles.push(res);
        }
      }
    }
  }
  removeFile(file) {
    const index = this.droppedFiles.indexOf(file);
    if (index >= 0) {
      this.droppedFiles.splice(index, 1);
    }
  }
  onDragOver(event) {
    event.preventDefault();
    event.stopPropagation();
    if (this.dropFiles) {
      this.fileOver = true;
    }
  }
  onDragLeave(event) {
    event.preventDefault();
    event.stopPropagation();
    if (this.dropFiles) {
      this.fileOver = false;
    }
  }
  sendMessage() {
    if (this.droppedFiles.length || String(this.message).trim().length) {
      this.send.emit({
        message: this.message,
        files: this.droppedFiles
      });
      this.message = "";
      this.droppedFiles = [];
    }
  }
  setStatus(status) {
    if (this.status !== status) {
      this.status = status;
      this.cd.detectChanges();
    }
  }
  getInputStatus() {
    if (this.fileOver) {
      return this.getHighlightStatus();
    }
    if (this.inputFocus || this.inputHover) {
      return this.status;
    }
    return "basic";
  }
  getButtonStatus() {
    return this.getHighlightStatus();
  }
  getHighlightStatus() {
    if (this.status === "basic" || this.status === "control") {
      return "primary";
    }
    return this.status;
  }
  onModelChange(value) {
    this.onInputChange.emit(value);
  }
};
_NbChatFormComponent.ɵfac = function NbChatFormComponent_Factory(t) {
  return new (t || _NbChatFormComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(DomSanitizer));
};
_NbChatFormComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbChatFormComponent,
  selectors: [["nb-chat-form"]],
  hostVars: 2,
  hostBindings: function NbChatFormComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("drop", function NbChatFormComponent_drop_HostBindingHandler($event) {
        return ctx.onDrop($event);
      })("dragover", function NbChatFormComponent_dragover_HostBindingHandler($event) {
        return ctx.onDragOver($event);
      })("dragleave", function NbChatFormComponent_dragleave_HostBindingHandler($event) {
        return ctx.onDragLeave($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("file-over", ctx.fileOver);
    }
  },
  inputs: {
    message: "message",
    messagePlaceholder: "messagePlaceholder",
    buttonTitle: "buttonTitle",
    buttonIcon: "buttonIcon",
    showButton: "showButton",
    dropFiles: "dropFiles",
    dropFilePlaceholder: "dropFilePlaceholder"
  },
  outputs: {
    send: "send",
    onInputChange: "onInputChange"
  },
  decls: 4,
  vars: 7,
  consts: [["class", "dropped-files", 4, "ngIf"], [1, "message-row"], ["nbInput", "", "fullWidth", "", "type", "text", 3, "status", "ngModel", "placeholder", "focus", "blur", "mouseenter", "mouseleave", "ngModelChange", "keyup.enter"], ["nbButton", "", "class", "send-button", 3, "status", "with-icon", "click", 4, "ngIf"], [1, "dropped-files"], [4, "ngFor", "ngForOf"], [3, "background-image", 4, "ngIf"], [4, "ngIf"], [1, "remove", 3, "click"], ["icon", "file-text-outline", "pack", "nebular-essentials"], ["nbButton", "", 1, "send-button", 3, "status", "click"], ["pack", "nebular-essentials", 3, "icon", 4, "ngIf", "ngIfElse"], ["title", ""], ["pack", "nebular-essentials", 3, "icon"]],
  template: function NbChatFormComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbChatFormComponent_div_0_Template, 2, 1, "div", 0);
      ɵɵelementStart(1, "div", 1)(2, "input", 2);
      ɵɵlistener("focus", function NbChatFormComponent_Template_input_focus_2_listener() {
        return ctx.inputFocus = true;
      })("blur", function NbChatFormComponent_Template_input_blur_2_listener() {
        return ctx.inputFocus = false;
      })("mouseenter", function NbChatFormComponent_Template_input_mouseenter_2_listener() {
        return ctx.inputHover = true;
      })("mouseleave", function NbChatFormComponent_Template_input_mouseleave_2_listener() {
        return ctx.inputHover = false;
      })("ngModelChange", function NbChatFormComponent_Template_input_ngModelChange_2_listener($event) {
        return ctx.message = $event;
      })("ngModelChange", function NbChatFormComponent_Template_input_ngModelChange_2_listener($event) {
        return ctx.onModelChange($event);
      })("keyup.enter", function NbChatFormComponent_Template_input_keyup_enter_2_listener() {
        return ctx.sendMessage();
      });
      ɵɵelementEnd();
      ɵɵtemplate(3, NbChatFormComponent_button_3_Template, 4, 5, "button", 3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.droppedFiles == null ? null : ctx.droppedFiles.length);
      ɵɵadvance(2);
      ɵɵclassProp("with-button", ctx.showButton);
      ɵɵpropertyInterpolate("placeholder", ctx.fileOver ? ctx.dropFilePlaceholder : ctx.messagePlaceholder);
      ɵɵproperty("status", ctx.getInputStatus())("ngModel", ctx.message);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showButton);
    }
  },
  dependencies: [NgForOf, NgIf, DefaultValueAccessor, NgControlStatus, NgModel, NbIconComponent, NbInputDirective, NbButtonComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbChatFormComponent = _NbChatFormComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatFormComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-form",
      template: `
    <div class="dropped-files" *ngIf="droppedFiles?.length">
      <ng-container *ngFor="let file of droppedFiles">
        <div *ngIf="file.urlStyle" [style.background-image]="file.urlStyle">
          <span class="remove" (click)="removeFile(file)">&times;</span>
        </div>

        <div *ngIf="!file.urlStyle">
          <nb-icon icon="file-text-outline" pack="nebular-essentials"></nb-icon>
          <span class="remove" (click)="removeFile(file)">&times;</span>
        </div>
      </ng-container>
    </div>
    <div class="message-row">
      <input
        nbInput
        fullWidth
        [status]="getInputStatus()"
        (focus)="inputFocus = true"
        (blur)="inputFocus = false"
        (mouseenter)="inputHover = true"
        (mouseleave)="inputHover = false"
        [(ngModel)]="message"
        (ngModelChange)="onModelChange($event)"
        [class.with-button]="showButton"
        type="text"
        placeholder="{{ fileOver ? dropFilePlaceholder : messagePlaceholder }}"
        (keyup.enter)="sendMessage()"
      />
      <button
        nbButton
        [status]="getButtonStatus()"
        *ngIf="showButton"
        [class.with-icon]="!buttonTitle"
        (click)="sendMessage()"
        class="send-button"
      >
        <nb-icon *ngIf="!buttonTitle; else title" [icon]="buttonIcon" pack="nebular-essentials"></nb-icon>
        <ng-template #title>{{ buttonTitle }}</ng-template>
      </button>
    </div>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: DomSanitizer
  }], {
    message: [{
      type: Input
    }],
    messagePlaceholder: [{
      type: Input
    }],
    buttonTitle: [{
      type: Input
    }],
    buttonIcon: [{
      type: Input
    }],
    showButton: [{
      type: Input
    }],
    dropFiles: [{
      type: Input
    }],
    dropFilePlaceholder: [{
      type: Input
    }],
    send: [{
      type: Output
    }],
    onInputChange: [{
      type: Output
    }],
    fileOver: [{
      type: HostBinding,
      args: ["class.file-over"]
    }],
    onDrop: [{
      type: HostListener,
      args: ["drop", ["$event"]]
    }],
    onDragOver: [{
      type: HostListener,
      args: ["dragover", ["$event"]]
    }],
    onDragLeave: [{
      type: HostListener,
      args: ["dragleave", ["$event"]]
    }]
  });
})();
var _NbChatCustomMessageService = class _NbChatCustomMessageService {
  constructor() {
    this.customMessages = /* @__PURE__ */ new Map();
  }
  register(type, instance) {
    this.customMessages.set(type, instance);
  }
  unregister(type) {
    return this.customMessages.delete(type);
  }
  getInstance(type) {
    return this.customMessages.get(type);
  }
};
_NbChatCustomMessageService.ɵfac = function NbChatCustomMessageService_Factory(t) {
  return new (t || _NbChatCustomMessageService)();
};
_NbChatCustomMessageService.ɵprov = ɵɵdefineInjectable({
  token: _NbChatCustomMessageService,
  factory: _NbChatCustomMessageService.ɵfac
});
var NbChatCustomMessageService = _NbChatCustomMessageService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatCustomMessageService, [{
    type: Injectable
  }], null, null);
})();
var _NbChatMessageTextComponent = class _NbChatMessageTextComponent {
  constructor() {
    this.dateFormat = "shortTime";
  }
};
_NbChatMessageTextComponent.ɵfac = function NbChatMessageTextComponent_Factory(t) {
  return new (t || _NbChatMessageTextComponent)();
};
_NbChatMessageTextComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbChatMessageTextComponent,
  selectors: [["nb-chat-message-text"]],
  inputs: {
    sender: "sender",
    message: "message",
    date: "date",
    dateFormat: "dateFormat"
  },
  decls: 2,
  vars: 2,
  consts: [["class", "sender", 4, "ngIf"], ["class", "text", 4, "ngIf"], [1, "sender"], [1, "text"]],
  template: function NbChatMessageTextComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbChatMessageTextComponent_p_0_Template, 5, 5, "p", 0)(1, NbChatMessageTextComponent_p_1_Template, 2, 1, "p", 1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.sender || ctx.date);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.message);
    }
  },
  dependencies: [NgIf, DatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var NbChatMessageTextComponent = _NbChatMessageTextComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageTextComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message-text",
      template: `
    <p class="sender" *ngIf="sender || date">{{ sender }} <time>{{ date  | date: dateFormat }}</time></p>
    <p class="text" *ngIf="message">{{ message }}</p>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    sender: [{
      type: Input
    }],
    message: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }]
  });
})();
var _NbChatMessageFileComponent = class _NbChatMessageFileComponent {
  /**
   * Message file path
   * @type {Date}
   */
  set files(files) {
    this.readyFiles = (files || []).map((file) => {
      const isImage = this.isImage(file);
      return __spreadProps(__spreadValues({}, file), {
        urlStyle: isImage && this.domSanitizer.bypassSecurityTrustStyle(`url(${file.url})`),
        isImage
      });
    });
    this.cd.detectChanges();
  }
  constructor(cd, domSanitizer) {
    this.cd = cd;
    this.domSanitizer = domSanitizer;
    this.dateFormat = "shortTime";
  }
  isImage(file) {
    const type = file.type;
    if (type) {
      return ["image/png", "image/jpeg", "image/gif"].includes(type);
    }
    return false;
  }
};
_NbChatMessageFileComponent.ɵfac = function NbChatMessageFileComponent_Factory(t) {
  return new (t || _NbChatMessageFileComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(DomSanitizer));
};
_NbChatMessageFileComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbChatMessageFileComponent,
  selectors: [["nb-chat-message-file"]],
  inputs: {
    message: "message",
    sender: "sender",
    date: "date",
    dateFormat: "dateFormat",
    files: "files"
  },
  decls: 4,
  vars: 7,
  consts: [[3, "sender", "date", "dateFormat", "message"], [4, "ngIf"], [1, "message-content-group"], ["target", "_blank", 3, "href", 4, "ngFor", "ngForOf"], ["target", "_blank", 3, "href"], [3, "icon", 4, "ngIf"], [3, "background-image", 4, "ngIf"], [3, "icon"]],
  template: function NbChatMessageFileComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nb-chat-message-text", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
      ɵɵtemplate(2, NbChatMessageFileComponent_ng_container_2_Template, 3, 1, "ng-container", 1)(3, NbChatMessageFileComponent_ng_container_3_Template, 4, 3, "ng-container", 1);
    }
    if (rf & 2) {
      ɵɵproperty("sender", ctx.sender)("date", ctx.date)("dateFormat", ctx.dateFormat)("message", ctx.message);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.message, " ");
      ɵɵadvance();
      ɵɵproperty("ngIf", (ctx.readyFiles == null ? null : ctx.readyFiles.length) > 1);
      ɵɵadvance();
      ɵɵproperty("ngIf", (ctx.readyFiles == null ? null : ctx.readyFiles.length) === 1);
    }
  },
  dependencies: [NgForOf, NgIf, NbIconComponent, NbChatMessageTextComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbChatMessageFileComponent = _NbChatMessageFileComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageFileComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message-file",
      template: `
    <nb-chat-message-text [sender]="sender" [date]="date" [dateFormat]="dateFormat" [message]="message">
      {{ message }}
    </nb-chat-message-text>

    <ng-container *ngIf="readyFiles?.length > 1">
      <div class="message-content-group">
        <a *ngFor="let file of readyFiles" [href]="file.url" target="_blank">
          <nb-icon [icon]="file.icon" *ngIf="!file.urlStyle && file.icon"></nb-icon>
          <div *ngIf="file.urlStyle" [style.background-image]="file.urlStyle"></div>
        </a>
      </div>
    </ng-container>

    <ng-container *ngIf="readyFiles?.length === 1">
      <a [href]="readyFiles[0].url" target="_blank">
        <nb-icon [icon]="readyFiles[0].icon" *ngIf="!readyFiles[0].urlStyle && readyFiles[0].icon"></nb-icon>
        <div *ngIf="readyFiles[0].urlStyle" [style.background-image]="readyFiles[0].urlStyle"></div>
      </a>
    </ng-container>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: DomSanitizer
  }], {
    message: [{
      type: Input
    }],
    sender: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    files: [{
      type: Input
    }]
  });
})();
var _NbChatMessageQuoteComponent = class _NbChatMessageQuoteComponent {
  constructor() {
    this.dateFormat = "shortTime";
  }
};
_NbChatMessageQuoteComponent.ɵfac = function NbChatMessageQuoteComponent_Factory(t) {
  return new (t || _NbChatMessageQuoteComponent)();
};
_NbChatMessageQuoteComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbChatMessageQuoteComponent,
  selectors: [["nb-chat-message-quote"]],
  inputs: {
    message: "message",
    sender: "sender",
    date: "date",
    dateFormat: "dateFormat",
    quote: "quote"
  },
  decls: 5,
  vars: 4,
  consts: [["class", "sender", 4, "ngIf"], [1, "quote"], [3, "message"], [1, "sender"]],
  template: function NbChatMessageQuoteComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbChatMessageQuoteComponent_p_0_Template, 5, 5, "p", 0);
      ɵɵelementStart(1, "p", 1);
      ɵɵtext(2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "nb-chat-message-text", 2);
      ɵɵtext(4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.sender || ctx.date);
      ɵɵadvance(2);
      ɵɵtextInterpolate1(" ", ctx.quote, " ");
      ɵɵadvance();
      ɵɵproperty("message", ctx.message);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.message, " ");
    }
  },
  dependencies: [NgIf, NbChatMessageTextComponent, DatePipe],
  encapsulation: 2,
  changeDetection: 0
});
var NbChatMessageQuoteComponent = _NbChatMessageQuoteComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageQuoteComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message-quote",
      template: `
    <p class="sender" *ngIf="sender || date">{{ sender }} <time>{{ date | date: dateFormat }}</time></p>
    <p class="quote">
      {{ quote }}
    </p>
    <nb-chat-message-text [message]="message">
      {{ message }}
    </nb-chat-message-text>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    message: [{
      type: Input
    }],
    sender: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    quote: [{
      type: Input
    }]
  });
})();
var NbChatOptions = class {
};
var _NbChatMessageMapComponent = class _NbChatMessageMapComponent {
  get file() {
    return {
      // eslint-disable-next-line max-len
      url: `https://maps.googleapis.com/maps/api/staticmap?center=${this.latitude},${this.longitude}&zoom=12&size=400x400&key=${this.mapKey}`,
      type: "image/png",
      icon: "location"
    };
  }
  constructor(options) {
    this.dateFormat = "shortTime";
    this.mapKey = options.messageGoogleMapKey;
  }
};
_NbChatMessageMapComponent.ɵfac = function NbChatMessageMapComponent_Factory(t) {
  return new (t || _NbChatMessageMapComponent)(ɵɵdirectiveInject(NbChatOptions));
};
_NbChatMessageMapComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbChatMessageMapComponent,
  selectors: [["nb-chat-message-map"]],
  inputs: {
    message: "message",
    sender: "sender",
    date: "date",
    dateFormat: "dateFormat",
    latitude: "latitude",
    longitude: "longitude"
  },
  decls: 1,
  vars: 7,
  consts: [[3, "files", "message", "sender", "date", "dateFormat"]],
  template: function NbChatMessageMapComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "nb-chat-message-file", 0);
    }
    if (rf & 2) {
      ɵɵproperty("files", ɵɵpureFunction1(5, _c26, ctx.file))("message", ctx.message)("sender", ctx.sender)("date", ctx.date)("dateFormat", ctx.dateFormat);
    }
  },
  dependencies: [NbChatMessageFileComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbChatMessageMapComponent = _NbChatMessageMapComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageMapComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message-map",
      template: `
    <nb-chat-message-file [files]="[file]" [message]="message" [sender]="sender" [date]="date"
     [dateFormat]="dateFormat"></nb-chat-message-file>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbChatOptions
  }], {
    message: [{
      type: Input
    }],
    sender: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    latitude: [{
      type: Input
    }],
    longitude: [{
      type: Input
    }]
  });
})();
var _NbChatAvatarComponent = class _NbChatAvatarComponent {
  constructor() {
    this.avatarClass = true;
  }
};
_NbChatAvatarComponent.ɵfac = function NbChatAvatarComponent_Factory(t) {
  return new (t || _NbChatAvatarComponent)();
};
_NbChatAvatarComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbChatAvatarComponent,
  selectors: [["nb-chat-avatar"]],
  hostVars: 4,
  hostBindings: function NbChatAvatarComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵstyleProp("background-image", ctx.avatarStyle);
      ɵɵclassProp("avatar", ctx.avatarClass);
    }
  },
  inputs: {
    initials: "initials",
    avatarStyle: "avatarStyle"
  },
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"]],
  template: function NbChatAvatarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbChatAvatarComponent_ng_container_0_Template, 2, 1, "ng-container", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.avatarStyle);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2,
  changeDetection: 0
});
var NbChatAvatarComponent = _NbChatAvatarComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatAvatarComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-avatar",
      template: `
    <ng-container *ngIf="!avatarStyle">
      {{ initials }}
    </ng-container>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    initials: [{
      type: Input
    }],
    avatarStyle: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["style.background-image"]
    }],
    avatarClass: [{
      type: HostBinding,
      args: ["class.avatar"]
    }]
  });
})();
var _NbChatMessageComponent = class _NbChatMessageComponent {
  get _addReplyClass() {
    return this._areDefaultStylesEnabled() && this.reply;
  }
  get _addNotReplyClass() {
    return this._areDefaultStylesEnabled() && this.notReply;
  }
  get _addNoSpaceClass() {
    return this._areDefaultStylesEnabled() && !this.message;
  }
  get flyInOut() {
    return true;
  }
  get notReply() {
    return !this.reply;
  }
  /**
   * Determines if a message is a reply
   */
  get reply() {
    return this._reply;
  }
  set reply(value) {
    this._reply = convertToBoolProperty(value);
  }
  /**
   * Message send avatar
   * @type {string}
   */
  set avatar(value) {
    this.avatarStyle = value ? this.domSanitizer.bypassSecurityTrustStyle(`url(${value})`) : null;
  }
  constructor(domSanitizer, customMessageService) {
    this.domSanitizer = domSanitizer;
    this.customMessageService = customMessageService;
    this.builtInMessageTypes = ["text", "file", "map", "quote"];
    this._reply = false;
  }
  getInitials() {
    if (this.sender) {
      const names = this.sender.split(" ");
      return names.map((n) => n.charAt(0)).splice(0, 2).join("").toUpperCase();
    }
    return "";
  }
  _isBuiltInMessageType() {
    return this.type == null || this.builtInMessageTypes.includes(this.type);
  }
  _getTemplate() {
    const customMessage = this.getCustomMessage(this.type);
    return customMessage.templateRef;
  }
  _getTemplateContext() {
    return {
      $implicit: this.customMessageData,
      isReply: this.reply
    };
  }
  _areDefaultStylesEnabled() {
    const customMessageDirective = this.getCustomMessage(this.type);
    return !customMessageDirective.noStyles;
  }
  getCustomMessage(type) {
    const customMessageDirective = this.customMessageService.getInstance(type);
    if (!customMessageDirective) {
      throw new Error(`nb-chat: Can't find template for custom type '${type}'. Make sure you provide it in the chat component with *nbCustomMessage='${type}'.`);
    }
    return customMessageDirective;
  }
};
_NbChatMessageComponent.ɵfac = function NbChatMessageComponent_Factory(t) {
  return new (t || _NbChatMessageComponent)(ɵɵdirectiveInject(DomSanitizer), ɵɵdirectiveInject(NbChatCustomMessageService));
};
_NbChatMessageComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbChatMessageComponent,
  selectors: [["nb-chat-message"]],
  hostVars: 5,
  hostBindings: function NbChatMessageComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵsyntheticHostProperty("@flyInOut", ctx.flyInOut);
      ɵɵclassProp("not-reply", ctx.notReply)("reply", ctx.reply);
    }
  },
  inputs: {
    reply: "reply",
    message: "message",
    sender: "sender",
    date: "date",
    dateFormat: "dateFormat",
    files: "files",
    quote: "quote",
    latitude: "latitude",
    longitude: "longitude",
    avatar: "avatar",
    type: "type",
    customMessageData: "customMessageData"
  },
  decls: 5,
  vars: 3,
  consts: [[3, "initials", "avatarStyle", 4, "ngIf"], [1, "message"], [3, "ngSwitch", 4, "ngIf", "ngIfElse"], ["customTemplate", ""], [3, "initials", "avatarStyle"], [3, "ngSwitch"], [3, "sender", "date", "dateFormat", "message", "files", 4, "ngSwitchCase"], [3, "sender", "date", "dateFormat", "message", "quote", 4, "ngSwitchCase"], [3, "sender", "date", "message", "latitude", "longitude", 4, "ngSwitchCase"], [3, "sender", "date", "dateFormat", "message", 4, "ngSwitchDefault"], [3, "sender", "date", "dateFormat", "message", "files"], [3, "sender", "date", "dateFormat", "message", "quote"], [3, "sender", "date", "message", "latitude", "longitude"], [3, "sender", "date", "dateFormat", "message"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function NbChatMessageComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbChatMessageComponent_nb_chat_avatar_0_Template, 1, 2, "nb-chat-avatar", 0);
      ɵɵelementStart(1, "div", 1);
      ɵɵtemplate(2, NbChatMessageComponent_ng_container_2_Template, 5, 4, "ng-container", 2);
      ɵɵelementEnd();
      ɵɵtemplate(3, NbChatMessageComponent_ng_template_3_Template, 3, 16, "ng-template", null, 3, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const _r3 = ɵɵreference(4);
      ɵɵproperty("ngIf", ctx.notReply);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx._isBuiltInMessageType())("ngIfElse", _r3);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NgSwitch, NgSwitchCase, NgSwitchDefault, NbChatMessageTextComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent, NbChatAvatarComponent],
  encapsulation: 2,
  data: {
    animation: [trigger("flyInOut", [state("in", style({
      transform: "translateX(0)"
    })), transition("void => *", [style({
      transform: "translateX(-100%)"
    }), animate(80)]), transition("* => void", [animate(80, style({
      transform: "translateX(100%)"
    }))])])]
  },
  changeDetection: 0
});
var NbChatMessageComponent = _NbChatMessageComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatMessageComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat-message",
      template: `
    <nb-chat-avatar *ngIf="notReply" [initials]="getInitials()" [avatarStyle]="avatarStyle"> </nb-chat-avatar>

    <div class="message">
      <ng-container [ngSwitch]="type" *ngIf="_isBuiltInMessageType(); else customTemplate">
        <nb-chat-message-file
          *ngSwitchCase="'file'"
          [sender]="sender"
          [date]="date"
          [dateFormat]="dateFormat"
          [message]="message"
          [files]="files"
        >
        </nb-chat-message-file>

        <nb-chat-message-quote
          *ngSwitchCase="'quote'"
          [sender]="sender"
          [date]="date"
          [dateFormat]="dateFormat"
          [message]="message"
          [quote]="quote"
        >
        </nb-chat-message-quote>

        <nb-chat-message-map
          *ngSwitchCase="'map'"
          [sender]="sender"
          [date]="date"
          [message]="message"
          [latitude]="latitude"
          [longitude]="longitude"
        >
        </nb-chat-message-map>

        <nb-chat-message-text
          *ngSwitchDefault
          [sender]="sender"
          [date]="date"
          [dateFormat]="dateFormat"
          [message]="message"
        >
        </nb-chat-message-text>
      </ng-container>
    </div>

    <ng-template #customTemplate>
      <nb-chat-message-text [sender]="sender" [date]="date" [dateFormat]="dateFormat" [message]="message">
      </nb-chat-message-text>
      <div
        [class.nb-custom-message]="_areDefaultStylesEnabled()"
        [class.nb-custom-message-no-space]="_addNoSpaceClass"
        [class.nb-custom-message-reply]="_addReplyClass"
        [class.nb-custom-message-not-reply]="_addNotReplyClass"
        [class.nb-custom-message-full-width]="!_areDefaultStylesEnabled()"
      >
        <ng-container [ngTemplateOutlet]="_getTemplate()" [ngTemplateOutletContext]="_getTemplateContext()">
        </ng-container>
      </div>
    </ng-template>
  `,
      animations: [trigger("flyInOut", [state("in", style({
        transform: "translateX(0)"
      })), transition("void => *", [style({
        transform: "translateX(-100%)"
      }), animate(80)]), transition("* => void", [animate(80, style({
        transform: "translateX(100%)"
      }))])])],
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: DomSanitizer
  }, {
    type: NbChatCustomMessageService
  }], {
    flyInOut: [{
      type: HostBinding,
      args: ["@flyInOut"]
    }],
    notReply: [{
      type: HostBinding,
      args: ["class.not-reply"]
    }],
    reply: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.reply"]
    }],
    message: [{
      type: Input
    }],
    sender: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    files: [{
      type: Input
    }],
    quote: [{
      type: Input
    }],
    latitude: [{
      type: Input
    }],
    longitude: [{
      type: Input
    }],
    avatar: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    customMessageData: [{
      type: Input
    }]
  });
})();
var _NbChatTitleDirective = class _NbChatTitleDirective {
  constructor(templateRef) {
    this.templateRef = templateRef;
    this.context = {};
  }
};
_NbChatTitleDirective.ɵfac = function NbChatTitleDirective_Factory(t) {
  return new (t || _NbChatTitleDirective)(ɵɵdirectiveInject(TemplateRef));
};
_NbChatTitleDirective.ɵdir = ɵɵdefineDirective({
  type: _NbChatTitleDirective,
  selectors: [["", "nbChatTitle", ""]],
  inputs: {
    context: "context"
  }
});
var NbChatTitleDirective = _NbChatTitleDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatTitleDirective, [{
    type: Directive,
    args: [{
      selector: `[nbChatTitle]`
    }]
  }], () => [{
    type: TemplateRef
  }], {
    context: [{
      type: Input
    }]
  });
})();
var _NbChatComponent = class _NbChatComponent {
  /**
   * Scroll chat to the bottom of the list when a new message arrives
   */
  get scrollBottom() {
    return this._scrollBottom;
  }
  set scrollBottom(value) {
    this._scrollBottom = convertToBoolProperty(value);
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.status = "basic";
    this.noMessagesPlaceholder = "No messages yet.";
    this._scrollBottom = true;
  }
  ngOnChanges(changes) {
    if ("status" in changes) {
      this.updateFormStatus();
    }
  }
  ngAfterContentInit() {
    this.updateFormStatus();
  }
  ngAfterViewInit() {
    this.messages.changes.subscribe((messages) => {
      this.messages = messages;
      this.updateView();
    });
    this.updateView();
  }
  updateView() {
    if (this.scrollBottom) {
      this.scrollListBottom();
    }
  }
  scrollListBottom() {
    this.scrollable.nativeElement.scrollTop = this.scrollable.nativeElement.scrollHeight;
  }
  updateFormStatus() {
    if (this.chatForm) {
      this.chatForm.setStatus(this.status);
    }
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
};
_NbChatComponent.ɵfac = function NbChatComponent_Factory(t) {
  return new (t || _NbChatComponent)(ɵɵdirectiveInject(NbStatusService));
};
_NbChatComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbChatComponent,
  selectors: [["nb-chat"]],
  contentQueries: function NbChatComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbChatFormComponent, 5);
      ɵɵcontentQuery(dirIndex, NbChatTitleDirective, 5);
      ɵɵcontentQuery(dirIndex, NbChatMessageComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chatForm = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.titleTemplate = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.messages = _t);
    }
  },
  viewQuery: function NbChatComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c27, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.scrollable = _t.first);
    }
  },
  hostVars: 26,
  hostBindings: function NbChatComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    }
  },
  inputs: {
    title: "title",
    size: "size",
    status: "status",
    noMessagesPlaceholder: "noMessagesPlaceholder",
    scrollBottom: "scrollBottom"
  },
  features: [ɵɵProvidersFeature([NbChatCustomMessageService]), ɵɵNgOnChangesFeature],
  ngContentSelectors: _c30,
  decls: 11,
  vars: 3,
  consts: [[1, "header"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf", "ngIfElse"], ["textTitleTemplate", ""], [1, "scrollable"], ["scrollable", ""], [1, "messages"], ["class", "no-messages", 4, "ngIf"], [1, "form"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "no-messages"]],
  template: function NbChatComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c29);
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, NbChatComponent_ng_container_1_Template, 1, 4, "ng-container", 1)(2, NbChatComponent_ng_template_2_Template, 1, 1, "ng-template", null, 2, ɵɵtemplateRefExtractor);
      ɵɵelementEnd();
      ɵɵelementStart(4, "div", 3, 4)(6, "div", 5);
      ɵɵprojection(7);
      ɵɵtemplate(8, NbChatComponent_p_8_Template, 2, 1, "p", 6);
      ɵɵelementEnd()();
      ɵɵelementStart(9, "div", 7);
      ɵɵprojection(10, 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      const _r2 = ɵɵreference(3);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.titleTemplate)("ngIfElse", _r2);
      ɵɵadvance(7);
      ɵɵproperty("ngIf", !(ctx.messages == null ? null : ctx.messages.length));
    }
  },
  dependencies: [NgIf, NgTemplateOutlet],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;flex-direction:column;position:relative;height:100%}"]
});
var NbChatComponent = _NbChatComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatComponent, [{
    type: Component,
    args: [{
      selector: "nb-chat",
      template: `
    <div class="header">
      <ng-container
        *ngIf="titleTemplate; else textTitleTemplate"
        [ngTemplateOutlet]="titleTemplate.templateRef"
        [ngTemplateOutletContext]="{ $implicit: titleTemplate.context }"
      >
      </ng-container>
      <ng-template #textTitleTemplate>
        {{ title }}
      </ng-template>
    </div>

    <div class="scrollable" #scrollable>
      <div class="messages">
        <ng-content select="nb-chat-message"></ng-content>
        <p class="no-messages" *ngIf="!messages?.length">{{ noMessagesPlaceholder }}</p>
      </div>
    </div>
    <div class="form">
      <ng-content select="nb-chat-form"></ng-content>
    </div>
  `,
      providers: [NbChatCustomMessageService],
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;flex-direction:column;position:relative;height:100%}\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    title: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    noMessagesPlaceholder: [{
      type: Input
    }],
    scrollBottom: [{
      type: Input
    }],
    scrollable: [{
      type: ViewChild,
      args: ["scrollable"]
    }],
    messages: [{
      type: ContentChildren,
      args: [NbChatMessageComponent]
    }],
    chatForm: [{
      type: ContentChild,
      args: [NbChatFormComponent]
    }],
    titleTemplate: [{
      type: ContentChild,
      args: [NbChatTitleDirective]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var NB_INPUT_COMPONENTS = [NbInputDirective];
var _NbInputModule = class _NbInputModule {
};
_NbInputModule.ɵfac = function NbInputModule_Factory(t) {
  return new (t || _NbInputModule)();
};
_NbInputModule.ɵmod = ɵɵdefineNgModule({
  type: _NbInputModule,
  declarations: [NbInputDirective],
  imports: [NbSharedModule],
  exports: [NbInputDirective]
});
_NbInputModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule]
});
var NbInputModule = _NbInputModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbInputModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      declarations: NB_INPUT_COMPONENTS,
      exports: NB_INPUT_COMPONENTS
    }]
  }], null, null);
})();
function throwCustomMessageTypeIsRequired() {
  throw new Error("[nbCustomMessage]: custom message type is required.");
}
var _NbChatCustomMessageDirective = class _NbChatCustomMessageDirective {
  /**
   * Defines a message type which should rendered with the custom message template.
   * @type {string}
   */
  get nbCustomMessage() {
    return this._type;
  }
  set nbCustomMessage(value) {
    this._type = value;
  }
  get type() {
    return this._type;
  }
  /**
   * Disables generic message styles, such as round corners, text color, background, etc.,
   * so a custom message could be styled from the ground up.
   *
   * @type {boolean}
   */
  set nbCustomMessageNoStyles(value) {
    this._noStyles = convertToBoolProperty(value);
  }
  get nbCustomMessageNoStyles() {
    return this._noStyles;
  }
  get noStyles() {
    return this.nbCustomMessageNoStyles;
  }
  constructor(templateRef, customMessageService) {
    this.templateRef = templateRef;
    this.customMessageService = customMessageService;
    this._noStyles = false;
  }
  ngOnInit() {
    if (!this._type) {
      throwCustomMessageTypeIsRequired();
    }
    this.customMessageService.register(this.type, this);
  }
  ngOnDestroy() {
    this.customMessageService.unregister(this.type);
  }
};
_NbChatCustomMessageDirective.ɵfac = function NbChatCustomMessageDirective_Factory(t) {
  return new (t || _NbChatCustomMessageDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(NbChatCustomMessageService));
};
_NbChatCustomMessageDirective.ɵdir = ɵɵdefineDirective({
  type: _NbChatCustomMessageDirective,
  selectors: [["", "nbCustomMessage", ""]],
  inputs: {
    nbCustomMessage: "nbCustomMessage",
    nbCustomMessageNoStyles: "nbCustomMessageNoStyles"
  }
});
var NbChatCustomMessageDirective = _NbChatCustomMessageDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatCustomMessageDirective, [{
    type: Directive,
    args: [{
      selector: `[nbCustomMessage]`
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: NbChatCustomMessageService
  }], {
    nbCustomMessage: [{
      type: Input
    }],
    nbCustomMessageNoStyles: [{
      type: Input
    }]
  });
})();
var NB_CHAT_COMPONENTS = [NbChatComponent, NbChatMessageComponent, NbChatFormComponent, NbChatMessageTextComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent, NbChatAvatarComponent];
var NB_CHAT_DIRECTIVES = [NbChatCustomMessageDirective, NbChatTitleDirective];
var _NbChatModule = class _NbChatModule {
  static forRoot(options) {
    return {
      ngModule: _NbChatModule,
      providers: [{
        provide: NbChatOptions,
        useValue: options || {}
      }]
    };
  }
  static forChild(options) {
    return {
      ngModule: _NbChatModule,
      providers: [{
        provide: NbChatOptions,
        useValue: options || {}
      }]
    };
  }
};
_NbChatModule.ɵfac = function NbChatModule_Factory(t) {
  return new (t || _NbChatModule)();
};
_NbChatModule.ɵmod = ɵɵdefineNgModule({
  type: _NbChatModule,
  declarations: [NbChatComponent, NbChatMessageComponent, NbChatFormComponent, NbChatMessageTextComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent, NbChatAvatarComponent, NbChatCustomMessageDirective, NbChatTitleDirective],
  imports: [NbSharedModule, NbIconModule, NbInputModule, NbButtonModule],
  exports: [NbChatComponent, NbChatMessageComponent, NbChatFormComponent, NbChatMessageTextComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageMapComponent, NbChatAvatarComponent, NbChatCustomMessageDirective, NbChatTitleDirective]
});
_NbChatModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbIconModule, NbInputModule, NbButtonModule]
});
var NbChatModule = _NbChatModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbChatModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule, NbInputModule, NbButtonModule],
      declarations: [...NB_CHAT_COMPONENTS, ...NB_CHAT_DIRECTIVES],
      exports: [...NB_CHAT_COMPONENTS, ...NB_CHAT_DIRECTIVES]
    }]
  }], null, null);
})();
var _NbSpinnerComponent = class _NbSpinnerComponent {
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.message = "Loading...";
    this.size = "medium";
    this.status = "basic";
  }
};
_NbSpinnerComponent.ɵfac = function NbSpinnerComponent_Factory(t) {
  return new (t || _NbSpinnerComponent)(ɵɵdirectiveInject(NbStatusService));
};
_NbSpinnerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSpinnerComponent,
  selectors: [["nb-spinner"]],
  hostVars: 26,
  hostBindings: function NbSpinnerComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    }
  },
  inputs: {
    message: "message",
    size: "size",
    status: "status"
  },
  decls: 2,
  vars: 1,
  consts: [[1, "spin-circle"], ["class", "message", 4, "ngIf"], [1, "message"]],
  template: function NbSpinnerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "span", 0);
      ɵɵtemplate(1, NbSpinnerComponent_span_1_Template, 2, 1, "span", 1);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.message);
    }
  },
  dependencies: [NgIf],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{opacity:1;position:absolute;border-radius:inherit;inset:0;overflow:hidden;z-index:9999;display:flex;justify-content:center;align-items:center;visibility:visible}[_nghost-%COMP%]   .spin-circle[_ngcontent-%COMP%]{animation:spin .8s infinite linear;border-radius:50%;border-style:solid;border-width:.125em;width:1em;height:1em}[_nghost-%COMP%]   .message[_ngcontent-%COMP%]{margin-left:.5rem}"]
});
var NbSpinnerComponent = _NbSpinnerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSpinnerComponent, [{
    type: Component,
    args: [{
      selector: "nb-spinner",
      template: `
    <span class="spin-circle"></span>
    <span class="message" *ngIf="message">{{ message }}</span>
  `,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{opacity:1;position:absolute;border-radius:inherit;inset:0;overflow:hidden;z-index:9999;display:flex;justify-content:center;align-items:center;visibility:visible}:host .spin-circle{animation:spin .8s infinite linear;border-radius:50%;border-style:solid;border-width:.125em;width:1em;height:1em}:host .message{margin-left:.5rem}\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    message: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbSpinnerDirective = class _NbSpinnerDirective {
  /**
   * Directive value - show or hide spinner
   * @param {boolean} val
   */
  set nbSpinner(val) {
    if (this.componentFactory) {
      if (val) {
        this.show();
      } else {
        this.hide();
      }
    } else {
      this.shouldShow = val;
    }
  }
  constructor(directiveView, componentFactoryResolver, renderer, directiveElement) {
    this.directiveView = directiveView;
    this.componentFactoryResolver = componentFactoryResolver;
    this.renderer = renderer;
    this.directiveElement = directiveElement;
    this.shouldShow = false;
    this.spinnerStatus = "basic";
    this.spinnerSize = "medium";
    this.isSpinnerExist = false;
  }
  ngOnInit() {
    this.componentFactory = this.componentFactoryResolver.resolveComponentFactory(NbSpinnerComponent);
    if (this.shouldShow) {
      this.show();
    }
  }
  hide() {
    if (this.isSpinnerExist) {
      this.directiveView.remove();
      this.isSpinnerExist = false;
    }
  }
  show() {
    if (!this.isSpinnerExist) {
      this.spinner = this.directiveView.createComponent(this.componentFactory);
      this.setInstanceInputs(this.spinner.instance);
      this.spinner.changeDetectorRef.detectChanges();
      this.renderer.appendChild(this.directiveElement.nativeElement, this.spinner.location.nativeElement);
      this.isSpinnerExist = true;
    }
  }
  setInstanceInputs(instance) {
    instance.message = this.spinnerMessage;
    typeof this.spinnerStatus !== "undefined" && (instance.status = this.spinnerStatus);
    typeof this.spinnerSize !== "undefined" && (instance.size = this.spinnerSize);
  }
};
_NbSpinnerDirective.ɵfac = function NbSpinnerDirective_Factory(t) {
  return new (t || _NbSpinnerDirective)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
_NbSpinnerDirective.ɵdir = ɵɵdefineDirective({
  type: _NbSpinnerDirective,
  selectors: [["", "nbSpinner", ""]],
  hostVars: 2,
  hostBindings: function NbSpinnerDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("nb-spinner-container", ctx.isSpinnerExist);
    }
  },
  inputs: {
    spinnerMessage: [InputFlags.None, "nbSpinnerMessage", "spinnerMessage"],
    spinnerStatus: [InputFlags.None, "nbSpinnerStatus", "spinnerStatus"],
    spinnerSize: [InputFlags.None, "nbSpinnerSize", "spinnerSize"],
    nbSpinner: "nbSpinner"
  }
});
var NbSpinnerDirective = _NbSpinnerDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSpinnerDirective, [{
    type: Directive,
    args: [{
      selector: "[nbSpinner]"
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }], {
    spinnerMessage: [{
      type: Input,
      args: ["nbSpinnerMessage"]
    }],
    spinnerStatus: [{
      type: Input,
      args: ["nbSpinnerStatus"]
    }],
    spinnerSize: [{
      type: Input,
      args: ["nbSpinnerSize"]
    }],
    nbSpinner: [{
      type: Input,
      args: ["nbSpinner"]
    }],
    isSpinnerExist: [{
      type: HostBinding,
      args: ["class.nb-spinner-container"]
    }]
  });
})();
var _NbSpinnerModule = class _NbSpinnerModule {
};
_NbSpinnerModule.ɵfac = function NbSpinnerModule_Factory(t) {
  return new (t || _NbSpinnerModule)();
};
_NbSpinnerModule.ɵmod = ɵɵdefineNgModule({
  type: _NbSpinnerModule,
  declarations: [NbSpinnerComponent, NbSpinnerDirective],
  imports: [NbSharedModule],
  exports: [NbSpinnerComponent, NbSpinnerDirective]
});
_NbSpinnerModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule]
});
var NbSpinnerModule = _NbSpinnerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSpinnerModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule],
      exports: [NbSpinnerComponent, NbSpinnerDirective],
      declarations: [NbSpinnerComponent, NbSpinnerDirective]
    }]
  }], null, null);
})();
var NB_STEPPER = new InjectionToken("Nebular Stepper Component");
var _NbStepComponent = class _NbStepComponent {
  /**
   * Whether step will be displayed in wizard
   *
   * @type {boolean}
   */
  get hidden() {
    return this._hidden;
  }
  set hidden(value) {
    this._hidden = convertToBoolProperty(value);
  }
  /**
   * Check that label is a TemplateRef.
   *
   * @return boolean
   * */
  get isLabelTemplate() {
    return this.label instanceof TemplateRef;
  }
  /**
   * Whether step is marked as completed.
   *
   * @type {boolean}
   */
  get completed() {
    return this._completed || this.isCompleted;
  }
  set completed(value) {
    this._completed = convertToBoolProperty(value);
  }
  get isCompleted() {
    return this.stepControl ? this.stepControl.valid && this.interacted : this.interacted;
  }
  constructor(stepper) {
    this._hidden = false;
    this._completed = false;
    this.interacted = false;
    this.stepper = stepper;
  }
  /**
   * Mark step as selected
   * */
  select() {
    this.stepper.selected = this;
  }
  /**
   * Reset step and stepControl state
   * */
  reset() {
    this.interacted = false;
    if (this.stepControl) {
      this.stepControl.reset();
    }
  }
};
_NbStepComponent.ɵfac = function NbStepComponent_Factory(t) {
  return new (t || _NbStepComponent)(ɵɵdirectiveInject(NB_STEPPER));
};
_NbStepComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbStepComponent,
  selectors: [["nb-step"]],
  viewQuery: function NbStepComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(TemplateRef, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.content = _t.first);
    }
  },
  inputs: {
    stepControl: "stepControl",
    label: "label",
    hidden: "hidden",
    completed: "completed"
  },
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function NbStepComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, NbStepComponent_ng_template_0_Template, 1, 0, "ng-template");
    }
  },
  encapsulation: 2
});
var NbStepComponent = _NbStepComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepComponent, [{
    type: Component,
    args: [{
      selector: "nb-step",
      template: `
    <ng-template>
      <ng-content></ng-content>
    </ng-template>
  `
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_STEPPER]
    }]
  }], {
    content: [{
      type: ViewChild,
      args: [TemplateRef, {
        static: true
      }]
    }],
    stepControl: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    hidden: [{
      type: Input
    }],
    completed: [{
      type: Input
    }]
  });
})();
var _NbStepperComponent = class _NbStepperComponent {
  constructor() {
    this._selectedIndex = 0;
    this._disableStepNavigation = false;
    this.orientation = "horizontal";
    this._linear = true;
    this.stepChange = new EventEmitter();
  }
  /**
   * Selected step index
   */
  get selectedIndex() {
    return this._selectedIndex;
  }
  set selectedIndex(index) {
    if (!this.steps) {
      this._selectedIndex = index;
      return;
    }
    this.markCurrentStepInteracted();
    if (this.canBeSelected(index)) {
      const previouslySelectedIndex = this._selectedIndex;
      const previouslySelectedStep = this.selected;
      this._selectedIndex = index;
      this.stepChange.emit({
        index: this.selectedIndex,
        step: this.selected,
        previouslySelectedIndex,
        previouslySelectedStep
      });
    }
  }
  /**
   * Disables navigation by clicking on steps. False by default
   * @param {boolean} value
   */
  set disableStepNavigation(value) {
    this._disableStepNavigation = convertToBoolProperty(value);
  }
  get disableStepNavigation() {
    return this._disableStepNavigation;
  }
  /**
   * Selected step component
   */
  get selected() {
    return this.steps ? this.steps.toArray()[this.selectedIndex] : void 0;
  }
  set selected(step) {
    if (!this.steps) {
      return;
    }
    this.selectedIndex = this.steps.toArray().indexOf(step);
  }
  /**
   * Allow moving forward only if the current step is complete
   * @default true
   */
  set linear(value) {
    this._linear = convertToBoolProperty(value);
  }
  get linear() {
    return this._linear;
  }
  get vertical() {
    return this.orientation === "vertical";
  }
  get horizontal() {
    return this.orientation === "horizontal";
  }
  /**
   * Navigate to next step
   * */
  next() {
    this.selectedIndex = Math.min(this.selectedIndex + 1, this.steps.length - 1);
  }
  /**
   * Navigate to previous step
   * */
  previous() {
    this.selectedIndex = Math.max(this.selectedIndex - 1, 0);
  }
  /**
   * Select step if navigation is not disabled
   * @param { NbStepComponent } step
   */
  changeStep(step) {
    if (!this.disableStepNavigation) {
      step.select();
    }
  }
  /**
   * Reset stepper and stepControls to initial state
   * */
  reset() {
    const previouslySelectedIndex = this.selectedIndex;
    const previouslySelectedStep = this.selected;
    this._selectedIndex = 0;
    this.steps.forEach((step) => step.reset());
    this.stepChange.emit({
      index: this.selectedIndex,
      step: this.selected,
      previouslySelectedIndex,
      previouslySelectedStep
    });
  }
  isStepSelected(step) {
    return this.selected === step;
  }
  /*
   * @docs-private
   **/
  getStepTemplate(step) {
    if (step.isLabelTemplate) {
      return step.label;
    }
    return null;
  }
  isStepValid(index) {
    return this.steps.toArray()[index].completed;
  }
  canBeSelected(indexToCheck) {
    const noSteps = !this.steps || this.steps.length === 0;
    if (noSteps || indexToCheck < 0 || indexToCheck >= this.steps.length || indexToCheck === this.selectedIndex) {
      return false;
    }
    if (indexToCheck <= this.selectedIndex || !this.linear) {
      return true;
    }
    let isAllStepsValid = true;
    for (let i = this.selectedIndex; i < indexToCheck; i++) {
      if (!this.isStepValid(i)) {
        isAllStepsValid = false;
        break;
      }
    }
    return isAllStepsValid;
  }
  markCurrentStepInteracted() {
    if (this.selected) {
      this.selected.interacted = true;
    }
  }
};
_NbStepperComponent.ɵfac = function NbStepperComponent_Factory(t) {
  return new (t || _NbStepperComponent)();
};
_NbStepperComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbStepperComponent,
  selectors: [["nb-stepper"]],
  contentQueries: function NbStepperComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbStepComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.steps = _t);
    }
  },
  hostVars: 4,
  hostBindings: function NbStepperComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("vertical", ctx.vertical)("horizontal", ctx.horizontal);
    }
  },
  inputs: {
    selectedIndex: "selectedIndex",
    disableStepNavigation: "disableStepNavigation",
    selected: "selected",
    orientation: "orientation",
    linear: "linear"
  },
  outputs: {
    stepChange: "stepChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: NB_STEPPER,
    useExisting: _NbStepperComponent
  }])],
  ngContentSelectors: _c32,
  decls: 5,
  vars: 2,
  consts: [[1, "header"], [4, "ngFor", "ngForOf"], [1, "step-content"], [3, "ngTemplateOutlet"], ["class", "connector", 3, "connector-past", 4, "ngIf"], ["class", "step", 3, "selected", "completed", "noninteractive", "click", 4, "ngIf"], [1, "connector"], [1, "step", 3, "click"], [1, "label-index"], [4, "ngIf"], ["icon", "checkmark-outline", "pack", "nebular-essentials", 4, "ngIf"], [1, "label"], ["icon", "checkmark-outline", "pack", "nebular-essentials"], [4, "ngTemplateOutlet"]],
  template: function NbStepperComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c31);
      ɵɵtemplate(0, NbStepperComponent_ng_template_0_Template, 1, 0, "ng-template");
      ɵɵelementStart(1, "div", 0);
      ɵɵtemplate(2, NbStepperComponent_ng_container_2_Template, 3, 2, "ng-container", 1);
      ɵɵelementEnd();
      ɵɵelementStart(3, "div", 2);
      ɵɵelementContainer(4, 3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.steps);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.selected == null ? null : ctx.selected.content);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, NbIconComponent],
  styles: [".horizontal[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .step[_ngcontent-%COMP%]{flex-direction:column}.horizontal[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .connector[_ngcontent-%COMP%]{height:2px}.horizontal[_nghost-%COMP%]   .label-index[_ngcontent-%COMP%]{margin-bottom:10px}.vertical[_nghost-%COMP%]{display:flex;height:100%}.vertical[_nghost-%COMP%]   .header[_ngcontent-%COMP%]{flex-direction:column}.vertical[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{margin:0 10px}.vertical[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .connector[_ngcontent-%COMP%]{width:2px}.header[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:10px}.header[_ngcontent-%COMP%]   .connector[_ngcontent-%COMP%]{flex:auto}.header[_ngcontent-%COMP%]   .step[_ngcontent-%COMP%]{display:flex;align-items:center;cursor:pointer}.header[_ngcontent-%COMP%]   .step.noninteractive[_ngcontent-%COMP%]{cursor:default}.header[_ngcontent-%COMP%]   .label-index[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center}.header[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{width:max-content}"]
});
var NbStepperComponent = _NbStepperComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepperComponent, [{
    type: Component,
    args: [{
      selector: "nb-stepper",
      providers: [{
        provide: NB_STEPPER,
        useExisting: NbStepperComponent
      }],
      template: '<ng-template><ng-content select="nb-step"></ng-content></ng-template>\n<div class="header">\n  <ng-container *ngFor="let step of steps; let index = index; let first = first">\n\n    <div *ngIf="!first && !step.hidden"\n         [class.connector-past]="index <= selectedIndex"\n         class="connector"></div>\n\n    <div *ngIf="!step.hidden" class="step"\n         [class.selected]="isStepSelected(step)"\n         [class.completed]="!isStepSelected(step) && step.completed"\n         [class.noninteractive]="disableStepNavigation"\n         (click)="changeStep(step)">\n      <div class="label-index">\n        <span *ngIf="!step.completed || isStepSelected(step)">{{ index + 1 }}</span>\n        <nb-icon *ngIf="!isStepSelected(step) && step.completed" icon="checkmark-outline" pack="nebular-essentials">\n        </nb-icon>\n      </div>\n      <div class="label">\n        <ng-container *ngIf="step.isLabelTemplate">\n          <ng-container *ngTemplateOutlet="getStepTemplate(step)"></ng-container>\n        </ng-container>\n        <span *ngIf="!step.isLabelTemplate">{{ step.label }}</span>\n      </div>\n    </div>\n  </ng-container>\n</div>\n<div class="step-content">\n  <ng-container [ngTemplateOutlet]="selected?.content"></ng-container>\n</div>\n',
      styles: [":host(.horizontal) .header .step{flex-direction:column}:host(.horizontal) .header .connector{height:2px}:host(.horizontal) .label-index{margin-bottom:10px}:host(.vertical){display:flex;height:100%}:host(.vertical) .header{flex-direction:column}:host(.vertical) .header .label{margin:0 10px}:host(.vertical) .header .connector{width:2px}.header{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:10px}.header .connector{flex:auto}.header .step{display:flex;align-items:center;cursor:pointer}.header .step.noninteractive{cursor:default}.header .label-index{display:flex;justify-content:center;align-items:center}.header .label{width:max-content}\n"]
    }]
  }], null, {
    selectedIndex: [{
      type: Input
    }],
    disableStepNavigation: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    linear: [{
      type: Input
    }],
    stepChange: [{
      type: Output
    }],
    vertical: [{
      type: HostBinding,
      args: ["class.vertical"]
    }],
    horizontal: [{
      type: HostBinding,
      args: ["class.horizontal"]
    }],
    steps: [{
      type: ContentChildren,
      args: [NbStepComponent]
    }]
  });
})();
var _NbStepperNextDirective = class _NbStepperNextDirective {
  constructor(stepper) {
    this.stepper = stepper;
    this.type = "submit";
  }
  onClick() {
    this.stepper.next();
  }
};
_NbStepperNextDirective.ɵfac = function NbStepperNextDirective_Factory(t) {
  return new (t || _NbStepperNextDirective)(ɵɵdirectiveInject(NbStepperComponent));
};
_NbStepperNextDirective.ɵdir = ɵɵdefineDirective({
  type: _NbStepperNextDirective,
  selectors: [["button", "nbStepperNext", ""]],
  hostVars: 1,
  hostBindings: function NbStepperNextDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbStepperNextDirective_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵattribute("type", ctx.type);
    }
  },
  inputs: {
    type: "type"
  }
});
var NbStepperNextDirective = _NbStepperNextDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepperNextDirective, [{
    type: Directive,
    args: [{
      selector: "button[nbStepperNext]"
    }]
  }], () => [{
    type: NbStepperComponent
  }], {
    type: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.type"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbStepperPreviousDirective = class _NbStepperPreviousDirective {
  constructor(stepper) {
    this.stepper = stepper;
    this.type = "button";
  }
  onClick() {
    this.stepper.previous();
  }
};
_NbStepperPreviousDirective.ɵfac = function NbStepperPreviousDirective_Factory(t) {
  return new (t || _NbStepperPreviousDirective)(ɵɵdirectiveInject(NbStepperComponent));
};
_NbStepperPreviousDirective.ɵdir = ɵɵdefineDirective({
  type: _NbStepperPreviousDirective,
  selectors: [["button", "nbStepperPrevious", ""]],
  hostVars: 1,
  hostBindings: function NbStepperPreviousDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbStepperPreviousDirective_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵattribute("type", ctx.type);
    }
  },
  inputs: {
    type: "type"
  }
});
var NbStepperPreviousDirective = _NbStepperPreviousDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepperPreviousDirective, [{
    type: Directive,
    args: [{
      selector: "button[nbStepperPrevious]"
    }]
  }], () => [{
    type: NbStepperComponent
  }], {
    type: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.type"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbStepperModule = class _NbStepperModule {
};
_NbStepperModule.ɵfac = function NbStepperModule_Factory(t) {
  return new (t || _NbStepperModule)();
};
_NbStepperModule.ɵmod = ɵɵdefineNgModule({
  type: _NbStepperModule,
  declarations: [NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective],
  imports: [NbSharedModule, NbIconModule],
  exports: [NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective]
});
_NbStepperModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbIconModule]
});
var NbStepperModule = _NbStepperModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbStepperModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbIconModule],
      declarations: [NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective],
      exports: [NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective]
    }]
  }], null, null);
})();
var _NbAccordionComponent = class _NbAccordionComponent {
  constructor() {
    this.openCloseItems = new Subject();
    this.multiValue = false;
  }
  /**
   *  Allow multiple items to be expanded at the same time.
   * @type {boolean}
   */
  get multi() {
    return this.multiValue;
  }
  set multi(val) {
    this.multiValue = convertToBoolProperty(val);
  }
  /**
   * Opens all enabled accordion items.
   */
  openAll() {
    if (this.multi) {
      this.openCloseItems.next(false);
    }
  }
  /**
   * Closes all enabled accordion items.
   */
  closeAll() {
    this.openCloseItems.next(true);
  }
};
_NbAccordionComponent.ɵfac = function NbAccordionComponent_Factory(t) {
  return new (t || _NbAccordionComponent)();
};
_NbAccordionComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbAccordionComponent,
  selectors: [["nb-accordion"]],
  inputs: {
    multi: "multi"
  },
  ngContentSelectors: _c34,
  decls: 1,
  vars: 0,
  template: function NbAccordionComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c33);
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbAccordionComponent = _NbAccordionComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionComponent, [{
    type: Component,
    args: [{
      selector: "nb-accordion",
      template: `
    <ng-content select="nb-accordion-item"></ng-content>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    multi: [{
      type: Input,
      args: ["multi"]
    }]
  });
})();
var _NbAccordionItemComponent = class _NbAccordionItemComponent {
  /**
   * Item is collapse (`true` by default)
   * @type {boolean}
   */
  get collapsed() {
    return this.collapsedValue;
  }
  set collapsed(val) {
    this.collapsedValue = convertToBoolProperty(val);
    this.collapsedChange.emit(this.collapsedValue);
    this.invalidate();
  }
  /**
   * Item is expanded (`false` by default)
   * @type {boolean}
   */
  get expanded() {
    return !this.collapsed;
  }
  set expanded(val) {
    this.collapsedValue = !convertToBoolProperty(val);
  }
  /**
   * Item is disabled and cannot be opened.
   * @type {boolean}
   */
  get disabled() {
    return this.disabledValue;
  }
  set disabled(val) {
    this.disabledValue = convertToBoolProperty(val);
    this.invalidate();
  }
  constructor(accordion, cd) {
    this.accordion = accordion;
    this.cd = cd;
    this.collapsedChange = new EventEmitter();
    this.accordionItemInvalidate = new Subject();
    this.collapsedValue = true;
    this.disabledValue = false;
    this.destroy$ = new Subject();
  }
  /**
   * Open/close the item
   */
  toggle() {
    if (!this.disabled) {
      const willSet = !this.collapsed;
      if (!this.accordion.multi) {
        this.accordion.openCloseItems.next(true);
      }
      this.collapsed = willSet;
    }
  }
  /**
   * Open the item.
   */
  open() {
    !this.disabled && (this.collapsed = false);
  }
  /**
   * Collapse the item.
   */
  close() {
    !this.disabled && (this.collapsed = true);
  }
  ngOnInit() {
    this.accordion.openCloseItems.pipe(takeUntil(this.destroy$)).subscribe((collapsed) => {
      !this.disabled && (this.collapsed = collapsed);
    });
  }
  ngOnChanges(changes) {
    this.accordionItemInvalidate.next(true);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.accordionItemInvalidate.complete();
  }
  invalidate() {
    this.accordionItemInvalidate.next(true);
    this.cd.markForCheck();
  }
};
_NbAccordionItemComponent.ɵfac = function NbAccordionItemComponent_Factory(t) {
  return new (t || _NbAccordionItemComponent)(ɵɵdirectiveInject(NbAccordionComponent, 1), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbAccordionItemComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbAccordionItemComponent,
  selectors: [["nb-accordion-item"]],
  hostVars: 6,
  hostBindings: function NbAccordionItemComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("collapsed", ctx.collapsed)("expanded", ctx.expanded)("disabled", ctx.disabled);
    }
  },
  inputs: {
    collapsed: "collapsed",
    expanded: "expanded",
    disabled: "disabled"
  },
  outputs: {
    collapsedChange: "collapsedChange"
  },
  features: [ɵɵNgOnChangesFeature],
  ngContentSelectors: _c36,
  decls: 2,
  vars: 0,
  template: function NbAccordionItemComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c35);
      ɵɵprojection(0);
      ɵɵprojection(1, 1);
    }
  },
  styles: [_c8],
  changeDetection: 0
});
var NbAccordionItemComponent = _NbAccordionItemComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionItemComponent, [{
    type: Component,
    args: [{
      selector: "nb-accordion-item",
      template: `
    <ng-content select="nb-accordion-item-header"></ng-content>
    <ng-content select="nb-accordion-item-body"></ng-content>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;flex-direction:column}\n"]
    }]
  }], () => [{
    type: NbAccordionComponent,
    decorators: [{
      type: Host
    }]
  }, {
    type: ChangeDetectorRef
  }], {
    collapsed: [{
      type: Input,
      args: ["collapsed"]
    }, {
      type: HostBinding,
      args: ["class.collapsed"]
    }],
    expanded: [{
      type: Input,
      args: ["expanded"]
    }, {
      type: HostBinding,
      args: ["class.expanded"]
    }],
    disabled: [{
      type: Input,
      args: ["disabled"]
    }, {
      type: HostBinding,
      args: ["class.disabled"]
    }],
    collapsedChange: [{
      type: Output
    }]
  });
})();
var accordionItemBodyTrigger = trigger("accordionItemBody", [state("collapsed", style({
  overflow: "hidden",
  visibility: "hidden",
  height: 0
})), state("expanded", style({
  overflow: "hidden",
  visibility: "visible"
})), transition("collapsed => expanded", animate("100ms ease-in")), transition("expanded => collapsed", animate("100ms ease-out"))]);
var _NbAccordionItemBodyComponent = class _NbAccordionItemBodyComponent {
  constructor(accordionItem, cd) {
    this.accordionItem = accordionItem;
    this.cd = cd;
    this.destroy$ = new Subject();
  }
  get state() {
    return this.accordionItem.collapsed ? "collapsed" : "expanded";
  }
  ngOnInit() {
    this.accordionItem.accordionItemInvalidate.pipe(takeUntil(this.destroy$)).subscribe(() => this.cd.markForCheck());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NbAccordionItemBodyComponent.ɵfac = function NbAccordionItemBodyComponent_Factory(t) {
  return new (t || _NbAccordionItemBodyComponent)(ɵɵdirectiveInject(NbAccordionItemComponent, 1), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbAccordionItemBodyComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbAccordionItemBodyComponent,
  selectors: [["nb-accordion-item-body"]],
  ngContentSelectors: _c02,
  decls: 3,
  vars: 3,
  consts: [[1, "item-body"]],
  template: function NbAccordionItemBodyComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div")(1, "div", 0);
      ɵɵprojection(2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("@accordionItemBody", ɵɵpureFunction1(1, _c37, ctx.state));
    }
  },
  encapsulation: 2,
  data: {
    animation: [accordionItemBodyTrigger]
  },
  changeDetection: 0
});
var NbAccordionItemBodyComponent = _NbAccordionItemBodyComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionItemBodyComponent, [{
    type: Component,
    args: [{
      selector: "nb-accordion-item-body",
      template: `
    <div [@accordionItemBody]="{ value: state }">
      <div class="item-body">
        <ng-content></ng-content>
      </div>
    </div>
  `,
      animations: [accordionItemBodyTrigger],
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: NbAccordionItemComponent,
    decorators: [{
      type: Host
    }]
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var _NbAccordionItemHeaderComponent = class _NbAccordionItemHeaderComponent {
  get isCollapsed() {
    return this.accordionItem.collapsed;
  }
  get expanded() {
    return !this.accordionItem.collapsed;
  }
  // issue #794
  get tabbable() {
    return this.accordionItem.disabled ? "-1" : "0";
  }
  get disabled() {
    return this.accordionItem.disabled;
  }
  toggle() {
    this.accordionItem.toggle();
  }
  get state() {
    if (this.isCollapsed) {
      return "collapsed";
    }
    return "expanded";
  }
  constructor(accordionItem, cd) {
    this.accordionItem = accordionItem;
    this.cd = cd;
    this.destroy$ = new Subject();
  }
  ngOnInit() {
    this.accordionItem.accordionItemInvalidate.pipe(takeUntil(this.destroy$)).subscribe(() => this.cd.markForCheck());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NbAccordionItemHeaderComponent.ɵfac = function NbAccordionItemHeaderComponent_Factory(t) {
  return new (t || _NbAccordionItemHeaderComponent)(ɵɵdirectiveInject(NbAccordionItemComponent, 1), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbAccordionItemHeaderComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbAccordionItemHeaderComponent,
  selectors: [["nb-accordion-item-header"]],
  hostVars: 7,
  hostBindings: function NbAccordionItemHeaderComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbAccordionItemHeaderComponent_click_HostBindingHandler() {
        return ctx.toggle();
      })("keydown.space", function NbAccordionItemHeaderComponent_keydown_space_HostBindingHandler() {
        return ctx.toggle();
      })("keydown.enter", function NbAccordionItemHeaderComponent_keydown_enter_HostBindingHandler() {
        return ctx.toggle();
      });
    }
    if (rf & 2) {
      ɵɵattribute("aria-expanded", ctx.expanded)("tabindex", ctx.tabbable)("aria-disabled", ctx.disabled);
      ɵɵclassProp("accordion-item-header-collapsed", ctx.isCollapsed)("accordion-item-header-expanded", ctx.expanded);
    }
  },
  ngContentSelectors: _c39,
  decls: 4,
  vars: 1,
  consts: [["icon", "chevron-down-outline", "pack", "nebular-essentials", "class", "expansion-indicator", 4, "ngIf"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", 1, "expansion-indicator"]],
  template: function NbAccordionItemHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c38);
      ɵɵprojection(0);
      ɵɵprojection(1, 1);
      ɵɵprojection(2, 2);
      ɵɵtemplate(3, NbAccordionItemHeaderComponent_nb_icon_3_Template, 1, 1, "nb-icon", 0);
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵproperty("ngIf", !ctx.disabled);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;align-items:center;cursor:pointer}[_nghost-%COMP%]:focus{outline:0}"],
  data: {
    animation: [trigger("expansionIndicator", [state("expanded", style({
      transform: "rotate(180deg)"
    })), transition("collapsed => expanded", animate("100ms ease-in")), transition("expanded => collapsed", animate("100ms ease-out"))])]
  },
  changeDetection: 0
});
var NbAccordionItemHeaderComponent = _NbAccordionItemHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionItemHeaderComponent, [{
    type: Component,
    args: [{
      selector: "nb-accordion-item-header",
      template: `
    <ng-content select="nb-accordion-item-title"></ng-content>
    <ng-content select="nb-accordion-item-description"></ng-content>
    <ng-content></ng-content>
    <nb-icon icon="chevron-down-outline"
             pack="nebular-essentials"
             [@expansionIndicator]="state"
             *ngIf="!disabled"
             class="expansion-indicator">
    </nb-icon>
  `,
      animations: [trigger("expansionIndicator", [state("expanded", style({
        transform: "rotate(180deg)"
      })), transition("collapsed => expanded", animate("100ms ease-in")), transition("expanded => collapsed", animate("100ms ease-out"))])],
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;align-items:center;cursor:pointer}:host:focus{outline:0}\n"]
    }]
  }], () => [{
    type: NbAccordionItemComponent,
    decorators: [{
      type: Host
    }]
  }, {
    type: ChangeDetectorRef
  }], {
    isCollapsed: [{
      type: HostBinding,
      args: ["class.accordion-item-header-collapsed"]
    }],
    expanded: [{
      type: HostBinding,
      args: ["class.accordion-item-header-expanded"]
    }, {
      type: HostBinding,
      args: ["attr.aria-expanded"]
    }],
    tabbable: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    disabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    toggle: [{
      type: HostListener,
      args: ["click"]
    }, {
      type: HostListener,
      args: ["keydown.space"]
    }, {
      type: HostListener,
      args: ["keydown.enter"]
    }]
  });
})();
var NB_ACCORDION_COMPONENTS = [NbAccordionComponent, NbAccordionItemComponent, NbAccordionItemHeaderComponent, NbAccordionItemBodyComponent];
var _NbAccordionModule = class _NbAccordionModule {
};
_NbAccordionModule.ɵfac = function NbAccordionModule_Factory(t) {
  return new (t || _NbAccordionModule)();
};
_NbAccordionModule.ɵmod = ɵɵdefineNgModule({
  type: _NbAccordionModule,
  declarations: [NbAccordionComponent, NbAccordionItemComponent, NbAccordionItemHeaderComponent, NbAccordionItemBodyComponent],
  imports: [CommonModule, NbIconModule],
  exports: [NbAccordionComponent, NbAccordionItemComponent, NbAccordionItemHeaderComponent, NbAccordionItemBodyComponent]
});
_NbAccordionModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, NbIconModule]
});
var NbAccordionModule = _NbAccordionModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAccordionModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbIconModule],
      exports: [...NB_ACCORDION_COMPONENTS],
      declarations: [...NB_ACCORDION_COMPONENTS],
      providers: []
    }]
  }], null, null);
})();
var NB_BUTTON_GROUP = new InjectionToken("NB_BUTTON_GROUP");
var _NbButtonToggleDirective = class _NbButtonToggleDirective extends NbButton {
  get pressedChange$() {
    return this._pressedChange$.asObservable();
  }
  /**
   * Controls button pressed state
   **/
  get pressed() {
    return this._pressed;
  }
  set pressed(value) {
    if (this.pressed !== convertToBoolProperty(value)) {
      this._pressed = !this.pressed;
      this.pressedChange.emit(this.pressed);
      this._pressedChange$.next({
        source: this,
        pressed: this.pressed
      });
    }
  }
  get basic() {
    return !this.pressed;
  }
  get primary() {
    return this.pressed && (this.status === "basic" || this.status === "primary");
  }
  get success() {
    return this.pressed && this.status === "success";
  }
  get info() {
    return this.pressed && this.status === "info";
  }
  get warning() {
    return this.pressed && this.status === "warning";
  }
  get danger() {
    return this.pressed && this.status === "danger";
  }
  get control() {
    return this.pressed && this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  onClick() {
    if (this.buttonGroup?.multiple || !this.pressed) {
      this.pressed = !this.pressed;
    }
  }
  constructor(renderer, hostElement, cd, zone, statusService, buttonGroup) {
    super(renderer, hostElement, cd, zone, statusService);
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.cd = cd;
    this.zone = zone;
    this.statusService = statusService;
    this.buttonGroup = buttonGroup;
    this._pressedChange$ = new Subject();
    this.appearance = "filled";
    this._pressed = false;
    this.pressedChange = new EventEmitter();
  }
  /**
   * @docs-private
   */
  _updatePressed(value) {
    this.pressed = value;
    this.cd.markForCheck();
  }
};
_NbButtonToggleDirective.ɵfac = function NbButtonToggleDirective_Factory(t) {
  return new (t || _NbButtonToggleDirective)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService), ɵɵdirectiveInject(NB_BUTTON_GROUP, 8));
};
_NbButtonToggleDirective.ɵdir = ɵɵdefineDirective({
  type: _NbButtonToggleDirective,
  selectors: [["button", "nbButtonToggle", ""]],
  hostVars: 17,
  hostBindings: function NbButtonToggleDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbButtonToggleDirective_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵattribute("aria-pressed", ctx.pressed);
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("status-basic", ctx.basic)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-control", ctx.control);
    }
  },
  inputs: {
    appearance: "appearance",
    value: "value",
    pressed: "pressed"
  },
  outputs: {
    pressedChange: "pressedChange"
  },
  exportAs: ["nbButtonToggle"],
  features: [ɵɵProvidersFeature([{
    provide: NbButton,
    useExisting: _NbButtonToggleDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbButtonToggleDirective = _NbButtonToggleDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonToggleDirective, [{
    type: Directive,
    args: [{
      selector: "button[nbButtonToggle]",
      providers: [{
        provide: NbButton,
        useExisting: NbButtonToggleDirective
      }],
      exportAs: "nbButtonToggle"
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_BUTTON_GROUP]
    }]
  }], {
    appearance: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    pressed: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-pressed"]
    }],
    pressedChange: [{
      type: Output
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbButtonGroupComponent = class _NbButtonGroupComponent {
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    if (this.disabled !== convertToBoolProperty(value)) {
      this._disabled = !this.disabled;
    }
  }
  /**
   * Allows to keep multiple button toggles pressed. Off by default.
   */
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = convertToBoolProperty(value);
  }
  /**
   * Sets `filled` appearance
   */
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  /**
   * Sets `outline` appearance
   */
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  /**
   * Sets `ghost` appearance
   */
  get ghost() {
    return this.appearance === "ghost";
  }
  set ghost(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "ghost";
    }
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  constructor(cd, statusService) {
    this.cd = cd;
    this.statusService = statusService;
    this.lastEmittedValue = [];
    this.destroy$ = new Subject();
    this.buttonsChange$ = new Subject();
    this.size = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this.appearance = "filled";
    this._disabled = false;
    this._multiple = false;
    this.valueChange = new EventEmitter();
    this.role = "group";
  }
  ngOnChanges({
    size,
    status,
    shape,
    multiple,
    filled,
    outline,
    ghost,
    disabled
  }) {
    if (size || status || shape || multiple || filled || outline || ghost || disabled) {
      this.syncButtonsProperties(this.buttons?.toArray() || []);
    }
  }
  ngAfterContentInit() {
    this.buttonsChange$.pipe(takeUntil(this.destroy$)).subscribe((buttons) => {
      this.listenButtonPressedState(buttons);
      this.syncButtonsProperties(buttons);
    });
    this.buttons.changes.pipe(
      // `buttons.changes` emit during change detection run after projected content already was initialized.
      // So at this time, it's too late to update projected buttons properties as updating bindings after
      // initialization doesn't make sense. Changes won't be picked up and should cause an "expression changed" error.
      // Instead, we wrap the new buttons list into a promise to defer update to the following microtask and also to
      // trigger change detection one more time.
      switchMap((buttons) => from(Promise.resolve(buttons.toArray()))),
      takeUntil(this.destroy$)
    ).subscribe(this.buttonsChange$);
    this.buttonsChange$.next(this.buttons.toArray());
  }
  listenButtonPressedState(buttons) {
    const toggleButtons = buttons.filter((button) => {
      return button instanceof NbButtonToggleDirective;
    });
    if (!toggleButtons.length) {
      return;
    }
    const buttonsPressedChange$ = toggleButtons.map((button) => button.pressedChange$);
    merge(...buttonsPressedChange$).pipe(filter(({
      pressed
    }) => !this.multiple && pressed), takeUntil(merge(this.buttonsChange$, this.destroy$))).subscribe(({
      source
    }) => {
      toggleButtons.filter((button) => button !== source).forEach((button) => button._updatePressed(false));
    });
    merge(...buttonsPressedChange$).pipe(
      // Use startWith to emit if some buttons are initially pressed.
      startWith(""),
      // Use debounce to emit change once when pressed state change in multiple button toggles.
      debounceTime(0),
      takeUntil(merge(this.buttonsChange$, this.destroy$))
    ).subscribe(() => this.emitCurrentValue(toggleButtons));
  }
  syncButtonsProperties(buttons) {
    buttons.forEach((button) => {
      button.updateProperties({
        appearance: this.appearance,
        size: this.size,
        status: this.status,
        shape: this.shape,
        disabled: this.disabled
      });
    });
  }
  emitCurrentValue(toggleButtons) {
    const pressedToggleValues = toggleButtons.filter((b) => b.pressed && typeof b.value !== "undefined").map((b) => b.value);
    if (pressedToggleValues.length === 0 && this.lastEmittedValue.length === 0) {
      return;
    }
    this.valueChange.emit(pressedToggleValues);
    this.lastEmittedValue = pressedToggleValues;
  }
};
_NbButtonGroupComponent.ɵfac = function NbButtonGroupComponent_Factory(t) {
  return new (t || _NbButtonGroupComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbStatusService));
};
_NbButtonGroupComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbButtonGroupComponent,
  selectors: [["nb-button-group"]],
  contentQueries: function NbButtonGroupComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbButton, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.buttons = _t);
    }
  },
  hostVars: 3,
  hostBindings: function NbButtonGroupComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
      ɵɵclassMap(ctx.additionalClasses);
    }
  },
  inputs: {
    size: "size",
    status: "status",
    shape: "shape",
    appearance: "appearance",
    disabled: "disabled",
    multiple: "multiple",
    filled: "filled",
    outline: "outline",
    ghost: "ghost"
  },
  outputs: {
    valueChange: "valueChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: NB_BUTTON_GROUP,
    useExisting: _NbButtonGroupComponent
  }]), ɵɵNgOnChangesFeature],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function NbButtonGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbButtonGroupComponent = _NbButtonGroupComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonGroupComponent, [{
    type: Component,
    args: [{
      selector: "nb-button-group",
      template: ` <ng-content></ng-content> `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NB_BUTTON_GROUP,
        useExisting: NbButtonGroupComponent
      }]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NbStatusService
  }], {
    buttons: [{
      type: ContentChildren,
      args: [NbButton]
    }],
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    filled: [{
      type: Input
    }],
    outline: [{
      type: Input
    }],
    ghost: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbButtonGroupModule = class _NbButtonGroupModule {
};
_NbButtonGroupModule.ɵfac = function NbButtonGroupModule_Factory(t) {
  return new (t || _NbButtonGroupModule)();
};
_NbButtonGroupModule.ɵmod = ɵɵdefineNgModule({
  type: _NbButtonGroupModule,
  declarations: [NbButtonGroupComponent, NbButtonToggleDirective],
  exports: [NbButtonGroupComponent, NbButtonToggleDirective]
});
_NbButtonGroupModule.ɵinj = ɵɵdefineInjector({});
var NbButtonGroupModule = _NbButtonGroupModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbButtonGroupModule, [{
    type: NgModule,
    args: [{
      declarations: [NbButtonGroupComponent, NbButtonToggleDirective],
      exports: [NbButtonGroupComponent, NbButtonToggleDirective]
    }]
  }], null, null);
})();
var _NbListPageTrackerDirective = class _NbListPageTrackerDirective {
  constructor() {
    this.destroy$ = new Subject();
    this.startPage = 1;
    this.pageChange = new EventEmitter();
    this.observer = new IntersectionObserver((entries) => this.checkForPageChange(entries), {
      threshold: 0.5
    });
  }
  ngAfterViewInit() {
    if (this.listItems && this.listItems.length) {
      this.observeItems();
    }
    this.listItems.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.observeItems());
  }
  ngOnDestroy() {
    this.observer.disconnect && this.observer.disconnect();
  }
  observeItems() {
    this.listItems.forEach((i) => this.observer.observe(i.nativeElement));
  }
  checkForPageChange(entries) {
    const mostVisiblePage = this.findMostVisiblePage(entries);
    if (mostVisiblePage && this.currentPage !== mostVisiblePage) {
      this.currentPage = mostVisiblePage;
      this.pageChange.emit(this.currentPage);
    }
  }
  findMostVisiblePage(entries) {
    const intersectionRatioByPage = /* @__PURE__ */ new Map();
    for (const entry of entries) {
      if (entry.intersectionRatio < 0.5) {
        continue;
      }
      const elementIndex = this.elementIndex(entry.target);
      if (elementIndex === -1) {
        continue;
      }
      const page = this.startPage + Math.floor(elementIndex / this.pageSize);
      let ratio = entry.intersectionRatio;
      if (intersectionRatioByPage.has(page)) {
        ratio += intersectionRatioByPage.get(page);
      }
      intersectionRatioByPage.set(page, ratio);
    }
    let maxRatio = 0;
    let mostVisiblePage;
    intersectionRatioByPage.forEach((ratio, page) => {
      if (ratio > maxRatio) {
        maxRatio = ratio;
        mostVisiblePage = page;
      }
    });
    return mostVisiblePage;
  }
  elementIndex(element) {
    return element.parentElement && element.parentElement.children ? Array.from(element.parentElement.children).indexOf(element) : -1;
  }
};
_NbListPageTrackerDirective.ɵfac = function NbListPageTrackerDirective_Factory(t) {
  return new (t || _NbListPageTrackerDirective)();
};
_NbListPageTrackerDirective.ɵdir = ɵɵdefineDirective({
  type: _NbListPageTrackerDirective,
  selectors: [["", "nbListPageTracker", ""]],
  contentQueries: function NbListPageTrackerDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbListItemComponent, 4, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listItems = _t);
    }
  },
  inputs: {
    pageSize: "pageSize",
    startPage: "startPage"
  },
  outputs: {
    pageChange: "pageChange"
  }
});
var NbListPageTrackerDirective = _NbListPageTrackerDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbListPageTrackerDirective, [{
    type: Directive,
    args: [{
      selector: "[nbListPageTracker]"
    }]
  }], () => [], {
    pageSize: [{
      type: Input
    }],
    startPage: [{
      type: Input
    }],
    pageChange: [{
      type: Output
    }],
    listItems: [{
      type: ContentChildren,
      args: [NbListItemComponent, {
        read: ElementRef
      }]
    }]
  });
})();
var NbScrollableContainerDimensions = class {
};
var _NbInfiniteListDirective = class _NbInfiniteListDirective {
  get elementScroll() {
    return !this.windowScroll;
  }
  /**
   * Prevent subsequent bottom/topThreshold emissions for specified duration after emitting once.
   * In milliseconds.
   */
  set throttleTime(value) {
    this.throttleTime$.next(value);
  }
  get throttleTime() {
    return this.throttleTime$.value;
  }
  /**
   * By default component observes list scroll position.
   * If set to `true`, component will observe position of page scroll instead.
   */
  set listenWindowScroll(value) {
    this.windowScroll = convertToBoolProperty(value);
  }
  onElementScroll() {
    if (this.elementScroll) {
      this.elementScroll$.next();
    }
  }
  constructor(elementRef, scrollService, dimensionsService) {
    this.elementRef = elementRef;
    this.scrollService = scrollService;
    this.dimensionsService = dimensionsService;
    this.destroy$ = new Subject();
    this.windowScroll = false;
    this.elementScroll$ = new Subject();
    this.windowScroll$ = this.scrollService.onScroll().pipe(filter(() => this.windowScroll));
    this.bottomThreshold$ = new Subject();
    this.topThreshold$ = new Subject();
    this.throttleTime$ = new BehaviorSubject(0);
    this.bottomThreshold = new EventEmitter(true);
    this.topThreshold = new EventEmitter(true);
  }
  ngAfterViewInit() {
    merge(this.windowScroll$, this.elementScroll$).pipe(switchMap(() => this.getContainerDimensions()), takeUntil(this.destroy$)).subscribe((dimensions) => this.checkPosition(dimensions));
    this.throttleTime$.pipe(switchMap(() => this.topThreshold$.pipe(throttle(() => interval(this.throttleTime)))), takeUntil(this.destroy$)).subscribe(() => {
      this.topThreshold.emit();
    });
    this.throttleTime$.pipe(switchMap(() => this.bottomThreshold$.pipe(throttle(() => interval(this.throttleTime)))), takeUntil(this.destroy$)).subscribe(() => {
      this.bottomThreshold.emit();
    });
    this.listItems.changes.pipe(
      // For some reason, changes are emitted before list item removed from dom,
      // so dimensions will be incorrect.
      // Check every 50ms for a second if dom and query are in sync.
      // Once they synchronized, we can get proper dimensions.
      switchMap(() => interval(50).pipe(filter(() => this.inSyncWithDom()), take(1), takeUntil(timer(1e3)))),
      switchMap(() => this.getContainerDimensions()),
      takeUntil(this.destroy$)
    ).subscribe((dimensions) => this.checkPosition(dimensions));
    this.getContainerDimensions().subscribe((dimensions) => this.checkPosition(dimensions));
  }
  ngOnDestroy() {
    this.topThreshold$.complete();
    this.bottomThreshold$.complete();
    this.elementScroll$.complete();
    this.destroy$.next();
    this.destroy$.complete();
  }
  checkPosition({
    scrollHeight,
    scrollTop,
    clientHeight
  }) {
    const initialCheck = this.lastScrollPosition == null;
    const manualCheck = this.lastScrollPosition === scrollTop;
    const scrollUp = scrollTop < this.lastScrollPosition;
    const scrollDown = scrollTop > this.lastScrollPosition;
    const distanceToBottom = scrollHeight - scrollTop - clientHeight;
    if ((initialCheck || manualCheck || scrollDown) && distanceToBottom <= this.threshold) {
      this.bottomThreshold$.next();
    }
    if ((initialCheck || scrollUp) && scrollTop <= this.threshold) {
      this.topThreshold$.next();
    }
    this.lastScrollPosition = scrollTop;
  }
  getContainerDimensions() {
    if (this.elementScroll) {
      const {
        scrollTop,
        scrollHeight,
        clientHeight
      } = this.elementRef.nativeElement;
      return of({
        scrollTop,
        scrollHeight,
        clientHeight
      });
    }
    return forkJoin([this.scrollService.getPosition(), this.dimensionsService.getDimensions()]).pipe(map(([scrollPosition, dimensions]) => ({
      scrollTop: scrollPosition.y,
      scrollHeight: dimensions.scrollHeight,
      clientHeight: dimensions.clientHeight
    })));
  }
  inSyncWithDom() {
    return this.elementRef.nativeElement.children.length === this.listItems.length;
  }
};
_NbInfiniteListDirective.ɵfac = function NbInfiniteListDirective_Factory(t) {
  return new (t || _NbInfiniteListDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbLayoutScrollService), ɵɵdirectiveInject(NbLayoutRulerService));
};
_NbInfiniteListDirective.ɵdir = ɵɵdefineDirective({
  type: _NbInfiniteListDirective,
  selectors: [["", "nbInfiniteList", ""]],
  contentQueries: function NbInfiniteListDirective_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbListItemComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.listItems = _t);
    }
  },
  hostBindings: function NbInfiniteListDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("scroll", function NbInfiniteListDirective_scroll_HostBindingHandler() {
        return ctx.onElementScroll();
      });
    }
  },
  inputs: {
    threshold: "threshold",
    throttleTime: "throttleTime",
    listenWindowScroll: "listenWindowScroll"
  },
  outputs: {
    bottomThreshold: "bottomThreshold",
    topThreshold: "topThreshold"
  }
});
var NbInfiniteListDirective = _NbInfiniteListDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbInfiniteListDirective, [{
    type: Directive,
    args: [{
      selector: "[nbInfiniteList]"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbLayoutScrollService
  }, {
    type: NbLayoutRulerService
  }], {
    threshold: [{
      type: Input
    }],
    throttleTime: [{
      type: Input
    }],
    listenWindowScroll: [{
      type: Input
    }],
    bottomThreshold: [{
      type: Output
    }],
    topThreshold: [{
      type: Output
    }],
    onElementScroll: [{
      type: HostListener,
      args: ["scroll"]
    }],
    listItems: [{
      type: ContentChildren,
      args: [NbListItemComponent]
    }]
  });
})();
var components = [NbListComponent, NbListItemComponent, NbListPageTrackerDirective, NbInfiniteListDirective];
var _NbListModule = class _NbListModule {
};
_NbListModule.ɵfac = function NbListModule_Factory(t) {
  return new (t || _NbListModule)();
};
_NbListModule.ɵmod = ɵɵdefineNgModule({
  type: _NbListModule,
  declarations: [NbListComponent, NbListItemComponent, NbListPageTrackerDirective, NbInfiniteListDirective],
  exports: [NbListComponent, NbListItemComponent, NbListPageTrackerDirective, NbInfiniteListDirective]
});
_NbListModule.ɵinj = ɵɵdefineInjector({});
var NbListModule = _NbListModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbListModule, [{
    type: NgModule,
    args: [{
      declarations: components,
      exports: components
    }]
  }], null, null);
})();
var _NbDirectionality = class _NbDirectionality extends Directionality {
};
_NbDirectionality.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbDirectionality_BaseFactory;
  return function NbDirectionality_Factory(t) {
    return (ɵNbDirectionality_BaseFactory || (ɵNbDirectionality_BaseFactory = ɵɵgetInheritedFactory(_NbDirectionality)))(t || _NbDirectionality);
  };
})();
_NbDirectionality.ɵprov = ɵɵdefineInjectable({
  token: _NbDirectionality,
  factory: _NbDirectionality.ɵfac
});
var NbDirectionality = _NbDirectionality;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDirectionality, [{
    type: Injectable
  }], null, null);
})();
var _NbBidiModule = class _NbBidiModule extends BidiModule {
};
_NbBidiModule.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbBidiModule_BaseFactory;
  return function NbBidiModule_Factory(t) {
    return (ɵNbBidiModule_BaseFactory || (ɵNbBidiModule_BaseFactory = ɵɵgetInheritedFactory(_NbBidiModule)))(t || _NbBidiModule);
  };
})();
_NbBidiModule.ɵmod = ɵɵdefineNgModule({
  type: _NbBidiModule
});
_NbBidiModule.ɵinj = ɵɵdefineInjector({
  providers: [{
    provide: NbDirectionality,
    useExisting: Directionality
  }]
});
var NbBidiModule = _NbBidiModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbBidiModule, [{
    type: NgModule,
    args: [{
      providers: [{
        provide: NbDirectionality,
        useExisting: Directionality
      }]
    }]
  }], null, null);
})();
var _NbCellDefDirective = class _NbCellDefDirective extends CdkCellDef {
};
_NbCellDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbCellDefDirective_BaseFactory;
  return function NbCellDefDirective_Factory(t) {
    return (ɵNbCellDefDirective_BaseFactory || (ɵNbCellDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbCellDefDirective)))(t || _NbCellDefDirective);
  };
})();
_NbCellDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbCellDefDirective,
  selectors: [["", "nbCellDef", ""]],
  features: [ɵɵProvidersFeature([{
    provide: CdkCellDef,
    useExisting: _NbCellDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbCellDefDirective = _NbCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbCellDef]",
      providers: [{
        provide: CdkCellDef,
        useExisting: NbCellDefDirective
      }]
    }]
  }], null, null);
})();
var _NbHeaderCellDefDirective = class _NbHeaderCellDefDirective extends CdkHeaderCellDef {
};
_NbHeaderCellDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbHeaderCellDefDirective_BaseFactory;
  return function NbHeaderCellDefDirective_Factory(t) {
    return (ɵNbHeaderCellDefDirective_BaseFactory || (ɵNbHeaderCellDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbHeaderCellDefDirective)))(t || _NbHeaderCellDefDirective);
  };
})();
_NbHeaderCellDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbHeaderCellDefDirective,
  selectors: [["", "nbHeaderCellDef", ""]],
  features: [ɵɵProvidersFeature([{
    provide: CdkHeaderCellDef,
    useExisting: _NbHeaderCellDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbHeaderCellDefDirective = _NbHeaderCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbHeaderCellDef]",
      providers: [{
        provide: CdkHeaderCellDef,
        useExisting: NbHeaderCellDefDirective
      }]
    }]
  }], null, null);
})();
var _NbFooterCellDefDirective = class _NbFooterCellDefDirective extends CdkFooterCellDef {
};
_NbFooterCellDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbFooterCellDefDirective_BaseFactory;
  return function NbFooterCellDefDirective_Factory(t) {
    return (ɵNbFooterCellDefDirective_BaseFactory || (ɵNbFooterCellDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbFooterCellDefDirective)))(t || _NbFooterCellDefDirective);
  };
})();
_NbFooterCellDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbFooterCellDefDirective,
  selectors: [["", "nbFooterCellDef", ""]],
  features: [ɵɵProvidersFeature([{
    provide: CdkFooterCellDef,
    useExisting: _NbFooterCellDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbFooterCellDefDirective = _NbFooterCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFooterCellDef]",
      providers: [{
        provide: CdkFooterCellDef,
        useExisting: NbFooterCellDefDirective
      }]
    }]
  }], null, null);
})();
var NB_SORT_HEADER_COLUMN_DEF = new InjectionToken("NB_SORT_HEADER_COLUMN_DEF");
var _NbColumnDefDirective = class _NbColumnDefDirective extends CdkColumnDef {
  /** Unique name for this column. */
  get name() {
    return this._name;
  }
  set name(value) {
    this._setNameInput(value);
  }
  /** Whether this column should be sticky positioned on the end of the row */
  get stickyEnd() {
    return this._stickyEnd;
  }
  set stickyEnd(value) {
    const prevValue = this._stickyEnd;
    this._stickyEnd = coerceBooleanProperty(value);
    this._hasStickyChanged = prevValue !== this._stickyEnd;
  }
};
_NbColumnDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbColumnDefDirective_BaseFactory;
  return function NbColumnDefDirective_Factory(t) {
    return (ɵNbColumnDefDirective_BaseFactory || (ɵNbColumnDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbColumnDefDirective)))(t || _NbColumnDefDirective);
  };
})();
_NbColumnDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbColumnDefDirective,
  selectors: [["", "nbColumnDef", ""]],
  inputs: {
    name: [InputFlags.None, "nbColumnDef", "name"],
    sticky: "sticky",
    stickyEnd: "stickyEnd"
  },
  features: [ɵɵProvidersFeature([{
    provide: CdkColumnDef,
    useExisting: _NbColumnDefDirective
  }, {
    provide: NB_SORT_HEADER_COLUMN_DEF,
    useExisting: _NbColumnDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbColumnDefDirective = _NbColumnDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbColumnDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbColumnDef]",
      providers: [{
        provide: CdkColumnDef,
        useExisting: NbColumnDefDirective
      }, {
        provide: NB_SORT_HEADER_COLUMN_DEF,
        useExisting: NbColumnDefDirective
      }]
    }]
  }], null, {
    name: [{
      type: Input,
      args: ["nbColumnDef"]
    }],
    sticky: [{
      type: Input
    }],
    stickyEnd: [{
      type: Input
    }]
  });
})();
var _NbHeaderCellDirective = class _NbHeaderCellDirective extends CdkHeaderCell {
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    elementRef.nativeElement.classList.add(`nb-column-${columnDef.cssClassFriendlyName}`);
  }
};
_NbHeaderCellDirective.ɵfac = function NbHeaderCellDirective_Factory(t) {
  return new (t || _NbHeaderCellDirective)(ɵɵdirectiveInject(NbColumnDefDirective), ɵɵdirectiveInject(ElementRef));
};
_NbHeaderCellDirective.ɵdir = ɵɵdefineDirective({
  type: _NbHeaderCellDirective,
  selectors: [["nb-header-cell"], ["th", "nbHeaderCell", ""]],
  hostAttrs: ["role", "columnheader", 1, "nb-header-cell"],
  features: [ɵɵInheritDefinitionFeature]
});
var NbHeaderCellDirective = _NbHeaderCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderCellDirective, [{
    type: Directive,
    args: [{
      selector: "nb-header-cell, th[nbHeaderCell]",
      host: {
        "class": "nb-header-cell",
        "role": "columnheader"
      }
    }]
  }], () => [{
    type: NbColumnDefDirective
  }, {
    type: ElementRef
  }], null);
})();
var _NbFooterCellDirective = class _NbFooterCellDirective extends CdkFooterCell {
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    elementRef.nativeElement.classList.add(`nb-column-${columnDef.cssClassFriendlyName}`);
  }
};
_NbFooterCellDirective.ɵfac = function NbFooterCellDirective_Factory(t) {
  return new (t || _NbFooterCellDirective)(ɵɵdirectiveInject(NbColumnDefDirective), ɵɵdirectiveInject(ElementRef));
};
_NbFooterCellDirective.ɵdir = ɵɵdefineDirective({
  type: _NbFooterCellDirective,
  selectors: [["nb-footer-cell"], ["td", "nbFooterCell", ""]],
  hostAttrs: ["role", "gridcell", 1, "nb-footer-cell"],
  features: [ɵɵInheritDefinitionFeature]
});
var NbFooterCellDirective = _NbFooterCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterCellDirective, [{
    type: Directive,
    args: [{
      selector: "nb-footer-cell, td[nbFooterCell]",
      host: {
        "class": "nb-footer-cell",
        "role": "gridcell"
      }
    }]
  }], () => [{
    type: NbColumnDefDirective
  }, {
    type: ElementRef
  }], null);
})();
var _NbCellDirective = class _NbCellDirective extends CdkCell {
  constructor(columnDef, elementRef) {
    super(columnDef, elementRef);
    elementRef.nativeElement.classList.add(`nb-column-${columnDef.cssClassFriendlyName}`);
  }
};
_NbCellDirective.ɵfac = function NbCellDirective_Factory(t) {
  return new (t || _NbCellDirective)(ɵɵdirectiveInject(NbColumnDefDirective), ɵɵdirectiveInject(ElementRef));
};
_NbCellDirective.ɵdir = ɵɵdefineDirective({
  type: _NbCellDirective,
  selectors: [["nb-cell"], ["td", "nbCell", ""]],
  hostAttrs: ["role", "gridcell", 1, "nb-cell"],
  features: [ɵɵInheritDefinitionFeature]
});
var NbCellDirective = _NbCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCellDirective, [{
    type: Directive,
    args: [{
      selector: "nb-cell, td[nbCell]",
      host: {
        "class": "nb-cell",
        "role": "gridcell"
      }
    }]
  }], () => [{
    type: NbColumnDefDirective
  }, {
    type: ElementRef
  }], null);
})();
var NbDataSource = class extends DataSource {
};
var _NbDataRowOutletDirective = class _NbDataRowOutletDirective extends DataRowOutlet {
};
_NbDataRowOutletDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbDataRowOutletDirective_BaseFactory;
  return function NbDataRowOutletDirective_Factory(t) {
    return (ɵNbDataRowOutletDirective_BaseFactory || (ɵNbDataRowOutletDirective_BaseFactory = ɵɵgetInheritedFactory(_NbDataRowOutletDirective)))(t || _NbDataRowOutletDirective);
  };
})();
_NbDataRowOutletDirective.ɵdir = ɵɵdefineDirective({
  type: _NbDataRowOutletDirective,
  selectors: [["", "nbRowOutlet", ""]],
  features: [ɵɵProvidersFeature([{
    provide: DataRowOutlet,
    useExisting: _NbDataRowOutletDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbDataRowOutletDirective = _NbDataRowOutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDataRowOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbRowOutlet]",
      providers: [{
        provide: DataRowOutlet,
        useExisting: NbDataRowOutletDirective
      }]
    }]
  }], null, null);
})();
var _NbHeaderRowOutletDirective = class _NbHeaderRowOutletDirective extends HeaderRowOutlet {
};
_NbHeaderRowOutletDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbHeaderRowOutletDirective_BaseFactory;
  return function NbHeaderRowOutletDirective_Factory(t) {
    return (ɵNbHeaderRowOutletDirective_BaseFactory || (ɵNbHeaderRowOutletDirective_BaseFactory = ɵɵgetInheritedFactory(_NbHeaderRowOutletDirective)))(t || _NbHeaderRowOutletDirective);
  };
})();
_NbHeaderRowOutletDirective.ɵdir = ɵɵdefineDirective({
  type: _NbHeaderRowOutletDirective,
  selectors: [["", "nbHeaderRowOutlet", ""]],
  features: [ɵɵProvidersFeature([{
    provide: HeaderRowOutlet,
    useExisting: _NbHeaderRowOutletDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbHeaderRowOutletDirective = _NbHeaderRowOutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderRowOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbHeaderRowOutlet]",
      providers: [{
        provide: HeaderRowOutlet,
        useExisting: NbHeaderRowOutletDirective
      }]
    }]
  }], null, null);
})();
var _NbFooterRowOutletDirective = class _NbFooterRowOutletDirective extends FooterRowOutlet {
};
_NbFooterRowOutletDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbFooterRowOutletDirective_BaseFactory;
  return function NbFooterRowOutletDirective_Factory(t) {
    return (ɵNbFooterRowOutletDirective_BaseFactory || (ɵNbFooterRowOutletDirective_BaseFactory = ɵɵgetInheritedFactory(_NbFooterRowOutletDirective)))(t || _NbFooterRowOutletDirective);
  };
})();
_NbFooterRowOutletDirective.ɵdir = ɵɵdefineDirective({
  type: _NbFooterRowOutletDirective,
  selectors: [["", "nbFooterRowOutlet", ""]],
  features: [ɵɵProvidersFeature([{
    provide: FooterRowOutlet,
    useExisting: _NbFooterRowOutletDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbFooterRowOutletDirective = _NbFooterRowOutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterRowOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFooterRowOutlet]",
      providers: [{
        provide: FooterRowOutlet,
        useExisting: NbFooterRowOutletDirective
      }]
    }]
  }], null, null);
})();
var _NbNoDataRowOutletDirective = class _NbNoDataRowOutletDirective extends NoDataRowOutlet {
};
_NbNoDataRowOutletDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbNoDataRowOutletDirective_BaseFactory;
  return function NbNoDataRowOutletDirective_Factory(t) {
    return (ɵNbNoDataRowOutletDirective_BaseFactory || (ɵNbNoDataRowOutletDirective_BaseFactory = ɵɵgetInheritedFactory(_NbNoDataRowOutletDirective)))(t || _NbNoDataRowOutletDirective);
  };
})();
_NbNoDataRowOutletDirective.ɵdir = ɵɵdefineDirective({
  type: _NbNoDataRowOutletDirective,
  selectors: [["", "nbNoDataRowOutlet", ""]],
  features: [ɵɵProvidersFeature([{
    provide: NoDataRowOutlet,
    useExisting: _NbNoDataRowOutletDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbNoDataRowOutletDirective = _NbNoDataRowOutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbNoDataRowOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbNoDataRowOutlet]",
      providers: [{
        provide: NoDataRowOutlet,
        useExisting: NbNoDataRowOutletDirective
      }]
    }]
  }], null, null);
})();
var _NbCellOutletDirective = class _NbCellOutletDirective extends CdkCellOutlet {
};
_NbCellOutletDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbCellOutletDirective_BaseFactory;
  return function NbCellOutletDirective_Factory(t) {
    return (ɵNbCellOutletDirective_BaseFactory || (ɵNbCellOutletDirective_BaseFactory = ɵɵgetInheritedFactory(_NbCellOutletDirective)))(t || _NbCellOutletDirective);
  };
})();
_NbCellOutletDirective.ɵdir = ɵɵdefineDirective({
  type: _NbCellOutletDirective,
  selectors: [["", "nbCellOutlet", ""]],
  features: [ɵɵProvidersFeature([{
    provide: CdkCellOutlet,
    useExisting: _NbCellOutletDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbCellOutletDirective = _NbCellOutletDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbCellOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[nbCellOutlet]",
      providers: [{
        provide: CdkCellOutlet,
        useExisting: NbCellOutletDirective
      }]
    }]
  }], null, null);
})();
var _NbHeaderRowDefDirective = class _NbHeaderRowDefDirective extends CdkHeaderRowDef {
};
_NbHeaderRowDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbHeaderRowDefDirective_BaseFactory;
  return function NbHeaderRowDefDirective_Factory(t) {
    return (ɵNbHeaderRowDefDirective_BaseFactory || (ɵNbHeaderRowDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbHeaderRowDefDirective)))(t || _NbHeaderRowDefDirective);
  };
})();
_NbHeaderRowDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbHeaderRowDefDirective,
  selectors: [["", "nbHeaderRowDef", ""]],
  inputs: {
    columns: [InputFlags.None, "nbHeaderRowDef", "columns"],
    sticky: [InputFlags.None, "nbHeaderRowDefSticky", "sticky"]
  },
  features: [ɵɵProvidersFeature([{
    provide: CdkHeaderRowDef,
    useExisting: _NbHeaderRowDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbHeaderRowDefDirective = _NbHeaderRowDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbHeaderRowDef]",
      providers: [{
        provide: CdkHeaderRowDef,
        useExisting: NbHeaderRowDefDirective
      }]
    }]
  }], null, {
    columns: [{
      type: Input,
      args: ["nbHeaderRowDef"]
    }],
    sticky: [{
      type: Input,
      args: ["nbHeaderRowDefSticky"]
    }]
  });
})();
var _NbFooterRowDefDirective = class _NbFooterRowDefDirective extends CdkFooterRowDef {
};
_NbFooterRowDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbFooterRowDefDirective_BaseFactory;
  return function NbFooterRowDefDirective_Factory(t) {
    return (ɵNbFooterRowDefDirective_BaseFactory || (ɵNbFooterRowDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbFooterRowDefDirective)))(t || _NbFooterRowDefDirective);
  };
})();
_NbFooterRowDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbFooterRowDefDirective,
  selectors: [["", "nbFooterRowDef", ""]],
  inputs: {
    columns: [InputFlags.None, "nbFooterRowDef", "columns"],
    sticky: [InputFlags.None, "nbFooterRowDefSticky", "sticky"]
  },
  features: [ɵɵProvidersFeature([{
    provide: CdkFooterRowDef,
    useExisting: _NbFooterRowDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbFooterRowDefDirective = _NbFooterRowDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFooterRowDef]",
      providers: [{
        provide: CdkFooterRowDef,
        useExisting: NbFooterRowDefDirective
      }]
    }]
  }], null, {
    columns: [{
      type: Input,
      args: ["nbFooterRowDef"]
    }],
    sticky: [{
      type: Input,
      args: ["nbFooterRowDefSticky"]
    }]
  });
})();
var _NbRowDefDirective = class _NbRowDefDirective extends CdkRowDef {
};
_NbRowDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbRowDefDirective_BaseFactory;
  return function NbRowDefDirective_Factory(t) {
    return (ɵNbRowDefDirective_BaseFactory || (ɵNbRowDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbRowDefDirective)))(t || _NbRowDefDirective);
  };
})();
_NbRowDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbRowDefDirective,
  selectors: [["", "nbRowDef", ""]],
  inputs: {
    columns: [InputFlags.None, "nbRowDefColumns", "columns"],
    when: [InputFlags.None, "nbRowDefWhen", "when"]
  },
  features: [ɵɵProvidersFeature([{
    provide: CdkRowDef,
    useExisting: _NbRowDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbRowDefDirective = _NbRowDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbRowDef]",
      providers: [{
        provide: CdkRowDef,
        useExisting: NbRowDefDirective
      }]
    }]
  }], null, {
    columns: [{
      type: Input,
      args: ["nbRowDefColumns"]
    }],
    when: [{
      type: Input,
      args: ["nbRowDefWhen"]
    }]
  });
})();
var _NbHeaderRowComponent = class _NbHeaderRowComponent extends CdkHeaderRow {
};
_NbHeaderRowComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbHeaderRowComponent_BaseFactory;
  return function NbHeaderRowComponent_Factory(t) {
    return (ɵNbHeaderRowComponent_BaseFactory || (ɵNbHeaderRowComponent_BaseFactory = ɵɵgetInheritedFactory(_NbHeaderRowComponent)))(t || _NbHeaderRowComponent);
  };
})();
_NbHeaderRowComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbHeaderRowComponent,
  selectors: [["nb-header-row"], ["tr", "nbHeaderRow", ""]],
  hostAttrs: ["role", "row", 1, "nb-header-row"],
  features: [ɵɵProvidersFeature([{
    provide: CdkHeaderRow,
    useExisting: _NbHeaderRowComponent
  }]), ɵɵInheritDefinitionFeature],
  decls: 1,
  vars: 0,
  consts: [["nbCellOutlet", ""]],
  template: function NbHeaderRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [NbCellOutletDirective],
  encapsulation: 2
});
var NbHeaderRowComponent = _NbHeaderRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbHeaderRowComponent, [{
    type: Component,
    args: [{
      selector: "nb-header-row, tr[nbHeaderRow]",
      template: `
    <ng-container nbCellOutlet></ng-container>`,
      host: {
        "class": "nb-header-row",
        "role": "row"
      },
      providers: [{
        provide: CdkHeaderRow,
        useExisting: NbHeaderRowComponent
      }]
    }]
  }], null, null);
})();
var _NbFooterRowComponent = class _NbFooterRowComponent extends CdkFooterRow {
};
_NbFooterRowComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbFooterRowComponent_BaseFactory;
  return function NbFooterRowComponent_Factory(t) {
    return (ɵNbFooterRowComponent_BaseFactory || (ɵNbFooterRowComponent_BaseFactory = ɵɵgetInheritedFactory(_NbFooterRowComponent)))(t || _NbFooterRowComponent);
  };
})();
_NbFooterRowComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbFooterRowComponent,
  selectors: [["nb-footer-row"], ["tr", "nbFooterRow", ""]],
  hostAttrs: ["role", "row", 1, "nb-footer-row"],
  features: [ɵɵProvidersFeature([{
    provide: CdkFooterRow,
    useExisting: _NbFooterRowComponent
  }]), ɵɵInheritDefinitionFeature],
  decls: 1,
  vars: 0,
  consts: [["nbCellOutlet", ""]],
  template: function NbFooterRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [NbCellOutletDirective],
  encapsulation: 2
});
var NbFooterRowComponent = _NbFooterRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFooterRowComponent, [{
    type: Component,
    args: [{
      selector: "nb-footer-row, tr[nbFooterRow]",
      template: `
    <ng-container nbCellOutlet></ng-container>`,
      host: {
        "class": "nb-footer-row",
        "role": "row"
      },
      providers: [{
        provide: CdkFooterRow,
        useExisting: NbFooterRowComponent
      }]
    }]
  }], null, null);
})();
var _NbRowComponent = class _NbRowComponent extends CdkRow {
};
_NbRowComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbRowComponent_BaseFactory;
  return function NbRowComponent_Factory(t) {
    return (ɵNbRowComponent_BaseFactory || (ɵNbRowComponent_BaseFactory = ɵɵgetInheritedFactory(_NbRowComponent)))(t || _NbRowComponent);
  };
})();
_NbRowComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbRowComponent,
  selectors: [["nb-row"], ["tr", "nbRow", ""]],
  hostAttrs: ["role", "row", 1, "nb-row"],
  features: [ɵɵProvidersFeature([{
    provide: CdkRow,
    useExisting: _NbRowComponent
  }]), ɵɵInheritDefinitionFeature],
  decls: 1,
  vars: 0,
  consts: [["nbCellOutlet", ""]],
  template: function NbRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [NbCellOutletDirective],
  encapsulation: 2
});
var NbRowComponent = _NbRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRowComponent, [{
    type: Component,
    args: [{
      selector: "nb-row, tr[nbRow]",
      template: `
    <ng-container nbCellOutlet></ng-container>`,
      host: {
        "class": "nb-row",
        "role": "row"
      },
      providers: [{
        provide: CdkRow,
        useExisting: NbRowComponent
      }]
    }]
  }], null, null);
})();
var NbCdkRowDef = CdkRowDef;
var NbCdkRow = CdkRow;
var NbCdkCellDef = CdkCellDef;
var NbCdkHeaderRowDef = CdkHeaderRowDef;
var NbCdkHeaderRow = CdkHeaderRow;
var NbCdkHeaderCellDef = CdkHeaderCellDef;
var NbCdkFooterRowDef = CdkFooterRowDef;
var NbCdkFooterRow = CdkFooterRow;
var NbCdkFooterCellDef = CdkFooterCellDef;
var NbCdkColumnDef = CdkColumnDef;
var NbCdkCell = CdkCell;
var NbCdkHeaderCell = CdkHeaderCell;
var NbCdkFooterCell = CdkFooterCell;
var NB_STICKY_POSITIONING_LISTENER = STICKY_POSITIONING_LISTENER;
var NB_TABLE_TEMPLATE = `
  <ng-container nbHeaderRowOutlet></ng-container>
  <ng-container nbRowOutlet></ng-container>
  <ng-container nbNoDataRowOutlet></ng-container>
  <ng-container nbFooterRowOutlet></ng-container>
`;
var NB_VIEW_REPEATER_STRATEGY = _VIEW_REPEATER_STRATEGY;
var NB_COALESCED_STYLE_SCHEDULER = _COALESCED_STYLE_SCHEDULER;
var NB_TABLE_PROVIDERS = [{
  provide: NB_VIEW_REPEATER_STRATEGY,
  useClass: _DisposeViewRepeaterStrategy
}, {
  provide: NB_COALESCED_STYLE_SCHEDULER,
  useClass: _CoalescedStyleScheduler
}];
var _NbTable = class _NbTable extends CdkTable {
  constructor(differs, changeDetectorRef, elementRef, role, dir, document, platform, _viewRepeater, _coalescedStyleScheduler, _viewportRuler, _stickyPositioningListener) {
    super(differs, changeDetectorRef, elementRef, role, dir, document, platform, _viewRepeater, _coalescedStyleScheduler, _viewportRuler, _stickyPositioningListener);
    this._viewRepeater = _viewRepeater;
    this._coalescedStyleScheduler = _coalescedStyleScheduler;
    this._stickyPositioningListener = _stickyPositioningListener;
  }
};
_NbTable.ɵfac = function NbTable_Factory(t) {
  return new (t || _NbTable)(ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵinjectAttribute("role"), ɵɵdirectiveInject(NbDirectionality), ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbPlatform), ɵɵdirectiveInject(_VIEW_REPEATER_STRATEGY), ɵɵdirectiveInject(_COALESCED_STYLE_SCHEDULER), ɵɵdirectiveInject(NbViewportRulerAdapter), ɵɵdirectiveInject(NB_STICKY_POSITIONING_LISTENER, 12));
};
_NbTable.ɵcmp = ɵɵdefineComponent({
  type: _NbTable,
  selectors: [["nb-table-not-implemented"]],
  features: [ɵɵProvidersFeature(NB_TABLE_PROVIDERS), ɵɵInheritDefinitionFeature],
  decls: 0,
  vars: 0,
  template: function NbTable_Template(rf, ctx) {
  },
  encapsulation: 2
});
var NbTable = _NbTable;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTable, [{
    type: Component,
    args: [{
      selector: "nb-table-not-implemented",
      template: ``,
      providers: NB_TABLE_PROVIDERS
    }]
  }], () => [{
    type: IterableDiffers
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["role"]
    }]
  }, {
    type: NbDirectionality
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPlatform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [_VIEW_REPEATER_STRATEGY]
    }]
  }, {
    type: _CoalescedStyleScheduler,
    decorators: [{
      type: Inject,
      args: [_COALESCED_STYLE_SCHEDULER]
    }]
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: SkipSelf
    }, {
      type: Inject,
      args: [NB_STICKY_POSITIONING_LISTENER]
    }]
  }], null);
})();
var COMPONENTS$2 = [
  NbTable,
  // Template defs
  NbHeaderCellDefDirective,
  NbHeaderRowDefDirective,
  NbColumnDefDirective,
  NbCellDefDirective,
  NbRowDefDirective,
  NbFooterCellDefDirective,
  NbFooterRowDefDirective,
  // Outlets
  NbDataRowOutletDirective,
  NbHeaderRowOutletDirective,
  NbFooterRowOutletDirective,
  NbNoDataRowOutletDirective,
  NbCellOutletDirective,
  // Cell directives
  NbHeaderCellDirective,
  NbCellDirective,
  NbFooterCellDirective,
  // Row directives
  NbHeaderRowComponent,
  NbRowComponent,
  NbFooterRowComponent
];
var _NbTableModule = class _NbTableModule extends CdkTableModule {
};
_NbTableModule.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbTableModule_BaseFactory;
  return function NbTableModule_Factory(t) {
    return (ɵNbTableModule_BaseFactory || (ɵNbTableModule_BaseFactory = ɵɵgetInheritedFactory(_NbTableModule)))(t || _NbTableModule);
  };
})();
_NbTableModule.ɵmod = ɵɵdefineNgModule({
  type: _NbTableModule,
  declarations: [
    NbTable,
    // Template defs
    NbHeaderCellDefDirective,
    NbHeaderRowDefDirective,
    NbColumnDefDirective,
    NbCellDefDirective,
    NbRowDefDirective,
    NbFooterCellDefDirective,
    NbFooterRowDefDirective,
    // Outlets
    NbDataRowOutletDirective,
    NbHeaderRowOutletDirective,
    NbFooterRowOutletDirective,
    NbNoDataRowOutletDirective,
    NbCellOutletDirective,
    // Cell directives
    NbHeaderCellDirective,
    NbCellDirective,
    NbFooterCellDirective,
    // Row directives
    NbHeaderRowComponent,
    NbRowComponent,
    NbFooterRowComponent
  ],
  imports: [NbBidiModule],
  exports: [
    NbTable,
    // Template defs
    NbHeaderCellDefDirective,
    NbHeaderRowDefDirective,
    NbColumnDefDirective,
    NbCellDefDirective,
    NbRowDefDirective,
    NbFooterCellDefDirective,
    NbFooterRowDefDirective,
    // Outlets
    NbDataRowOutletDirective,
    NbHeaderRowOutletDirective,
    NbFooterRowOutletDirective,
    NbNoDataRowOutletDirective,
    NbCellOutletDirective,
    // Cell directives
    NbHeaderCellDirective,
    NbCellDirective,
    NbFooterCellDirective,
    // Row directives
    NbHeaderRowComponent,
    NbRowComponent,
    NbFooterRowComponent
  ]
});
_NbTableModule.ɵinj = ɵɵdefineInjector({
  imports: [NbBidiModule]
});
var NbTableModule = _NbTableModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTableModule, [{
    type: NgModule,
    args: [{
      imports: [NbBidiModule],
      declarations: [...COMPONENTS$2],
      exports: [...COMPONENTS$2]
    }]
  }], null, null);
})();
var NB_DIALOG_CONFIG = new InjectionToken("Default dialog options");
var NbDialogConfig = class {
  constructor(config) {
    this.hasBackdrop = true;
    this.backdropClass = "overlay-backdrop";
    this.dialogClass = "";
    this.closeOnBackdropClick = true;
    this.closeOnEsc = true;
    this.hasScroll = false;
    this.autoFocus = true;
    Object.assign(this, config);
  }
};
var NbDialogRef = class {
  constructor(overlayRef) {
    this.overlayRef = overlayRef;
    this.onClose$ = new Subject();
    this.onClose = this.onClose$.asObservable();
    this.onBackdropClick = this.overlayRef.backdropClick();
  }
  /**
   * Hides dialog.
   * */
  close(res) {
    this.overlayRef.detach();
    this.overlayRef.dispose();
    this.onClose$.next(res);
    this.onClose$.complete();
  }
};
var _NbDialogContainerComponent = class _NbDialogContainerComponent {
  constructor(config, elementRef, focusTrapFactory) {
    this.config = config;
    this.elementRef = elementRef;
    this.focusTrapFactory = focusTrapFactory;
  }
  ngOnInit() {
    if (this.config.autoFocus) {
      this.focusTrap = this.focusTrapFactory.create(this.elementRef.nativeElement);
      this.focusTrap.blurPreviouslyFocusedElement();
      this.focusTrap.focusInitialElement();
    }
  }
  ngOnDestroy() {
    if (this.config.autoFocus && this.focusTrap) {
      this.focusTrap.restoreFocus();
    }
  }
  attachComponentPortal(portal) {
    return this.portalOutlet.attachComponentPortal(portal);
  }
  attachTemplatePortal(portal) {
    return this.portalOutlet.attachTemplatePortal(portal);
  }
};
_NbDialogContainerComponent.ɵfac = function NbDialogContainerComponent_Factory(t) {
  return new (t || _NbDialogContainerComponent)(ɵɵdirectiveInject(NbDialogConfig), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbFocusTrapFactoryService));
};
_NbDialogContainerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbDialogContainerComponent,
  selectors: [["nb-dialog-container"]],
  viewQuery: function NbDialogContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbPortalOutletDirective, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);
    }
  },
  decls: 1,
  vars: 0,
  consts: [["nbPortalOutlet", ""]],
  template: function NbDialogContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbDialogContainerComponent_ng_template_0_Template, 0, 0, "ng-template", 0);
    }
  },
  dependencies: [NbPortalOutletDirective],
  encapsulation: 2
});
var NbDialogContainerComponent = _NbDialogContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDialogContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-dialog-container",
      template: "<ng-template nbPortalOutlet></ng-template>"
    }]
  }], () => [{
    type: NbDialogConfig
  }, {
    type: ElementRef
  }, {
    type: NbFocusTrapFactoryService
  }], {
    portalOutlet: [{
      type: ViewChild,
      args: [NbPortalOutletDirective, {
        static: true
      }]
    }]
  });
})();
var _NbDialogService = class _NbDialogService {
  constructor(document, globalConfig, positionBuilder, overlay, injector, cfr) {
    this.document = document;
    this.globalConfig = globalConfig;
    this.positionBuilder = positionBuilder;
    this.overlay = overlay;
    this.injector = injector;
    this.cfr = cfr;
  }
  /**
   * Opens new instance of the dialog, may receive optional config.
   * */
  open(content, userConfig = {}) {
    const config = new NbDialogConfig(__spreadValues(__spreadValues({}, this.globalConfig), userConfig));
    const overlayRef = this.createOverlay(config);
    const dialogRef = new NbDialogRef(overlayRef);
    const container = this.createContainer(config, overlayRef);
    this.createContent(config, content, container, dialogRef);
    this.registerCloseListeners(config, overlayRef, dialogRef);
    return dialogRef;
  }
  createOverlay(config) {
    const positionStrategy = this.createPositionStrategy();
    const scrollStrategy = this.createScrollStrategy(config.hasScroll);
    return this.overlay.create({
      positionStrategy,
      scrollStrategy,
      hasBackdrop: config.hasBackdrop,
      backdropClass: config.backdropClass,
      panelClass: config.dialogClass
    });
  }
  createPositionStrategy() {
    return this.positionBuilder.global().centerVertically().centerHorizontally();
  }
  createScrollStrategy(hasScroll) {
    if (hasScroll) {
      return this.overlay.scrollStrategies.noop();
    } else {
      return this.overlay.scrollStrategies.block();
    }
  }
  createContainer(config, overlayRef) {
    const injector = new NbPortalInjector(this.createInjector(config), new WeakMap([[NbDialogConfig, config]]));
    const containerPortal = new NbComponentPortal(NbDialogContainerComponent, null, injector, this.cfr);
    const containerRef = overlayRef.attach(containerPortal);
    return containerRef.instance;
  }
  createContent(config, content, container, dialogRef) {
    if (content instanceof TemplateRef) {
      const portal = this.createTemplatePortal(config, content, dialogRef);
      container.attachTemplatePortal(portal);
    } else {
      const portal = this.createComponentPortal(config, content, dialogRef);
      dialogRef.componentRef = container.attachComponentPortal(portal);
      if (config.context) {
        Object.assign(dialogRef.componentRef.instance, __spreadValues({}, config.context));
      }
    }
  }
  createTemplatePortal(config, content, dialogRef) {
    return new NbTemplatePortal(content, null, {
      $implicit: config.context,
      dialogRef
    });
  }
  /**
   * We're creating portal with custom injector provided through config or using global injector.
   * This approach provides us capability inject `NbDialogRef` in dialog component.
   * */
  createComponentPortal(config, content, dialogRef) {
    const injector = this.createInjector(config);
    const portalInjector = new NbPortalInjector(injector, new WeakMap([[NbDialogRef, dialogRef]]));
    return new NbComponentPortal(content, config.viewContainerRef, portalInjector);
  }
  createInjector(config) {
    return config.viewContainerRef && config.viewContainerRef.injector || this.injector;
  }
  registerCloseListeners(config, overlayRef, dialogRef) {
    if (config.closeOnBackdropClick) {
      overlayRef.backdropClick().subscribe(() => dialogRef.close());
    }
    if (config.closeOnEsc) {
      fromEvent(this.document, "keyup").pipe(filter((event) => event.keyCode === 27), takeUntil(dialogRef.onClose)).subscribe(() => dialogRef.close());
    }
  }
};
_NbDialogService.ɵfac = function NbDialogService_Factory(t) {
  return new (t || _NbDialogService)(ɵɵinject(NB_DOCUMENT), ɵɵinject(NB_DIALOG_CONFIG), ɵɵinject(NbPositionBuilderService), ɵɵinject(NbOverlayService), ɵɵinject(Injector), ɵɵinject(ComponentFactoryResolver$1));
};
_NbDialogService.ɵprov = ɵɵdefineInjectable({
  token: _NbDialogService,
  factory: _NbDialogService.ɵfac
});
var NbDialogService = _NbDialogService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDialogService, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DIALOG_CONFIG]
    }]
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbOverlayService
  }, {
    type: Injector
  }, {
    type: ComponentFactoryResolver$1
  }], null);
})();
var _NbDialogModule = class _NbDialogModule {
  static forRoot(dialogConfig = {}) {
    return {
      ngModule: _NbDialogModule,
      providers: [NbDialogService, {
        provide: NB_DIALOG_CONFIG,
        useValue: dialogConfig
      }]
    };
  }
  static forChild(dialogConfig = {}) {
    return {
      ngModule: _NbDialogModule,
      providers: [NbDialogService, {
        provide: NB_DIALOG_CONFIG,
        useValue: dialogConfig
      }]
    };
  }
};
_NbDialogModule.ɵfac = function NbDialogModule_Factory(t) {
  return new (t || _NbDialogModule)();
};
_NbDialogModule.ɵmod = ɵɵdefineNgModule({
  type: _NbDialogModule,
  declarations: [NbDialogContainerComponent],
  imports: [NbSharedModule, NbOverlayModule]
});
_NbDialogModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbOverlayModule]
});
var NbDialogModule = _NbDialogModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDialogModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule],
      declarations: [NbDialogContainerComponent]
    }]
  }], null, null);
})();
var _NbToastComponent = class _NbToastComponent {
  get success() {
    return this.toast.config.status === "success";
  }
  get info() {
    return this.toast.config.status === "info";
  }
  get warning() {
    return this.toast.config.status === "warning";
  }
  get primary() {
    return this.toast.config.status === "primary";
  }
  get danger() {
    return this.toast.config.status === "danger";
  }
  get basic() {
    return this.toast.config.status === "basic";
  }
  get control() {
    return this.toast.config.status === "control";
  }
  get destroyByClick() {
    return this.toast.config.destroyByClick;
  }
  get hasIcon() {
    const {
      icon
    } = this.toast.config;
    if (typeof icon === "string") {
      return true;
    }
    return !!(icon && icon.icon);
  }
  get customIcon() {
    return !!this.icon;
  }
  get icon() {
    return this.toast.config.icon;
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.toast.config.status)) {
      return [this.statusService.getStatusClass(this.toast.config.status)];
    }
    return [];
  }
  onClick() {
    this.toastClick.emit();
  }
  constructor(renderer, elementRef, statusService) {
    this.renderer = renderer;
    this.elementRef = elementRef;
    this.statusService = statusService;
    this.destroy = new EventEmitter();
    this.toastClick = new EventEmitter();
  }
  ngOnInit() {
    if (this.toast.config.toastClass) {
      this.renderer.addClass(this.elementRef.nativeElement, this.toast.config.toastClass);
    }
  }
  ngOnDestroy() {
    this.destroy.emit();
  }
};
_NbToastComponent.ɵfac = function NbToastComponent_Factory(t) {
  return new (t || _NbToastComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbStatusService));
};
_NbToastComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbToastComponent,
  selectors: [["nb-toast"]],
  hostVars: 22,
  hostBindings: function NbToastComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbToastComponent_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-primary", ctx.primary)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("destroy-by-click", ctx.destroyByClick)("has-icon", ctx.hasIcon)("custom-icon", ctx.customIcon);
    }
  },
  inputs: {
    toast: "toast"
  },
  outputs: {
    destroy: "destroy",
    toastClick: "toastClick"
  },
  decls: 6,
  vars: 3,
  consts: [["class", "icon-container", 4, "ngIf"], [1, "content-container"], [1, "title", "subtitle"], [1, "message"], [1, "icon-container"], [3, "config"]],
  template: function NbToastComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbToastComponent_div_0_Template, 2, 1, "div", 0);
      ɵɵelementStart(1, "div", 1)(2, "span", 2);
      ɵɵtext(3);
      ɵɵelementEnd();
      ɵɵelementStart(4, "div", 3);
      ɵɵtext(5);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.hasIcon && ctx.icon);
      ɵɵadvance(3);
      ɵɵtextInterpolate(ctx.toast.title);
      ɵɵadvance(2);
      ɵɵtextInterpolate(ctx.toast.message);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;align-items:center;width:25rem;margin:.5rem}[_nghost-%COMP%]   .title[_ngcontent-%COMP%]{margin-right:.25rem}.default[_nghost-%COMP%]   .content-container[_ngcontent-%COMP%], [_nghost-%COMP%]:not(.has-icon)   .content-container[_ngcontent-%COMP%]{display:flex;flex-direction:row}.destroy-by-click[_nghost-%COMP%]{cursor:pointer}[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]{font-size:2.5rem}[_nghost-%COMP%]   svg[_ngcontent-%COMP%]{width:2.5rem;height:2.5rem}"]
});
var NbToastComponent = _NbToastComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastComponent, [{
    type: Component,
    args: [{
      selector: "nb-toast",
      template: '<div class="icon-container" *ngIf="hasIcon && icon">\n  <nb-icon [config]="icon"></nb-icon>\n</div>\n<div class="content-container">\n  <span class="title subtitle">{{ toast.title }}</span>\n  <div class="message">{{ toast.message }}</div>\n</div>\n',
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;align-items:center;width:25rem;margin:.5rem}:host .title{margin-right:.25rem}:host.default .content-container,:host:not(.has-icon) .content-container{display:flex;flex-direction:row}:host.destroy-by-click{cursor:pointer}:host nb-icon{font-size:2.5rem}:host svg{width:2.5rem;height:2.5rem}\n"]
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: NbStatusService
  }], {
    toast: [{
      type: Input
    }],
    destroy: [{
      type: Output
    }],
    toastClick: [{
      type: Output
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    destroyByClick: [{
      type: HostBinding,
      args: ["class.destroy-by-click"]
    }],
    hasIcon: [{
      type: HostBinding,
      args: ["class.has-icon"]
    }],
    customIcon: [{
      type: HostBinding,
      args: ["class.custom-icon"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var voidState = style({
  transform: "translateX({{ direction }}110%)",
  height: 0,
  marginLeft: "0",
  marginRight: "0",
  marginTop: "0",
  marginBottom: "0"
});
var defaultOptions = {
  params: {
    direction: ""
  }
};
var _NbToastrContainerComponent = class _NbToastrContainerComponent {
  constructor(layoutDirection, positionHelper) {
    this.layoutDirection = layoutDirection;
    this.positionHelper = positionHelper;
    this.destroy$ = new Subject();
    this.content = [];
  }
  ngOnInit() {
    this.layoutDirection.onDirectionChange().pipe(takeUntil(this.destroy$)).subscribe(() => this.onDirectionChange());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  onDirectionChange() {
    const direction = this.positionHelper.isRightPosition(this.position) ? "" : "-";
    this.fadeIn = {
      value: "",
      params: {
        direction
      }
    };
  }
};
_NbToastrContainerComponent.ɵfac = function NbToastrContainerComponent_Factory(t) {
  return new (t || _NbToastrContainerComponent)(ɵɵdirectiveInject(NbLayoutDirectionService), ɵɵdirectiveInject(NbPositionHelper));
};
_NbToastrContainerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbToastrContainerComponent,
  selectors: [["nb-toastr-container"]],
  viewQuery: function NbToastrContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbToastComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toasts = _t);
    }
  },
  inputs: {
    content: "content",
    context: "context",
    position: "position"
  },
  decls: 1,
  vars: 1,
  consts: [[3, "toast", 4, "ngFor", "ngForOf"], [3, "toast"]],
  template: function NbToastrContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbToastrContainerComponent_nb_toast_0_Template, 1, 2, "nb-toast", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngForOf", ctx.content);
    }
  },
  dependencies: [NgForOf, NbToastComponent],
  encapsulation: 2,
  data: {
    animation: [trigger("fadeIn", [transition(":enter", [voidState, animate(100)], defaultOptions), transition(":leave", [animate(100, voidState)], defaultOptions)])]
  }
});
var NbToastrContainerComponent = _NbToastrContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastrContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-toastr-container",
      template: `
    <nb-toast [@fadeIn]="fadeIn" *ngFor="let toast of content" [toast]="toast"></nb-toast>`,
      animations: [trigger("fadeIn", [transition(":enter", [voidState, animate(100)], defaultOptions), transition(":leave", [animate(100, voidState)], defaultOptions)])]
    }]
  }], () => [{
    type: NbLayoutDirectionService
  }, {
    type: NbPositionHelper
  }], {
    content: [{
      type: Input
    }],
    context: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    toasts: [{
      type: ViewChildren,
      args: [NbToastComponent]
    }]
  });
})();
var NB_TOASTR_CONFIG = new InjectionToken("Default toastr options");
var NbToastrConfig = class {
  constructor(config) {
    this.position = NbGlobalLogicalPosition.TOP_END;
    this.status = "basic";
    this.duration = 3e3;
    this.destroyByClick = true;
    this.preventDuplicates = false;
    this.duplicatesBehaviour = "previous";
    this.limit = null;
    this.toastClass = "";
    this.hasIcon = true;
    this.icon = "email";
    this.icons = {
      danger: "flash-outline",
      success: "checkmark-outline",
      info: "question-mark-outline",
      warning: "alert-triangle-outline",
      primary: "email-outline",
      control: "email-outline",
      basic: "email-outline"
    };
    this.patchIcon(config);
    Object.assign(this, config);
  }
  patchIcon(config) {
    if (!("icon" in config)) {
      config.icon = {
        icon: this.icons[config.status] || this.icons.basic,
        pack: "nebular-essentials"
      };
    }
  }
};
var NbToastRef = class {
  constructor(toastContainer, toast) {
    this.toastContainer = toastContainer;
    this.toast = toast;
  }
  close() {
    this.toastContainer.destroy(this.toast);
  }
  onClose() {
    return this.toastInstance.destroy.asObservable();
  }
  onClick() {
    return this.toastInstance.toastClick.asObservable();
  }
};
var NbToastContainer = class {
  get nativeElement() {
    return this.containerRef.location.nativeElement;
  }
  constructor(position, containerRef, positionHelper) {
    this.position = position;
    this.containerRef = containerRef;
    this.positionHelper = positionHelper;
    this.toasts = [];
    this.toastDuplicateCompareFunc = (t1, t2) => {
      return t1.message === t2.message && t1.title === t2.title && t1.config.status === t2.config.status;
    };
  }
  attach(toast) {
    if (toast.config.preventDuplicates && this.isDuplicate(toast)) {
      return void 0;
    }
    this.removeToastIfLimitReached(toast);
    const toastComponent = this.attachToast(toast);
    if (toast.config.destroyByClick) {
      this.subscribeOnClick(toastComponent, toast);
    }
    if (toast.config.duration) {
      this.setDestroyTimeout(toast);
    }
    this.prevToast = toast;
    const toastRef = new NbToastRef(this, toast);
    toastRef.toastInstance = toastComponent;
    return toastRef;
  }
  destroy(toast) {
    if (this.prevToast === toast) {
      this.prevToast = null;
    }
    this.toasts = this.toasts.filter((t) => t !== toast);
    this.updateContainer();
  }
  isDuplicate(toast) {
    return toast.config.duplicatesBehaviour === "previous" ? this.isDuplicatePrevious(toast) : this.isDuplicateAmongAll(toast);
  }
  isDuplicatePrevious(toast) {
    return this.prevToast && this.toastDuplicateCompareFunc(this.prevToast, toast);
  }
  isDuplicateAmongAll(toast) {
    return this.toasts.some((t) => this.toastDuplicateCompareFunc(t, toast));
  }
  removeToastIfLimitReached(toast) {
    if (!toast.config.limit || this.toasts.length < toast.config.limit) {
      return;
    }
    if (this.positionHelper.isTopPosition(toast.config.position)) {
      this.toasts.pop();
    } else {
      this.toasts.shift();
    }
  }
  attachToast(toast) {
    if (this.positionHelper.isTopPosition(toast.config.position)) {
      return this.attachToTop(toast);
    } else {
      return this.attachToBottom(toast);
    }
  }
  attachToTop(toast) {
    this.toasts.unshift(toast);
    this.updateContainer();
    return this.containerRef.instance.toasts.first;
  }
  attachToBottom(toast) {
    this.toasts.push(toast);
    this.updateContainer();
    return this.containerRef.instance.toasts.last;
  }
  setDestroyTimeout(toast) {
    setTimeout(() => this.destroy(toast), toast.config.duration);
  }
  subscribeOnClick(toastComponent, toast) {
    toastComponent.toastClick.pipe(filter(() => toast.config.destroyByClick), takeUntil(toastComponent.destroy)).subscribe(() => this.destroy(toast));
  }
  updateContainer() {
    patch(this.containerRef, {
      content: this.toasts,
      position: this.position
    });
  }
};
var _NbToastrContainerRegistry = class _NbToastrContainerRegistry {
  constructor(overlay, positionBuilder, positionHelper, cfr, document) {
    this.overlay = overlay;
    this.positionBuilder = positionBuilder;
    this.positionHelper = positionHelper;
    this.cfr = cfr;
    this.document = document;
    this.overlays = /* @__PURE__ */ new Map();
  }
  get(position) {
    const logicalPosition = this.positionHelper.toLogicalPosition(position);
    const overlayWithContainer = this.overlays.get(logicalPosition);
    if (!overlayWithContainer || !this.existsInDom(overlayWithContainer.toastrContainer)) {
      if (overlayWithContainer) {
        overlayWithContainer.overlayRef.dispose();
      }
      this.instantiateContainer(logicalPosition);
    }
    return this.overlays.get(logicalPosition).toastrContainer;
  }
  instantiateContainer(position) {
    const toastrOverlayWithContainer = this.createContainer(position);
    this.overlays.set(position, toastrOverlayWithContainer);
  }
  createContainer(position) {
    const positionStrategy = this.positionBuilder.global().position(position);
    const ref = this.overlay.create({
      positionStrategy
    });
    this.addClassToOverlayHost(ref);
    const containerRef = ref.attach(new NbComponentPortal(NbToastrContainerComponent, null, null, this.cfr));
    return {
      overlayRef: ref,
      toastrContainer: new NbToastContainer(position, containerRef, this.positionHelper)
    };
  }
  addClassToOverlayHost(overlayRef) {
    overlayRef.hostElement.classList.add("toastr-overlay-container");
  }
  existsInDom(toastContainer) {
    return this.document.body.contains(toastContainer.nativeElement);
  }
};
_NbToastrContainerRegistry.ɵfac = function NbToastrContainerRegistry_Factory(t) {
  return new (t || _NbToastrContainerRegistry)(ɵɵinject(NbOverlayService), ɵɵinject(NbPositionBuilderService), ɵɵinject(NbPositionHelper), ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(NB_DOCUMENT));
};
_NbToastrContainerRegistry.ɵprov = ɵɵdefineInjectable({
  token: _NbToastrContainerRegistry,
  factory: _NbToastrContainerRegistry.ɵfac
});
var NbToastrContainerRegistry = _NbToastrContainerRegistry;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastrContainerRegistry, [{
    type: Injectable
  }], () => [{
    type: NbOverlayService
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbPositionHelper
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var _NbToastrService = class _NbToastrService {
  constructor(globalConfig, containerRegistry) {
    this.globalConfig = globalConfig;
    this.containerRegistry = containerRegistry;
  }
  /**
   * Shows toast with message, title and user config.
   * */
  show(message, title, userConfig) {
    const config = new NbToastrConfig(__spreadValues(__spreadValues({}, this.globalConfig), userConfig));
    const container = this.containerRegistry.get(config.position);
    const toast = {
      message,
      title,
      config
    };
    return container.attach(toast);
  }
  /**
   * Shows success toast with message, title and user config.
   * */
  success(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "success"
    }));
  }
  /**
   * Shows info toast with message, title and user config.
   * */
  info(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "info"
    }));
  }
  /**
   * Shows warning toast with message, title and user config.
   * */
  warning(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "warning"
    }));
  }
  /**
   * Shows primary toast with message, title and user config.
   * */
  primary(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "primary"
    }));
  }
  /**
   * Shows danger toast with message, title and user config.
   * */
  danger(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "danger"
    }));
  }
  /**
   * Shows default toast with message, title and user config.
   * */
  default(message, title, config) {
    return this.show(message, title, __spreadProps(__spreadValues({}, config), {
      status: "basic"
    }));
  }
  /**
   * Shows control toast with message, title and user config.
   * */
  control(message, title, config) {
    return this.default(message, title, __spreadProps(__spreadValues({}, config), {
      status: "control"
    }));
  }
};
_NbToastrService.ɵfac = function NbToastrService_Factory(t) {
  return new (t || _NbToastrService)(ɵɵinject(NB_TOASTR_CONFIG), ɵɵinject(NbToastrContainerRegistry));
};
_NbToastrService.ɵprov = ɵɵdefineInjectable({
  token: _NbToastrService,
  factory: _NbToastrService.ɵfac
});
var NbToastrService = _NbToastrService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastrService, [{
    type: Injectable
  }], () => [{
    type: NbToastrConfig,
    decorators: [{
      type: Inject,
      args: [NB_TOASTR_CONFIG]
    }]
  }, {
    type: NbToastrContainerRegistry
  }], null);
})();
var _NbToastrModule = class _NbToastrModule {
  static forRoot(toastrConfig = {}) {
    return {
      ngModule: _NbToastrModule,
      providers: [NbToastrService, NbToastrContainerRegistry, {
        provide: NB_TOASTR_CONFIG,
        useValue: toastrConfig
      }]
    };
  }
};
_NbToastrModule.ɵfac = function NbToastrModule_Factory(t) {
  return new (t || _NbToastrModule)();
};
_NbToastrModule.ɵmod = ɵɵdefineNgModule({
  type: _NbToastrModule,
  declarations: [NbToastrContainerComponent, NbToastComponent],
  imports: [NbSharedModule, NbOverlayModule, NbIconModule]
});
_NbToastrModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbOverlayModule, NbIconModule]
});
var NbToastrModule = _NbToastrModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToastrModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbIconModule],
      declarations: [NbToastrContainerComponent, NbToastComponent]
    }]
  }], null, null);
})();
var NbToast = class {
};
var _NbTooltipComponent = class _NbTooltipComponent {
  get binding() {
    return `${this.position} ${this.statusClass}`;
  }
  get show() {
    return true;
  }
  get statusClass() {
    if (this.context.status) {
      return this.statusService.getStatusClass(this.context.status);
    }
    return "";
  }
  constructor(statusService) {
    this.statusService = statusService;
    this.position = NbPosition.TOP;
    this.context = {};
  }
  /**
   * The method is empty since we don't need to do anything additionally
   * render is handled by change detection
   */
  renderContent() {
  }
};
_NbTooltipComponent.ɵfac = function NbTooltipComponent_Factory(t) {
  return new (t || _NbTooltipComponent)(ɵɵdirectiveInject(NbStatusService));
};
_NbTooltipComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTooltipComponent,
  selectors: [["nb-tooltip"]],
  hostVars: 3,
  hostBindings: function NbTooltipComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵsyntheticHostProperty("@showTooltip", ctx.show);
      ɵɵclassMap(ctx.binding);
    }
  },
  inputs: {
    content: "content",
    position: "position",
    context: "context"
  },
  decls: 4,
  vars: 2,
  consts: [[1, "arrow"], [1, "content"], [3, "config", 4, "ngIf"], [4, "ngIf"], [3, "config"]],
  template: function NbTooltipComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "span", 0);
      ɵɵelementStart(1, "div", 1);
      ɵɵtemplate(2, NbTooltipComponent_nb_icon_2_Template, 1, 1, "nb-icon", 2)(3, NbTooltipComponent_span_3_Template, 2, 1, "span", 3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.context == null ? null : ctx.context.icon);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.content);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{z-index:10000}[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{display:flex;align-items:center}.right[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{flex-direction:row-reverse}[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{position:absolute;width:0;height:0}[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-left:.5rem}.right[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-right:.5rem}[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{border-left:6px solid transparent;border-right:6px solid transparent}.bottom[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-6px;left:calc(50% - 6px)}.bottom-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-6px}[dir=ltr]   .bottom-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}[dir=rtl]   .bottom-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}.bottom-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-6px}[dir=ltr]   .bottom-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}[dir=rtl]   .bottom-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}.left[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], .start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:calc(50% - 2.4px)}[dir=ltr]   .left[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=ltr]   .start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;transform:rotate(90deg)}[dir=rtl]   .left[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=rtl]   .start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8px;transform:rotate(270deg)}.start-top[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;bottom:6px;transform:rotate(90deg)}.start-bottom[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;top:6px;transform:rotate(90deg)}.top[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:-6px;left:calc(50% - 6px);transform:rotate(180deg)}.top-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:-5px;transform:rotate(180deg)}[dir=ltr]   .top-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}[dir=rtl]   .top-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}.top-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:-5px;transform:rotate(180deg)}[dir=ltr]   .top-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}[dir=rtl]   .top-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}.right[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], .end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:calc(50% - 2.4px)}[dir=ltr]   .right[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=ltr]   .end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8px;transform:rotate(270deg)}[dir=rtl]   .right[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=rtl]   .end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;transform:rotate(90deg)}.end-top[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8.4px;bottom:6px;transform:rotate(270deg)}.end-bottom[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8.4px;top:6px;transform:rotate(270deg)}"],
  data: {
    animation: [trigger("showTooltip", [state("in", style({
      opacity: 1
    })), transition("void => *", [style({
      opacity: 0
    }), animate(100)]), transition("* => void", [animate(100, style({
      opacity: 0
    }))])])]
  }
});
var NbTooltipComponent = _NbTooltipComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTooltipComponent, [{
    type: Component,
    args: [{
      selector: "nb-tooltip",
      template: `
    <span class="arrow"></span>
    <div class="content">
      <nb-icon *ngIf="context?.icon" [config]="context.icon"></nb-icon>
      <span *ngIf="content">{{ content }}</span>
    </div>
  `,
      animations: [trigger("showTooltip", [state("in", style({
        opacity: 1
      })), transition("void => *", [style({
        opacity: 0
      }), animate(100)]), transition("* => void", [animate(100, style({
        opacity: 0
      }))])])],
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{z-index:10000}:host .content{display:flex;align-items:center}:host.right .content{flex-direction:row-reverse}:host .arrow{position:absolute;width:0;height:0}:host nb-icon+span{margin-left:.5rem}:host.right nb-icon+span{margin-right:.5rem}:host .arrow{border-left:6px solid transparent;border-right:6px solid transparent}:host(.bottom) .arrow{top:-6px;left:calc(50% - 6px)}:host(.bottom-start) .arrow{top:-6px}[dir=ltr] :host(.bottom-start) .arrow{right:6px}[dir=rtl] :host(.bottom-start) .arrow{left:6px}:host(.bottom-end) .arrow{top:-6px}[dir=ltr] :host(.bottom-end) .arrow{left:6px}[dir=rtl] :host(.bottom-end) .arrow{right:6px}:host(.left) .arrow,:host(.start) .arrow{top:calc(50% - 2.4px)}[dir=ltr] :host(.left) .arrow,[dir=ltr] :host(.start) .arrow{right:-8px;transform:rotate(90deg)}[dir=rtl] :host(.left) .arrow,[dir=rtl] :host(.start) .arrow{left:-8px;transform:rotate(270deg)}:host(.start-top) .arrow{right:-8px;bottom:6px;transform:rotate(90deg)}:host(.start-bottom) .arrow{right:-8px;top:6px;transform:rotate(90deg)}:host(.top) .arrow{bottom:-6px;left:calc(50% - 6px);transform:rotate(180deg)}:host(.top-start) .arrow{bottom:-5px;transform:rotate(180deg)}[dir=ltr] :host(.top-start) .arrow{right:6px}[dir=rtl] :host(.top-start) .arrow{left:6px}:host(.top-end) .arrow{bottom:-5px;transform:rotate(180deg)}[dir=ltr] :host(.top-end) .arrow{left:6px}[dir=rtl] :host(.top-end) .arrow{right:6px}:host(.right) .arrow,:host(.end) .arrow{top:calc(50% - 2.4px)}[dir=ltr] :host(.right) .arrow,[dir=ltr] :host(.end) .arrow{left:-8px;transform:rotate(270deg)}[dir=rtl] :host(.right) .arrow,[dir=rtl] :host(.end) .arrow{right:-8px;transform:rotate(90deg)}:host(.end-top) .arrow{left:-8.4px;bottom:6px;transform:rotate(270deg)}:host(.end-bottom) .arrow{left:-8.4px;top:6px;transform:rotate(270deg)}\n"]
    }]
  }], () => [{
    type: NbStatusService
  }], {
    content: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    binding: [{
      type: HostBinding,
      args: ["class"]
    }],
    show: [{
      type: HostBinding,
      args: ["@showTooltip"]
    }],
    context: [{
      type: Input
    }]
  });
})();
var _NbTooltipDirective = class _NbTooltipDirective {
  /**
   * Container position will change automatically based on this strategy if container can't fit view port.
   * Set this property to `noop` value if you want to disable automatic adjustment.
   * Available values: `clockwise` (default), `counterclockwise`, `vertical`, `horizontal`, `noop`.
   */
  get adjustment() {
    return this._adjustment;
  }
  set adjustment(value) {
    this._adjustment = value;
  }
  get tooltipClass() {
    return this._tooltipClass;
  }
  set tooltipClass(value) {
    if (value !== this.tooltipClass) {
      this._tooltipClass = value;
      this.overlayConfig = {
        panelClass: this.tooltipClass
      };
    }
  }
  /**
   * Accepts icon name or icon config object
   * @param {string | NbIconConfig} icon name or config object
   */
  set icon(icon) {
    this.context = Object.assign(this.context, {
      icon
    });
  }
  /**
   *
   * @param {string} status
   */
  set status(status) {
    this.context = Object.assign(this.context, {
      status
    });
  }
  get isShown() {
    return !!(this.dynamicOverlay && this.dynamicOverlay.isAttached);
  }
  constructor(hostRef, dynamicOverlayHandler) {
    this.hostRef = hostRef;
    this.dynamicOverlayHandler = dynamicOverlayHandler;
    this.destroy$ = new Subject();
    this.tooltipComponent = NbTooltipComponent;
    this.context = {};
    this.position = NbPosition.TOP;
    this._adjustment = NbAdjustment.CLOCKWISE;
    this._tooltipClass = "";
    this.trigger = NbTrigger.HINT;
    this.offset = 8;
    this.disabled = false;
    this.nbTooltipShowStateChange = new EventEmitter();
    this.overlayConfig = {
      panelClass: this.tooltipClass
    };
  }
  ngOnInit() {
    this.dynamicOverlayHandler.host(this.hostRef).componentType(this.tooltipComponent).offset(this.offset);
  }
  ngOnChanges() {
    this.rebuild();
  }
  ngAfterViewInit() {
    this.dynamicOverlay = this.configureDynamicOverlay().build();
    this.dynamicOverlay.isShown.pipe(skip(1), takeUntil(this.destroy$)).subscribe((isShown) => this.nbTooltipShowStateChange.emit({
      isShown
    }));
  }
  rebuild() {
    this.dynamicOverlay = this.configureDynamicOverlay().rebuild();
  }
  show() {
    this.dynamicOverlay.show();
  }
  hide() {
    this.dynamicOverlay.hide();
  }
  toggle() {
    this.dynamicOverlay.toggle();
  }
  ngOnDestroy() {
    this.dynamicOverlayHandler.destroy();
    this.destroy$.next();
    this.destroy$.complete();
  }
  configureDynamicOverlay() {
    return this.dynamicOverlayHandler.position(this.position).trigger(this.trigger).disabled(this.disabled).adjustment(this.adjustment).content(this.content).context(this.context).overlayConfig(this.overlayConfig);
  }
};
_NbTooltipDirective.ɵfac = function NbTooltipDirective_Factory(t) {
  return new (t || _NbTooltipDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbDynamicOverlayHandler));
};
_NbTooltipDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTooltipDirective,
  selectors: [["", "nbTooltip", ""]],
  inputs: {
    content: [InputFlags.None, "nbTooltip", "content"],
    position: [InputFlags.None, "nbTooltipPlacement", "position"],
    adjustment: [InputFlags.None, "nbTooltipAdjustment", "adjustment"],
    tooltipClass: [InputFlags.None, "nbTooltipClass", "tooltipClass"],
    icon: [InputFlags.None, "nbTooltipIcon", "icon"],
    status: [InputFlags.None, "nbTooltipStatus", "status"],
    trigger: [InputFlags.None, "nbTooltipTrigger", "trigger"],
    offset: [InputFlags.None, "nbTooltipOffset", "offset"],
    disabled: [InputFlags.None, "nbTooltipDisabled", "disabled"]
  },
  outputs: {
    nbTooltipShowStateChange: "nbTooltipShowStateChange"
  },
  exportAs: ["nbTooltip"],
  features: [ɵɵProvidersFeature([NbDynamicOverlayHandler, NbDynamicOverlay]), ɵɵNgOnChangesFeature]
});
var NbTooltipDirective = _NbTooltipDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTooltipDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTooltip]",
      exportAs: "nbTooltip",
      providers: [NbDynamicOverlayHandler, NbDynamicOverlay]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbDynamicOverlayHandler
  }], {
    content: [{
      type: Input,
      args: ["nbTooltip"]
    }],
    position: [{
      type: Input,
      args: ["nbTooltipPlacement"]
    }],
    adjustment: [{
      type: Input,
      args: ["nbTooltipAdjustment"]
    }],
    tooltipClass: [{
      type: Input,
      args: ["nbTooltipClass"]
    }],
    icon: [{
      type: Input,
      args: ["nbTooltipIcon"]
    }],
    status: [{
      type: Input,
      args: ["nbTooltipStatus"]
    }],
    trigger: [{
      type: Input,
      args: ["nbTooltipTrigger"]
    }],
    offset: [{
      type: Input,
      args: ["nbTooltipOffset"]
    }],
    disabled: [{
      type: Input,
      args: ["nbTooltipDisabled"]
    }],
    nbTooltipShowStateChange: [{
      type: Output
    }]
  });
})();
var _NbTooltipModule = class _NbTooltipModule {
};
_NbTooltipModule.ɵfac = function NbTooltipModule_Factory(t) {
  return new (t || _NbTooltipModule)();
};
_NbTooltipModule.ɵmod = ɵɵdefineNgModule({
  type: _NbTooltipModule,
  declarations: [NbTooltipComponent, NbTooltipDirective],
  imports: [NbSharedModule, NbOverlayModule, NbIconModule],
  exports: [NbTooltipDirective]
});
_NbTooltipModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbOverlayModule, NbIconModule]
});
var NbTooltipModule = _NbTooltipModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTooltipModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbIconModule],
      declarations: [NbTooltipComponent, NbTooltipDirective],
      exports: [NbTooltipDirective]
    }]
  }], null, null);
})();
var NB_SELECT_INJECTION_TOKEN = new InjectionToken("NB_SELECT_INJECTION_TOKEN");
var lastOptionId = 0;
var _NbOptionComponent = class _NbOptionComponent {
  get disabled() {
    return this._disabled || this.disabledByGroup;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  get click() {
    return this.click$.asObservable();
  }
  constructor(parent, elementRef, cd, zone, renderer) {
    this.elementRef = elementRef;
    this.cd = cd;
    this.zone = zone;
    this.renderer = renderer;
    this.disabledByGroup = false;
    this._disabled = false;
    this.selectionChange = new EventEmitter();
    this.click$ = new Subject();
    this.selected = false;
    this.alive = true;
    this.id = `nb-option-${lastOptionId++}`;
    this._active = false;
    this.parent = parent;
  }
  ngOnDestroy() {
    this.alive = false;
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.elementRef.nativeElement, "nb-transition");
    }));
  }
  /**
   * Determines should we render checkbox.
   * */
  get withCheckbox() {
    return this.multiple && this.value != null;
  }
  get content() {
    return this.elementRef.nativeElement.textContent;
  }
  get hidden() {
    return this.elementRef.nativeElement.hidden;
  }
  // TODO: replace with isShowCheckbox property to control this behaviour outside, issues/1965
  get multiple() {
    return this.parent ? this.parent.multiple : false;
  }
  get selectedClass() {
    return this.selected;
  }
  get disabledAttribute() {
    return this.disabled ? "" : null;
  }
  get tabindex() {
    return "-1";
  }
  get activeClass() {
    return this._active;
  }
  onClick(event) {
    this.click$.next(this);
    event.preventDefault();
  }
  select() {
    this.setSelection(true);
  }
  deselect() {
    this.setSelection(false);
  }
  /**
   * Sets disabled by group state and marks component for check.
   */
  setDisabledByGroupState(disabled) {
    if (this.disabledByGroup !== disabled && this.alive) {
      this.disabledByGroup = disabled;
      this.cd.markForCheck();
    }
  }
  setSelection(selected) {
    if (this.alive && this.selected !== selected) {
      this.selected = selected;
      this.selectionChange.emit(this);
      this.cd.markForCheck();
    }
  }
  focus() {
    this.elementRef.nativeElement.focus();
  }
  getLabel() {
    return this.content;
  }
  setActiveStyles() {
    this._active = true;
    this.cd.markForCheck();
  }
  setInactiveStyles() {
    this._active = false;
    this.cd.markForCheck();
  }
};
_NbOptionComponent.ɵfac = function NbOptionComponent_Factory(t) {
  return new (t || _NbOptionComponent)(ɵɵdirectiveInject(NB_SELECT_INJECTION_TOKEN, 8), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2));
};
_NbOptionComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbOptionComponent,
  selectors: [["nb-option"]],
  hostVars: 9,
  hostBindings: function NbOptionComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbOptionComponent_click_HostBindingHandler($event) {
        return ctx.onClick($event);
      })("keydown.space", function NbOptionComponent_keydown_space_HostBindingHandler($event) {
        return ctx.onClick($event);
      })("keydown.enter", function NbOptionComponent_keydown_enter_HostBindingHandler($event) {
        return ctx.onClick($event);
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("tabIndex", ctx.tabindex);
      ɵɵattribute("id", ctx.id)("disabled", ctx.disabledAttribute);
      ɵɵclassProp("multiple", ctx.multiple)("selected", ctx.selectedClass)("active", ctx.activeClass);
    }
  },
  inputs: {
    value: "value",
    disabled: "disabled"
  },
  outputs: {
    selectionChange: "selectionChange"
  },
  ngContentSelectors: _c02,
  decls: 2,
  vars: 1,
  consts: [["aria-hidden", "true", 3, "checked", "disabled", 4, "ngIf"], ["aria-hidden", "true", 3, "checked", "disabled"]],
  template: function NbOptionComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, NbOptionComponent_nb_checkbox_0_Template, 1, 2, "nb-checkbox", 0);
      ɵɵprojection(1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.withCheckbox);
    }
  },
  dependencies: [NgIf, NbCheckboxComponent],
  styles: ["\n\n\n\n\n\n\n\n\n\n[_nghost-%COMP%]{display:flex}[hidden][_nghost-%COMP%]{display:none}[_nghost-%COMP%]:hover{cursor:pointer}[_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]{display:flex;pointer-events:none}[dir=ltr]   [_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]{margin-right:.5rem}[dir=rtl]   [_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]{margin-left:.5rem}[_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]     .label{padding:0}[disabled][_nghost-%COMP%]{pointer-events:none}.nb-transition[_nghost-%COMP%]{transition-duration:.15s;transition-property:background-color,color;transition-timing-function:ease-in}"],
  changeDetection: 0
});
var NbOptionComponent = _NbOptionComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOptionComponent, [{
    type: Component,
    args: [{
      selector: "nb-option",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <nb-checkbox *ngIf="withCheckbox" [checked]="selected" [disabled]="disabled" aria-hidden="true"> </nb-checkbox>
    <ng-content></ng-content>
  `,
      styles: ["/*!\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n *//**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex}:host[hidden]{display:none}:host:hover{cursor:pointer}:host nb-checkbox{display:flex;pointer-events:none}[dir=ltr] :host nb-checkbox{margin-right:.5rem}[dir=rtl] :host nb-checkbox{margin-left:.5rem}:host nb-checkbox ::ng-deep .label{padding:0}:host([disabled]){pointer-events:none}:host(.nb-transition){transition-duration:.15s;transition-property:background-color,color;transition-timing-function:ease-in}\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NB_SELECT_INJECTION_TOKEN]
    }]
  }, {
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: Renderer2
  }], {
    value: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    selectionChange: [{
      type: Output
    }],
    id: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    multiple: [{
      type: HostBinding,
      args: ["class.multiple"]
    }],
    selectedClass: [{
      type: HostBinding,
      args: ["class.selected"]
    }],
    disabledAttribute: [{
      type: HostBinding,
      args: ["attr.disabled"]
    }],
    tabindex: [{
      type: HostBinding,
      args: ["tabIndex"]
    }],
    activeClass: [{
      type: HostBinding,
      args: ["class.active"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }, {
      type: HostListener,
      args: ["keydown.space", ["$event"]]
    }, {
      type: HostListener,
      args: ["keydown.enter", ["$event"]]
    }]
  });
})();
var _NbOptionListComponent = class _NbOptionListComponent {
  constructor() {
    this.size = "medium";
  }
  get positionTop() {
    return this.position === NbPosition.TOP;
  }
  get positionBottom() {
    return this.position === NbPosition.BOTTOM;
  }
  get sizeTiny() {
    return this.size === "tiny";
  }
  get sizeSmall() {
    return this.size === "small";
  }
  get sizeMedium() {
    return this.size === "medium";
  }
  get sizeLarge() {
    return this.size === "large";
  }
  get sizeGiant() {
    return this.size === "giant";
  }
};
_NbOptionListComponent.ɵfac = function NbOptionListComponent_Factory(t) {
  return new (t || _NbOptionListComponent)();
};
_NbOptionListComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbOptionListComponent,
  selectors: [["nb-option-list"]],
  hostVars: 14,
  hostBindings: function NbOptionListComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("position-top", ctx.positionTop)("position-bottom", ctx.positionBottom)("size-tiny", ctx.sizeTiny)("size-small", ctx.sizeSmall)("size-medium", ctx.sizeMedium)("size-large", ctx.sizeLarge)("size-giant", ctx.sizeGiant);
    }
  },
  inputs: {
    size: "size",
    position: "position"
  },
  ngContentSelectors: _c02,
  decls: 2,
  vars: 0,
  consts: [[1, "option-list"]],
  template: function NbOptionListComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "ul", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbOptionListComponent = _NbOptionListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOptionListComponent, [{
    type: Component,
    args: [{
      selector: "nb-option-list",
      template: `
    <ul class="option-list">
      <ng-content></ng-content>
    </ul>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    size: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    positionTop: [{
      type: HostBinding,
      args: ["class.position-top"]
    }],
    positionBottom: [{
      type: HostBinding,
      args: ["class.position-bottom"]
    }],
    sizeTiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    sizeSmall: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    sizeMedium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    sizeLarge: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    sizeGiant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }]
  });
})();
var _NbSelectLabelComponent = class _NbSelectLabelComponent {
};
_NbSelectLabelComponent.ɵfac = function NbSelectLabelComponent_Factory(t) {
  return new (t || _NbSelectLabelComponent)();
};
_NbSelectLabelComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSelectLabelComponent,
  selectors: [["nb-select-label"]],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function NbSelectLabelComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
var NbSelectLabelComponent = _NbSelectLabelComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectLabelComponent, [{
    type: Component,
    args: [{
      selector: "nb-select-label",
      template: "<ng-content></ng-content>"
    }]
  }], null, null);
})();
function nbSelectFormFieldControlConfigFactory() {
  const config = new NbFormFieldControlConfig();
  config.supportsSuffix = false;
  return config;
}
var _NbSelectComponent = class _NbSelectComponent {
  /**
   * Specifies width (in pixels) to be set on `nb-option`s container (`nb-option-list`)
   * */
  get optionsWidth() {
    return this._optionsWidth ?? this.hostWidth;
  }
  set optionsWidth(value) {
    this._optionsWidth = value;
  }
  /**
   * Adds `outline` styles
   */
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  /**
   * Adds `filled` styles
   */
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  /**
   * Adds `hero` styles
   */
  get hero() {
    return this.appearance === "hero";
  }
  set hero(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "hero";
    }
  }
  /**
   * Disables the select
   */
  get disabled() {
    return !!this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  /**
   * If set element will fill its container
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  /**
   * A function to compare option value with selected value.
   * By default, values are compared with strict equality (`===`).
   */
  get compareWith() {
    return this._compareWith;
  }
  set compareWith(fn) {
    if (typeof fn !== "function") {
      return;
    }
    this._compareWith = fn;
    if (this.selectionModel.length && this.canSelectValue()) {
      this.setSelection(this.selected);
    }
  }
  /**
   * Accepts selected item or array of selected items.
   * */
  set selected(value) {
    this.writeValue(value);
  }
  get selected() {
    return this.multiple ? this.selectionModel.map((o) => o.value) : this.selectionModel[0].value;
  }
  /**
   * Gives capability just write `multiple` over the element.
   * */
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = convertToBoolProperty(value);
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  /**
   * Determines is select opened.
   * */
  get isOpen() {
    return this.ref && this.ref.hasAttached();
  }
  constructor(document, overlay, hostRef, positionBuilder, triggerStrategyBuilder, cd, focusKeyManagerFactoryService, focusMonitor, renderer, zone, statusService) {
    this.document = document;
    this.overlay = overlay;
    this.hostRef = hostRef;
    this.positionBuilder = positionBuilder;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.cd = cd;
    this.focusKeyManagerFactoryService = focusKeyManagerFactoryService;
    this.focusMonitor = focusMonitor;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this.size = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this.appearance = "outline";
    this._fullWidth = false;
    this.placeholder = "";
    this._compareWith = (v1, v2) => v1 === v2;
    this._multiple = false;
    this.optionsOverlayOffset = 8;
    this.scrollStrategy = "block";
    this.selectedChange = new EventEmitter();
    this.selectionModel = [];
    this.overlayPosition = "";
    this.alive = true;
    this.destroy$ = new Subject();
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.status$ = new BehaviorSubject(this.status);
    this.size$ = new BehaviorSubject(this.size);
    this.focused$ = new BehaviorSubject(false);
    this.disabled$ = new BehaviorSubject(this.disabled);
    this.fullWidth$ = new BehaviorSubject(this.fullWidth);
  }
  /**
   * Determines is select hidden.
   * */
  get isHidden() {
    return !this.isOpen;
  }
  /**
   * Returns width of the select button.
   * */
  get hostWidth() {
    return this.button.nativeElement.getBoundingClientRect().width;
  }
  get selectButtonClasses() {
    const classes = [];
    if (!this.selectionModel.length) {
      classes.push("placeholder");
    }
    if (!this.selectionModel.length && !this.placeholder) {
      classes.push("empty");
    }
    if (this.isOpen) {
      classes.push(this.overlayPosition);
    }
    return classes;
  }
  /**
   * Content rendered in the label.
   * */
  get selectionView() {
    if (this.selectionModel.length > 1) {
      return this.selectionModel.map((option) => option.content).join(", ");
    }
    return this.selectionModel[0].content;
  }
  ngOnChanges({
    disabled,
    status,
    size,
    fullWidth
  }) {
    if (disabled) {
      this.disabled$.next(disabled.currentValue);
    }
    if (status) {
      this.status$.next(status.currentValue);
    }
    if (size) {
      this.size$.next(size.currentValue);
    }
    if (fullWidth) {
      this.fullWidth$.next(this.fullWidth);
    }
  }
  ngAfterContentInit() {
    this.options.changes.pipe(
      startWith(this.options),
      filter(() => this.queue != null && this.canSelectValue()),
      // Call 'writeValue' when current change detection run is finished.
      // When writing is finished, change detection starts again, since
      // microtasks queue is empty.
      // Prevents ExpressionChangedAfterItHasBeenCheckedError.
      switchMap((options) => from(Promise.resolve(options))),
      takeUntil(this.destroy$)
    ).subscribe(() => this.writeValue(this.queue));
  }
  ngAfterViewInit() {
    this.triggerStrategy = this.createTriggerStrategy();
    this.subscribeOnButtonFocus();
    this.subscribeOnTriggers();
    this.subscribeOnOptionClick();
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostRef.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.alive = false;
    this.destroy$.next();
    this.destroy$.complete();
    if (this.ref) {
      this.ref.dispose();
    }
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
  }
  show() {
    if (this.shouldShow()) {
      this.attachToOverlay();
      this.positionStrategy.positionChange.pipe(take(1), takeUntil(this.destroy$)).subscribe(() => {
        this.setActiveOption();
      });
      this.cd.markForCheck();
    }
  }
  hide() {
    if (this.isOpen) {
      this.ref.detach();
      this.cd.markForCheck();
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cd.markForCheck();
  }
  writeValue(value) {
    if (!this.alive) {
      return;
    }
    if (this.canSelectValue()) {
      this.setSelection(value);
      if (this.selectionModel.length) {
        this.queue = null;
      }
    } else {
      this.queue = value;
    }
  }
  /**
   * Selects option or clear all selected options if value is null.
   * */
  handleOptionClick(option) {
    this.queue = null;
    if (option.value == null) {
      this.reset();
    } else {
      this.selectOption(option);
    }
    this.cd.markForCheck();
  }
  /**
   * Deselect all selected options.
   * */
  reset() {
    this.selectionModel.forEach((option) => option.deselect());
    this.selectionModel = [];
    this.hide();
    this.button.nativeElement.focus();
    this.emitSelected(this.multiple ? [] : null);
  }
  /**
   * Determines how to select option as multiple or single.
   * */
  selectOption(option) {
    if (this.multiple) {
      this.handleMultipleSelect(option);
    } else {
      this.handleSingleSelect(option);
    }
  }
  /**
   * Select single option.
   * */
  handleSingleSelect(option) {
    const selected = this.selectionModel.pop();
    if (selected && !this._compareWith(selected.value, option.value)) {
      selected.deselect();
    }
    this.selectionModel = [option];
    option.select();
    this.hide();
    this.button.nativeElement.focus();
    this.emitSelected(option.value);
  }
  /**
   * Select for multiple options.
   * */
  handleMultipleSelect(option) {
    if (option.selected) {
      this.selectionModel = this.selectionModel.filter((s) => !this._compareWith(s.value, option.value));
      option.deselect();
    } else {
      this.selectionModel.push(option);
      option.select();
    }
    this.emitSelected(this.selectionModel.map((opt) => opt.value));
  }
  attachToOverlay() {
    if (!this.ref) {
      this.createOverlay();
      this.subscribeOnPositionChange();
      this.createKeyManager();
      this.subscribeOnOverlayKeys();
    }
    this.ref.attach(this.portal);
  }
  setActiveOption() {
    if (this.selectionModel.length) {
      this.keyManager.setActiveItem(this.selectionModel[0]);
    } else {
      this.keyManager.setFirstItemActive();
    }
  }
  createOverlay() {
    const scrollStrategy = this.createScrollStrategy();
    this.positionStrategy = this.createPositionStrategy();
    this.ref = this.overlay.create({
      positionStrategy: this.positionStrategy,
      scrollStrategy,
      panelClass: this.optionsPanelClass
    });
  }
  createKeyManager() {
    this.keyManager = this.focusKeyManagerFactoryService.create(this.options).withTypeAhead(200);
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this.button).position(NbPosition.BOTTOM).offset(this.optionsOverlayOffset).adjustment(NbAdjustment.VERTICAL);
  }
  createScrollStrategy() {
    return this.overlay.scrollStrategies[this.scrollStrategy]();
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.CLICK).host(this.hostRef.nativeElement).container(() => this.getContainer()).build();
  }
  subscribeOnTriggers() {
    this.triggerStrategy.show$.subscribe(() => this.show());
    this.triggerStrategy.hide$.pipe(filter(() => this.isOpen)).subscribe(($event) => {
      this.hide();
      if (!this.isClickedWithinComponent($event)) {
        this.onTouched();
      }
    });
  }
  subscribeOnPositionChange() {
    this.positionStrategy.positionChange.pipe(takeUntil(this.destroy$)).subscribe((position) => {
      this.overlayPosition = position;
      this.cd.detectChanges();
    });
  }
  subscribeOnOptionClick() {
    this.options.changes.pipe(startWith(this.options), switchMap((options) => {
      return merge(...options.map((option) => option.click));
    }), takeUntil(this.destroy$)).subscribe((clickedOption) => this.handleOptionClick(clickedOption));
  }
  subscribeOnOverlayKeys() {
    this.ref.keydownEvents().pipe(filter(() => this.isOpen), takeUntil(this.destroy$)).subscribe((event) => {
      if (event.keyCode === ESCAPE) {
        this.button.nativeElement.focus();
        this.hide();
      } else {
        this.keyManager.onKeydown(event);
      }
    });
    this.keyManager.tabOut.pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.hide();
      this.onTouched();
    });
  }
  subscribeOnButtonFocus() {
    this.focusMonitor.monitor(this.button).pipe(map((origin) => !!origin), finalize(() => this.focusMonitor.stopMonitoring(this.button)), takeUntil(this.destroy$)).subscribe(this.focused$);
  }
  getContainer() {
    return this.ref && this.ref.hasAttached() && {
      location: {
        nativeElement: this.ref.overlayElement
      }
    };
  }
  /**
   * Propagate selected value.
   * */
  emitSelected(selected) {
    this.onChange(selected);
    this.selectedChange.emit(selected);
  }
  /**
   * Set selected value in model.
   * */
  setSelection(value) {
    const isResetValue = value == null;
    let safeValue = value;
    if (this.multiple) {
      safeValue = value ?? [];
    }
    const isArray = Array.isArray(safeValue);
    if (this.multiple && !isArray && !isResetValue) {
      throw new Error("Can't assign single value if select is marked as multiple");
    }
    if (!this.multiple && isArray) {
      throw new Error("Can't assign array if select is not marked as multiple");
    }
    const previouslySelectedOptions = this.selectionModel;
    this.selectionModel = [];
    if (this.multiple) {
      safeValue.forEach((option) => this.selectValue(option));
    } else {
      this.selectValue(safeValue);
    }
    previouslySelectedOptions.filter((option) => !this.selectionModel.includes(option)).forEach((option) => option.deselect());
    this.cd.markForCheck();
  }
  /**
   * Selects value.
   * */
  selectValue(value) {
    if (value == null) {
      return;
    }
    const corresponding = this.options.find((option) => this._compareWith(option.value, value));
    if (corresponding) {
      corresponding.select();
      this.selectionModel.push(corresponding);
    }
  }
  shouldShow() {
    return this.isHidden && this.options?.length > 0;
  }
  /**
   * Sets touched if focus moved outside of button and overlay,
   * ignoring the case when focus moved to options overlay.
   */
  trySetTouched() {
    if (this.isHidden) {
      this.onTouched();
    }
  }
  isClickedWithinComponent($event) {
    return this.hostRef.nativeElement === $event.target || this.hostRef.nativeElement.contains($event.target);
  }
  canSelectValue() {
    return !!(this.options && this.options.length);
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get round() {
    return this.shape === "round";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
};
_NbSelectComponent.ɵfac = function NbSelectComponent_Factory(t) {
  return new (t || _NbSelectComponent)(ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbPositionBuilderService), ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbFocusKeyManagerFactoryService), ɵɵdirectiveInject(NbFocusMonitor), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
};
_NbSelectComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSelectComponent,
  selectors: [["nb-select"]],
  contentQueries: function NbSelectComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbSelectLabelComponent, 5);
      ɵɵcontentQuery(dirIndex, NbOptionComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.customLabel = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t);
    }
  },
  viewQuery: function NbSelectComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbPortalDirective, 5);
      ɵɵviewQuery(_c40, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portal = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.button = _t.first);
    }
  },
  hostVars: 42,
  hostBindings: function NbSelectComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("appearance-outline", ctx.outline)("appearance-filled", ctx.filled)("appearance-hero", ctx.hero)("full-width", ctx.fullWidth)("open", ctx.isOpen)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("shape-rectangle", ctx.rectangle)("shape-round", ctx.round)("shape-semi-round", ctx.semiRound);
    }
  },
  inputs: {
    size: "size",
    status: "status",
    shape: "shape",
    appearance: "appearance",
    optionsListClass: "optionsListClass",
    optionsPanelClass: "optionsPanelClass",
    optionsWidth: "optionsWidth",
    outline: "outline",
    filled: "filled",
    hero: "hero",
    disabled: "disabled",
    fullWidth: "fullWidth",
    placeholder: "placeholder",
    compareWith: "compareWith",
    selected: "selected",
    multiple: "multiple",
    optionsOverlayOffset: "optionsOverlayOffset",
    scrollStrategy: "scrollStrategy"
  },
  outputs: {
    selectedChange: "selectedChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbSelectComponent),
    multi: true
  }, {
    provide: NB_SELECT_INJECTION_TOKEN,
    useExisting: _NbSelectComponent
  }, {
    provide: NbFormFieldControl,
    useExisting: _NbSelectComponent
  }, {
    provide: NbFormFieldControlConfig,
    useFactory: nbSelectFormFieldControlConfigFactory
  }]), ɵɵNgOnChangesFeature],
  ngContentSelectors: _c42,
  decls: 8,
  vars: 4,
  consts: [["type", "button", 1, "select-button", 3, "disabled", "ngClass", "blur", "keydown.arrowDown", "keydown.arrowUp"], ["selectButton", ""], [3, "click"], [4, "ngIf", "ngIfElse"], ["placeholderTemplate", ""], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "click"], [3, "size", "position", "width", "ngClass", 4, "nbPortal"], ["defaultSelectionTemplate", ""], [3, "size", "position", "ngClass"]],
  template: function NbSelectComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c41);
      ɵɵelementStart(0, "button", 0, 1);
      ɵɵlistener("blur", function NbSelectComponent_Template_button_blur_0_listener() {
        return ctx.trySetTouched();
      })("keydown.arrowDown", function NbSelectComponent_Template_button_keydown_arrowDown_0_listener() {
        return ctx.show();
      })("keydown.arrowUp", function NbSelectComponent_Template_button_keydown_arrowUp_0_listener() {
        return ctx.show();
      });
      ɵɵelementStart(2, "span", 2);
      ɵɵlistener("click", function NbSelectComponent_Template_span_click_2_listener($event) {
        return ctx.disabled && $event.stopPropagation();
      });
      ɵɵtemplate(3, NbSelectComponent_ng_container_3_Template, 4, 2, "ng-container", 3)(4, NbSelectComponent_ng_template_4_Template, 1, 1, "ng-template", null, 4, ɵɵtemplateRefExtractor);
      ɵɵelementEnd();
      ɵɵelementStart(6, "nb-icon", 5);
      ɵɵlistener("click", function NbSelectComponent_Template_nb_icon_click_6_listener($event) {
        return ctx.disabled && $event.stopPropagation();
      });
      ɵɵelementEnd()();
      ɵɵtemplate(7, NbSelectComponent_nb_option_list_7_Template, 2, 5, "nb-option-list", 6);
    }
    if (rf & 2) {
      const _r3 = ɵɵreference(5);
      ɵɵproperty("disabled", ctx.disabled)("ngClass", ctx.selectButtonClasses);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.selectionModel.length)("ngIfElse", _r3);
    }
  },
  dependencies: [NgClass, NgIf, NbPortalDirective, NbIconComponent, NbOptionListComponent],
  styles: ["\n\n\n\n\n\n\n\n\n\n[_nghost-%COMP%]{display:inline-block;max-width:100%}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:left}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{right:.2em}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:right}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{left:.2em}.full-width[_nghost-%COMP%]{width:100%}.nb-transition[_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}.select-button[_ngcontent-%COMP%]{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}nb-icon[_ngcontent-%COMP%]{font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{right:.5rem}[dir=rtl][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{left:.5rem}.open[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]{transform:translateY(-50%) rotate(180deg)}"],
  changeDetection: 0
});
var NbSelectComponent = _NbSelectComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectComponent, [{
    type: Component,
    args: [{
      selector: "nb-select",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbSelectComponent),
        multi: true
      }, {
        provide: NB_SELECT_INJECTION_TOKEN,
        useExisting: NbSelectComponent
      }, {
        provide: NbFormFieldControl,
        useExisting: NbSelectComponent
      }, {
        provide: NbFormFieldControlConfig,
        useFactory: nbSelectFormFieldControlConfigFactory
      }],
      template: '<button\n  [disabled]="disabled"\n  [ngClass]="selectButtonClasses"\n  (blur)="trySetTouched()"\n  (keydown.arrowDown)="show()"\n  (keydown.arrowUp)="show()"\n  class="select-button"\n  type="button"\n  #selectButton\n>\n  <span (click)="disabled && $event.stopPropagation()">\n    <ng-container *ngIf="selectionModel.length; else placeholderTemplate">\n      <ng-container *ngIf="customLabel; else defaultSelectionTemplate">\n        <ng-content select="nb-select-label"></ng-content>\n      </ng-container>\n\n      <ng-template #defaultSelectionTemplate>{{ selectionView }}</ng-template>\n    </ng-container>\n\n    <ng-template #placeholderTemplate>{{ placeholder }}</ng-template>\n  </span>\n\n  <nb-icon\n    icon="chevron-down-outline"\n    pack="nebular-essentials"\n    (click)="disabled && $event.stopPropagation()"\n    aria-hidden="true"\n  >\n  </nb-icon>\n</button>\n\n<nb-option-list\n  *nbPortal\n  [size]="size"\n  [position]="overlayPosition"\n  [style.width.px]="optionsWidth"\n  [ngClass]="optionsListClass"\n>\n  <ng-content select="nb-option, nb-option-group"></ng-content>\n</nb-option-list>\n',
      styles: ["/*!\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n *//**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:inline-block;max-width:100%}[dir=ltr] :host .select-button{text-align:left}[dir=ltr] :host .select-button nb-icon{right:.2em}[dir=rtl] :host .select-button{text-align:right}[dir=rtl] :host .select-button nb-icon{left:.2em}:host(.full-width){width:100%}:host(.nb-transition) .select-button{transition-duration:.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}.select-button{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}nb-icon{font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr] nb-icon{right:.5rem}[dir=rtl] nb-icon{left:.5rem}:host(.open) nb-icon{transform:translateY(-50%) rotate(180deg)}\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbOverlayService
  }, {
    type: ElementRef
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbFocusKeyManagerFactoryService
  }, {
    type: NbFocusMonitor
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    optionsListClass: [{
      type: Input
    }],
    optionsPanelClass: [{
      type: Input
    }],
    optionsWidth: [{
      type: Input
    }],
    outline: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-outline"]
    }],
    filled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-filled"]
    }],
    hero: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-hero"]
    }],
    disabled: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.full-width"]
    }],
    placeholder: [{
      type: Input
    }],
    compareWith: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    optionsOverlayOffset: [{
      type: Input
    }],
    scrollStrategy: [{
      type: Input
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    selectedChange: [{
      type: Output
    }],
    options: [{
      type: ContentChildren,
      args: [NbOptionComponent, {
        descendants: true
      }]
    }],
    customLabel: [{
      type: ContentChild,
      args: [NbSelectLabelComponent]
    }],
    portal: [{
      type: ViewChild,
      args: [NbPortalDirective]
    }],
    button: [{
      type: ViewChild,
      args: ["selectButton", {
        read: ElementRef
      }]
    }],
    isOpen: [{
      type: HostBinding,
      args: ["class.open"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }]
  });
})();
var _NbOptionGroupComponent = class _NbOptionGroupComponent {
  constructor() {
    this.destroy$ = new Subject();
    this._disabled = false;
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
    if (this.options) {
      this.updateOptionsDisabledState();
    }
  }
  get disabledAttribute() {
    return this.disabled ? "" : null;
  }
  ngAfterContentInit() {
    if (this.options.length) {
      this.asyncUpdateOptionsDisabledState();
    }
    this.options.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.asyncUpdateOptionsDisabledState());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  /**
   * Sets disabled state for each option to current group disabled state.
   */
  updateOptionsDisabledState() {
    this.options.forEach((option) => option.setDisabledByGroupState(this.disabled));
  }
  /**
   * Updates options disabled state after promise resolution.
   * This way change detection will be triggered after options state updated.
   * Use this method when updating options during change detection run (e.g. QueryList.changes, lifecycle hooks).
   */
  asyncUpdateOptionsDisabledState() {
    from(Promise.resolve()).pipe(takeUntil(this.destroy$)).subscribe(() => this.updateOptionsDisabledState());
  }
};
_NbOptionGroupComponent.ɵfac = function NbOptionGroupComponent_Factory(t) {
  return new (t || _NbOptionGroupComponent)();
};
_NbOptionGroupComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbOptionGroupComponent,
  selectors: [["nb-option-group"]],
  contentQueries: function NbOptionGroupComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbOptionComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t);
    }
  },
  hostVars: 1,
  hostBindings: function NbOptionGroupComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("disabled", ctx.disabledAttribute);
    }
  },
  inputs: {
    title: "title",
    disabled: "disabled"
  },
  ngContentSelectors: _c44,
  decls: 3,
  vars: 1,
  consts: [[1, "option-group-title"]],
  template: function NbOptionGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c43);
      ɵɵelementStart(0, "span", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
      ɵɵprojection(2);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate(ctx.title);
    }
  },
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:block}.option-group-title[_ngcontent-%COMP%]{display:block}"],
  changeDetection: 0
});
var NbOptionGroupComponent = _NbOptionGroupComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOptionGroupComponent, [{
    type: Component,
    args: [{
      selector: "nb-option-group",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `
    <span class="option-group-title">{{ title }}</span>
    <ng-content select="nb-option, ng-container"></ng-content>
  `,
      styles: ["/*\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:block}.option-group-title{display:block}\n"]
    }]
  }], null, {
    title: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    disabledAttribute: [{
      type: HostBinding,
      args: ["attr.disabled"]
    }],
    options: [{
      type: ContentChildren,
      args: [NbOptionComponent, {
        descendants: true
      }]
    }]
  });
})();
var NB_OPTION_LIST_COMPONENTS = [NbOptionListComponent, NbOptionComponent, NbOptionGroupComponent];
var _NbOptionModule = class _NbOptionModule {
};
_NbOptionModule.ɵfac = function NbOptionModule_Factory(t) {
  return new (t || _NbOptionModule)();
};
_NbOptionModule.ɵmod = ɵɵdefineNgModule({
  type: _NbOptionModule,
  declarations: [NbOptionListComponent, NbOptionComponent, NbOptionGroupComponent],
  imports: [CommonModule, NbCheckboxModule],
  exports: [NbOptionListComponent, NbOptionComponent, NbOptionGroupComponent]
});
_NbOptionModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, NbCheckboxModule]
});
var NbOptionModule = _NbOptionModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbOptionModule, [{
    type: NgModule,
    args: [{
      declarations: [...NB_OPTION_LIST_COMPONENTS],
      imports: [CommonModule, NbCheckboxModule],
      exports: [...NB_OPTION_LIST_COMPONENTS]
    }]
  }], null, null);
})();
var NB_SELECT_COMPONENTS$1 = [NbSelectComponent, NbSelectLabelComponent];
var _NbSelectModule = class _NbSelectModule {
};
_NbSelectModule.ɵfac = function NbSelectModule_Factory(t) {
  return new (t || _NbSelectModule)();
};
_NbSelectModule.ɵmod = ɵɵdefineNgModule({
  type: _NbSelectModule,
  declarations: [NbSelectComponent, NbSelectLabelComponent],
  imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule],
  exports: [NbSelectComponent, NbSelectLabelComponent, NbOptionModule]
});
_NbSelectModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule, NbOptionModule]
});
var NbSelectModule = _NbSelectModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule],
      exports: [...NB_SELECT_COMPONENTS$1, NbOptionModule],
      declarations: [...NB_SELECT_COMPONENTS$1]
    }]
  }], null, null);
})();
var _NbPrefixDirective = class _NbPrefixDirective {
};
_NbPrefixDirective.ɵfac = function NbPrefixDirective_Factory(t) {
  return new (t || _NbPrefixDirective)();
};
_NbPrefixDirective.ɵdir = ɵɵdefineDirective({
  type: _NbPrefixDirective,
  selectors: [["", "nbPrefix", ""]]
});
var NbPrefixDirective = _NbPrefixDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbPrefixDirective, [{
    type: Directive,
    args: [{
      selector: "[nbPrefix]"
    }]
  }], null, null);
})();
var _NbSuffixDirective = class _NbSuffixDirective {
};
_NbSuffixDirective.ɵfac = function NbSuffixDirective_Factory(t) {
  return new (t || _NbSuffixDirective)();
};
_NbSuffixDirective.ɵdir = ɵɵdefineDirective({
  type: _NbSuffixDirective,
  selectors: [["", "nbSuffix", ""]]
});
var NbSuffixDirective = _NbSuffixDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSuffixDirective, [{
    type: Directive,
    args: [{
      selector: "[nbSuffix]"
    }]
  }], null, null);
})();
function throwFormControlElementNotFound() {
  throw new Error(`NbFormFieldComponent must contain [nbInput]`);
}
var _NbFormFieldComponent = class _NbFormFieldComponent {
  constructor(cd, zone, elementRef, renderer) {
    this.cd = cd;
    this.zone = zone;
    this.elementRef = elementRef;
    this.renderer = renderer;
    this.destroy$ = new Subject();
    this.formControlState$ = new ReplaySubject(1);
    this.prefixClasses$ = this.formControlState$.pipe(map((s) => this.getAddonClasses("prefix", s)));
    this.suffixClasses$ = this.formControlState$.pipe(map((s) => this.getAddonClasses("suffix", s)));
  }
  ngAfterContentChecked() {
    if (!this.formControl) {
      throwFormControlElementNotFound();
    }
  }
  ngAfterContentInit() {
    this.subscribeToFormControlStateChange();
    this.subscribeToAddonChange();
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.elementRef.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
  shouldShowPrefix() {
    return this.getFormControlConfig().supportsPrefix && !!this.prefix.length;
  }
  shouldShowSuffix() {
    return this.getFormControlConfig().supportsSuffix && !!this.suffix.length;
  }
  subscribeToFormControlStateChange() {
    const {
      disabled$,
      focused$,
      size$,
      status$,
      fullWidth$
    } = this.formControl;
    combineLatest([disabled$, focused$, size$, status$, fullWidth$]).pipe(map(([disabled, focused, size, status, fullWidth]) => ({
      disabled,
      focused,
      size,
      status,
      fullWidth
    })), distinctUntilChanged((oldState, state2) => this.isStatesEqual(oldState, state2)), tap(({
      size,
      fullWidth
    }) => {
      const formFieldClasses = [`nb-form-field-size-${size}`];
      if (!fullWidth) {
        formFieldClasses.push("nb-form-field-limited-width");
      }
      this.formFieldClasses = formFieldClasses.join(" ");
    }), takeUntil(this.destroy$)).subscribe(this.formControlState$);
  }
  subscribeToAddonChange() {
    merge(this.prefix.changes, this.suffix.changes).pipe(takeUntil(this.destroy$)).subscribe(() => this.cd.markForCheck());
  }
  getAddonClasses(addon, state2) {
    const classes = ["nb-form-field-addon", `nb-form-field-${addon}-${state2.size}`];
    if (state2.disabled) {
      classes.push(`nb-form-field-addon-disabled`);
    } else if (state2.focused) {
      classes.push(`nb-form-field-addon-${state2.status}-highlight`);
    } else {
      classes.push(`nb-form-field-addon-${state2.status}`);
    }
    return classes;
  }
  getFormControlConfig() {
    return this.formControlConfig || new NbFormFieldControlConfig();
  }
  isStatesEqual(oldState, state2) {
    return oldState.status === state2.status && oldState.disabled === state2.disabled && oldState.focused === state2.focused && oldState.fullWidth === state2.fullWidth && oldState.size === state2.size;
  }
};
_NbFormFieldComponent.ɵfac = function NbFormFieldComponent_Factory(t) {
  return new (t || _NbFormFieldComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
};
_NbFormFieldComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbFormFieldComponent,
  selectors: [["nb-form-field"]],
  contentQueries: function NbFormFieldComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbFormFieldControl, 5);
      ɵɵcontentQuery(dirIndex, NbFormFieldControlConfig, 5);
      ɵɵcontentQuery(dirIndex, NbPrefixDirective, 5);
      ɵɵcontentQuery(dirIndex, NbSuffixDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.formControl = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.formControlConfig = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prefix = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suffix = _t);
    }
  },
  hostVars: 2,
  hostBindings: function NbFormFieldComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.formFieldClasses);
    }
  },
  ngContentSelectors: _c46,
  decls: 4,
  vars: 6,
  consts: [[3, "ngClass", 4, "ngIf"], [1, "nb-form-control-container"], [3, "ngClass"]],
  template: function NbFormFieldComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c45);
      ɵɵtemplate(0, NbFormFieldComponent_div_0_Template, 3, 3, "div", 0);
      ɵɵelementStart(1, "div", 1);
      ɵɵprojection(2);
      ɵɵelementEnd();
      ɵɵtemplate(3, NbFormFieldComponent_div_3_Template, 3, 3, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.shouldShowPrefix());
      ɵɵadvance();
      ɵɵclassProp("nb-form-field-control-with-prefix", ctx.shouldShowPrefix())("nb-form-field-control-with-suffix", ctx.shouldShowSuffix());
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.shouldShowSuffix());
    }
  },
  dependencies: [NgClass, NgIf, AsyncPipe],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:flex;align-items:center}[hidden][_nghost-%COMP%]{display:none}.nb-form-control-container[_ngcontent-%COMP%]{width:100%}"],
  changeDetection: 0
});
var NbFormFieldComponent = _NbFormFieldComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFormFieldComponent, [{
    type: Component,
    args: [{
      selector: "nb-form-field",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<div *ngIf="shouldShowPrefix()" [ngClass]="prefixClasses$ | async">\n  <ng-content select="[nbPrefix]"></ng-content>\n</div>\n\n<div class="nb-form-control-container"\n     [class.nb-form-field-control-with-prefix]="shouldShowPrefix()"\n     [class.nb-form-field-control-with-suffix]="shouldShowSuffix()">\n  <ng-content></ng-content>\n</div>\n\n<div *ngIf="shouldShowSuffix()" [ngClass]="suffixClasses$ | async">\n  <ng-content select="[nbSuffix]"></ng-content>\n</div>\n',
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;align-items:center}:host[hidden]{display:none}.nb-form-control-container{width:100%}\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    prefix: [{
      type: ContentChildren,
      args: [NbPrefixDirective, {
        descendants: true
      }]
    }],
    suffix: [{
      type: ContentChildren,
      args: [NbSuffixDirective, {
        descendants: true
      }]
    }],
    formControl: [{
      type: ContentChild,
      args: [NbFormFieldControl, {
        static: false
      }]
    }],
    formControlConfig: [{
      type: ContentChild,
      args: [NbFormFieldControlConfig, {
        static: false
      }]
    }],
    formFieldClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbSelectWithAutocompleteComponent = class _NbSelectWithAutocompleteComponent {
  /**
   * Specifies width (in pixels) to be set on `nb-option`s container (`nb-option-list`)
   * */
  get optionsWidth() {
    return this._optionsWidth ?? this.hostWidth;
  }
  set optionsWidth(value) {
    this._optionsWidth = value;
  }
  /**
   * Adds `outline` styles
   */
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  /**
   * Adds `filled` styles
   */
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  /**
   * Adds `hero` styles
   */
  get hero() {
    return this.appearance === "hero";
  }
  set hero(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "hero";
    }
  }
  /**
   * Disables the select
   */
  get disabled() {
    return !!this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  /**
   * If set element will fill its container
   */
  get fullWidth() {
    return this._fullWidth;
  }
  set fullWidth(value) {
    this._fullWidth = convertToBoolProperty(value);
  }
  /**
   * A function to compare option value with selected value.
   * By default, values are compared with strict equality (`===`).
   */
  get compareWith() {
    return this._compareWith;
  }
  set compareWith(fn) {
    if (typeof fn !== "function") {
      return;
    }
    this._compareWith = fn;
    if (this.selectionModel.length && this.canSelectValue()) {
      this.setSelection(this.selected);
    }
  }
  /**
   * Accepts selected item or array of selected items.
   * */
  set selected(value) {
    this.writeValue(value);
  }
  get selected() {
    return this.multiple ? this.selectionModel.map((o) => o.value) : this.selectionModel[0].value;
  }
  /**
   * Gives capability just write `multiple` over the element.
   * */
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = convertToBoolProperty(value);
    this.updatePositionStrategy();
    this.updateCurrentKeyManager();
  }
  /**
   * Experimental input.
   * Could be changed without any prior notice.
   * Use at your own risk.
   *
   * It replaces the button with input when the select is opened.
   * That replacement provides a very basic API to implement options filtering functionality.
   * Filtering itself isn't implemented inside select.
   * So it should be implemented by the user.
   */
  set withOptionsAutocomplete(value) {
    this._withOptionsAutocomplete = convertToBoolProperty(value);
    this.updatePositionStrategy();
    this.updateCurrentKeyManager();
    if (!value) {
      this.resetAutocompleteInput();
    }
  }
  get withOptionsAutocomplete() {
    return this._withOptionsAutocomplete;
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  /**
   * Determines is select opened.
   * */
  get isOpen() {
    return this.ref && this.ref.hasAttached();
  }
  get isOptionsAutocompleteAllowed() {
    return this.withOptionsAutocomplete;
  }
  get isOptionsAutocompleteInputShown() {
    return this.isOptionsAutocompleteAllowed && this.isOpen;
  }
  constructor(document, overlay, hostRef, positionBuilder, triggerStrategyBuilder, cd, focusKeyManagerFactoryService, focusMonitor, renderer, zone, statusService, activeDescendantKeyManagerFactoryService) {
    this.document = document;
    this.overlay = overlay;
    this.hostRef = hostRef;
    this.positionBuilder = positionBuilder;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.cd = cd;
    this.focusKeyManagerFactoryService = focusKeyManagerFactoryService;
    this.focusMonitor = focusMonitor;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this.activeDescendantKeyManagerFactoryService = activeDescendantKeyManagerFactoryService;
    this.size = "medium";
    this.status = "basic";
    this.shape = "rectangle";
    this.appearance = "outline";
    this._fullWidth = false;
    this.placeholder = "";
    this._compareWith = (v1, v2) => v1 === v2;
    this._multiple = false;
    this.optionsOverlayOffset = 8;
    this.scrollStrategy = "block";
    this._withOptionsAutocomplete = false;
    this.selectedChange = new EventEmitter();
    this.selectOpen = new EventEmitter();
    this.selectClose = new EventEmitter();
    this.optionsAutocompleteInputChange = new EventEmitter();
    this.selectionModel = [];
    this.positionStrategy$ = new BehaviorSubject(void 0);
    this.overlayPosition = "";
    this.alive = true;
    this.destroy$ = new Subject();
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.status$ = new BehaviorSubject(this.status);
    this.size$ = new BehaviorSubject(this.size);
    this.focused$ = new BehaviorSubject(false);
    this.disabled$ = new BehaviorSubject(this.disabled);
    this.fullWidth$ = new BehaviorSubject(this.fullWidth);
    this.lastShownButtonWidth = void 0;
  }
  /**
   * Determines is select hidden.
   * */
  get isHidden() {
    return !this.isOpen;
  }
  /**
   * Returns width of the select button.
   * */
  get hostWidth() {
    if (this.isOptionsAutocompleteInputShown) {
      return this.optionsAutocompleteInput.nativeElement.getBoundingClientRect().width;
    }
    return this.button.nativeElement.getBoundingClientRect().width;
  }
  get selectButtonClasses() {
    const classes = [];
    if (!this.selectionModel.length) {
      classes.push("placeholder");
    }
    if (!this.selectionModel.length && !this.placeholder) {
      classes.push("empty");
    }
    if (this.isOpen) {
      classes.push(this.overlayPosition);
    }
    return classes;
  }
  /**
   * Content rendered in the label.
   * */
  get selectionView() {
    if (this.isOptionsAutocompleteInputShown && this.multiple) {
      return "";
    }
    if (this.selectionModel.length > 1) {
      return this.selectionModel.map((option) => option.content).join(", ");
    }
    return this.selectionModel[0]?.content?.trim() ?? "";
  }
  ngOnChanges({
    disabled,
    status,
    size,
    fullWidth
  }) {
    if (disabled) {
      this.disabled$.next(disabled.currentValue);
    }
    if (status) {
      this.status$.next(status.currentValue);
    }
    if (size) {
      this.size$.next(size.currentValue);
    }
    if (fullWidth) {
      this.fullWidth$.next(this.fullWidth);
    }
  }
  ngAfterContentInit() {
    this.options.changes.pipe(
      startWith(this.options),
      filter(() => this.queue != null && this.canSelectValue()),
      // Call 'writeValue' when current change detection run is finished.
      // When writing is finished, change detection starts again, since
      // microtasks queue is empty.
      // Prevents ExpressionChangedAfterItHasBeenCheckedError.
      switchMap((options) => from(Promise.resolve(options))),
      takeUntil(this.destroy$)
    ).subscribe(() => this.writeValue(this.queue));
  }
  ngAfterViewInit() {
    this.triggerStrategy = this.createTriggerStrategy();
    this.subscribeOnButtonFocus();
    this.subscribeOnTriggers();
    this.subscribeOnOptionClick();
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostRef.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.alive = false;
    this.destroy$.next();
    this.destroy$.complete();
    if (this.ref) {
      this.ref.dispose();
    }
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
  }
  onAutocompleteInputChange(event) {
    this.optionsAutocompleteInputChange.emit(event.target.value);
  }
  show() {
    if (this.shouldShow()) {
      this.lastShownButtonWidth = this.hostWidth;
      this.attachToOverlay();
      this.positionStrategy$.pipe(switchMap((positionStrategy) => positionStrategy.positionChange ?? EMPTY), take(1), takeUntil(this.destroy$)).subscribe(() => {
        if (this.isOptionsAutocompleteInputShown) {
          this.optionsAutocompleteInput.nativeElement.focus();
        }
        this.setActiveOption();
      });
      this.selectOpen.emit();
      this.cd.markForCheck();
    }
  }
  hide() {
    if (this.isOpen) {
      this.ref.detach();
      this.cd.markForCheck();
      this.selectClose.emit();
      this.resetAutocompleteInput();
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.cd.markForCheck();
  }
  writeValue(value) {
    if (!this.alive) {
      return;
    }
    if (this.canSelectValue()) {
      this.setSelection(value);
      if (this.selectionModel.length) {
        this.queue = null;
      }
    } else {
      this.queue = value;
    }
  }
  /**
   * Selects option or clear all selected options if value is null.
   * */
  handleOptionClick(option) {
    this.queue = null;
    if (option.value == null) {
      this.reset();
    } else {
      this.selectOption(option);
    }
    this.cd.markForCheck();
  }
  /**
   * Deselect all selected options.
   * */
  reset() {
    this.selectionModel.forEach((option) => option.deselect());
    this.selectionModel = [];
    this.hide();
    this.focusButton();
    this.emitSelected(this.multiple ? [] : null);
  }
  /**
   * Determines how to select option as multiple or single.
   * */
  selectOption(option) {
    if (this.multiple) {
      this.handleMultipleSelect(option);
    } else {
      this.handleSingleSelect(option);
    }
  }
  /**
   * Select single option.
   * */
  handleSingleSelect(option) {
    const selected = this.selectionModel.pop();
    if (selected && !this._compareWith(selected.value, option.value)) {
      selected.deselect();
    }
    this.selectionModel = [option];
    option.select();
    this.hide();
    this.focusButton();
    this.emitSelected(option.value);
  }
  /**
   * Select for multiple options.
   * */
  handleMultipleSelect(option) {
    if (option.selected) {
      this.selectionModel = this.selectionModel.filter((s) => !this._compareWith(s.value, option.value));
      option.deselect();
    } else {
      this.selectionModel.push(option);
      option.select();
    }
    this.emitSelected(this.selectionModel.map((opt) => opt.value));
  }
  attachToOverlay() {
    if (!this.ref) {
      this.createOverlay();
      this.subscribeOnPositionChange();
      this.createKeyManager();
      this.subscribeOnOverlayKeys();
      this.subscribeOnOptionsAutocompleteChange();
    }
    this.ref.attach(this.portal);
  }
  setActiveOption() {
    if (this.selectionModel.length && !this.selectionModel[0].hidden) {
      this.currentKeyManager?.setActiveItem(this.selectionModel[0]);
    } else {
      this.currentKeyManager?.setFirstItemActive();
    }
  }
  createOverlay() {
    const scrollStrategy = this.createScrollStrategy();
    this.positionStrategy$.next(this.createPositionStrategy());
    this.ref = this.overlay.create({
      positionStrategy: this.positionStrategy$.value,
      scrollStrategy,
      panelClass: this.optionsPanelClass
    });
  }
  createKeyManager() {
    this.activeDescendantKeyManager = this.activeDescendantKeyManagerFactoryService.create(this.options).skipPredicate((option) => {
      return this.isOptionHidden(option);
    });
    this.focusKeyManager = this.focusKeyManagerFactoryService.create(this.options).withTypeAhead(200).skipPredicate((option) => {
      return this.isOptionHidden(option);
    });
    this.updateCurrentKeyManager();
  }
  updateCurrentKeyManager() {
    this.currentKeyManager?.setActiveItem(-1);
    if (this.isOptionsAutocompleteAllowed) {
      this.currentKeyManager = this.activeDescendantKeyManager;
    } else {
      this.currentKeyManager = this.focusKeyManager;
    }
    this.setActiveOption();
  }
  resetAutocompleteInput() {
    if (this.optionsAutocompleteInput?.nativeElement) {
      this.optionsAutocompleteInput.nativeElement.value = this.selectionView;
      this.optionsAutocompleteInputChange.emit("");
    }
  }
  createPositionStrategy() {
    const element = this.isOptionsAutocompleteAllowed ? this.optionsAutocompleteInput : this.button;
    return this.positionBuilder.connectedTo(element).position(NbPosition.BOTTOM).offset(this.optionsOverlayOffset).adjustment(NbAdjustment.VERTICAL);
  }
  updatePositionStrategy() {
    if (this.ref) {
      this.positionStrategy$.next(this.createPositionStrategy());
      this.ref.updatePositionStrategy(this.positionStrategy$.value);
      if (this.isOpen) {
        this.ref.updatePosition();
      }
    }
  }
  createScrollStrategy() {
    return this.overlay.scrollStrategies[this.scrollStrategy]();
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.CLICK).host(this.hostRef.nativeElement).container(() => this.getContainer()).build();
  }
  subscribeOnTriggers() {
    this.triggerStrategy.show$.subscribe(() => this.show());
    this.triggerStrategy.hide$.pipe(filter(() => this.isOpen)).subscribe(($event) => {
      this.hide();
      if (!this.isClickedWithinComponent($event)) {
        this.onTouched();
      }
    });
  }
  subscribeOnPositionChange() {
    this.positionStrategy$.pipe(switchMap((positionStrategy) => positionStrategy.positionChange ?? EMPTY), takeUntil(this.destroy$)).subscribe((position) => {
      this.overlayPosition = position;
      this.cd.detectChanges();
    });
  }
  subscribeOnOptionClick() {
    this.options.changes.pipe(startWith(this.options), switchMap((options) => {
      return merge(...options.map((option) => option.click));
    }), takeUntil(this.destroy$)).subscribe((clickedOption) => this.handleOptionClick(clickedOption));
  }
  subscribeOnOverlayKeys() {
    this.ref.keydownEvents().pipe(filter(() => this.isOpen), takeUntil(this.destroy$)).subscribe((event) => {
      if (event.keyCode === ESCAPE) {
        this.hide();
        this.focusButton();
      } else if (event.keyCode === ENTER && this.isOptionsAutocompleteInputShown) {
        event.preventDefault();
        const activeItem = this.currentKeyManager.activeItem;
        if (activeItem) {
          this.selectOption(activeItem);
        }
      } else {
        this.currentKeyManager.onKeydown(event);
      }
    });
    merge(this.focusKeyManager.tabOut.pipe(filter(() => !this.isOptionsAutocompleteInputShown)), this.activeDescendantKeyManager.tabOut.pipe(filter(() => this.isOptionsAutocompleteInputShown))).pipe(takeUntil(this.destroy$)).subscribe(() => {
      this.hide();
      this.onTouched();
    });
  }
  subscribeOnOptionsAutocompleteChange() {
    this.optionsAutocompleteInputChange.pipe(observeOn(animationFrameScheduler), filter(() => this.isOptionsAutocompleteInputShown), takeUntil(this.destroy$)).subscribe(() => {
      if (this.isOptionHidden(this.currentKeyManager.activeItem)) {
        this.currentKeyManager.setFirstItemActive();
      }
    });
  }
  subscribeOnButtonFocus() {
    const buttonFocus$ = this.focusMonitor.monitor(this.button).pipe(map((origin) => !!origin), startWith(false), finalize(() => this.focusMonitor.stopMonitoring(this.button)));
    const filterInputFocus$ = this.focusMonitor.monitor(this.optionsAutocompleteInput).pipe(map((origin) => !!origin), startWith(false), finalize(() => this.focusMonitor.stopMonitoring(this.button)));
    combineLatest([buttonFocus$, filterInputFocus$]).pipe(map(([buttonFocus, filterInputFocus]) => buttonFocus || filterInputFocus), takeUntil(this.destroy$)).subscribe(this.focused$);
  }
  getContainer() {
    return this.ref && this.ref.hasAttached() && {
      location: {
        nativeElement: this.ref.overlayElement
      }
    };
  }
  focusButton() {
    setTimeout(() => {
      this.button?.nativeElement?.focus();
    });
  }
  /**
   * Propagate selected value.
   * */
  emitSelected(selected) {
    this.onChange(selected);
    this.selectedChange.emit(selected);
  }
  /**
   * Set selected value in model.
   * */
  setSelection(value) {
    const isResetValue = value == null;
    let safeValue = value;
    if (this.multiple) {
      safeValue = value ?? [];
    }
    const isArray = Array.isArray(safeValue);
    if (this.multiple && !isArray && !isResetValue) {
      throw new Error("Can't assign single value if select is marked as multiple");
    }
    if (!this.multiple && isArray) {
      throw new Error("Can't assign array if select is not marked as multiple");
    }
    const previouslySelectedOptions = this.selectionModel;
    this.selectionModel = [];
    if (this.multiple) {
      safeValue.forEach((option) => this.selectValue(option));
    } else {
      this.selectValue(safeValue);
    }
    previouslySelectedOptions.filter((option) => !this.selectionModel.includes(option)).forEach((option) => option.deselect());
    this.cd.markForCheck();
  }
  /**
   * Selects value.
   * */
  selectValue(value) {
    if (value == null) {
      return;
    }
    const corresponding = this.options.find((option) => this._compareWith(option.value, value));
    if (corresponding) {
      corresponding.select();
      this.selectionModel.push(corresponding);
    }
  }
  shouldShow() {
    return this.isHidden && this.options?.length > 0;
  }
  /**
   * Sets touched if focus moved outside of button and overlay,
   * ignoring the case when focus moved to options overlay.
   */
  trySetTouched() {
    if (this.isHidden) {
      this.onTouched();
    }
  }
  isClickedWithinComponent($event) {
    return this.hostRef.nativeElement === $event.target || this.hostRef.nativeElement.contains($event.target);
  }
  canSelectValue() {
    return !!(this.options && this.options.length);
  }
  isOptionHidden(option) {
    return option.hidden;
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get primary() {
    return this.status === "primary";
  }
  get info() {
    return this.status === "info";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get rectangle() {
    return this.shape === "rectangle";
  }
  get round() {
    return this.shape === "round";
  }
  get semiRound() {
    return this.shape === "semi-round";
  }
};
_NbSelectWithAutocompleteComponent.ɵfac = function NbSelectWithAutocompleteComponent_Factory(t) {
  return new (t || _NbSelectWithAutocompleteComponent)(ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbPositionBuilderService), ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbFocusKeyManagerFactoryService), ɵɵdirectiveInject(NbFocusMonitor), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService), ɵɵdirectiveInject(NbActiveDescendantKeyManagerFactoryService));
};
_NbSelectWithAutocompleteComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSelectWithAutocompleteComponent,
  selectors: [["nb-select-with-autocomplete"]],
  contentQueries: function NbSelectWithAutocompleteComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbSelectLabelComponent, 5);
      ɵɵcontentQuery(dirIndex, NbOptionComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.customLabel = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t);
    }
  },
  viewQuery: function NbSelectWithAutocompleteComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbPortalDirective, 5);
      ɵɵviewQuery(_c40, 5, ElementRef);
      ɵɵviewQuery(_c47, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portal = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.button = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.optionsAutocompleteInput = _t.first);
    }
  },
  hostVars: 42,
  hostBindings: function NbSelectWithAutocompleteComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("appearance-outline", ctx.outline)("appearance-filled", ctx.filled)("appearance-hero", ctx.hero)("full-width", ctx.fullWidth)("open", ctx.isOpen)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("shape-rectangle", ctx.rectangle)("shape-round", ctx.round)("shape-semi-round", ctx.semiRound);
    }
  },
  inputs: {
    size: "size",
    status: "status",
    shape: "shape",
    appearance: "appearance",
    optionsListClass: "optionsListClass",
    optionsPanelClass: "optionsPanelClass",
    optionsWidth: "optionsWidth",
    outline: "outline",
    filled: "filled",
    hero: "hero",
    disabled: "disabled",
    fullWidth: "fullWidth",
    placeholder: "placeholder",
    compareWith: "compareWith",
    selected: "selected",
    multiple: "multiple",
    optionsOverlayOffset: "optionsOverlayOffset",
    scrollStrategy: "scrollStrategy",
    withOptionsAutocomplete: "withOptionsAutocomplete"
  },
  outputs: {
    selectedChange: "selectedChange",
    selectOpen: "selectOpen",
    selectClose: "selectClose",
    optionsAutocompleteInputChange: "optionsAutocompleteInputChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbSelectWithAutocompleteComponent),
    multi: true
  }, {
    provide: NB_SELECT_INJECTION_TOKEN,
    useExisting: _NbSelectWithAutocompleteComponent
  }, {
    provide: NbFormFieldControl,
    useExisting: _NbSelectWithAutocompleteComponent
  }, {
    provide: NbFormFieldControlConfig,
    useFactory: nbSelectFormFieldControlConfigFactory
  }]), ɵɵNgOnChangesFeature],
  ngContentSelectors: _c42,
  decls: 12,
  vars: 13,
  consts: [["type", "button", 1, "select-button", 3, "hidden", "disabled", "ngClass", "blur", "keydown.arrowDown", "keydown.arrowUp"], ["selectButton", ""], [3, "click"], [4, "ngIf", "ngIfElse"], ["placeholderTemplate", ""], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "click"], [3, "hidden"], ["nbInput", "", "fullWidth", "", 3, "value", "placeholder", "status", "shape", "fieldSize", "blur", "click", "dblclick", "input"], ["optionsAutocompleteInput", ""], ["nbSuffix", "", "icon", "chevron-up-outline", "pack", "nebular-essentials", "aria-hidden", "true"], [3, "size", "position", "width", "ngClass", 4, "nbPortal"], ["defaultSelectionTemplate", ""], [3, "size", "position", "ngClass"]],
  template: function NbSelectWithAutocompleteComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c41);
      ɵɵelementStart(0, "button", 0, 1);
      ɵɵlistener("blur", function NbSelectWithAutocompleteComponent_Template_button_blur_0_listener() {
        return ctx.trySetTouched();
      })("keydown.arrowDown", function NbSelectWithAutocompleteComponent_Template_button_keydown_arrowDown_0_listener() {
        return ctx.show();
      })("keydown.arrowUp", function NbSelectWithAutocompleteComponent_Template_button_keydown_arrowUp_0_listener() {
        return ctx.show();
      });
      ɵɵelementStart(2, "span", 2);
      ɵɵlistener("click", function NbSelectWithAutocompleteComponent_Template_span_click_2_listener($event) {
        return ctx.disabled && $event.stopPropagation();
      });
      ɵɵtemplate(3, NbSelectWithAutocompleteComponent_ng_container_3_Template, 4, 2, "ng-container", 3)(4, NbSelectWithAutocompleteComponent_ng_template_4_Template, 1, 1, "ng-template", null, 4, ɵɵtemplateRefExtractor);
      ɵɵelementEnd();
      ɵɵelementStart(6, "nb-icon", 5);
      ɵɵlistener("click", function NbSelectWithAutocompleteComponent_Template_nb_icon_click_6_listener($event) {
        return ctx.disabled && $event.stopPropagation();
      });
      ɵɵelementEnd()();
      ɵɵelementStart(7, "nb-form-field", 6)(8, "input", 7, 8);
      ɵɵlistener("blur", function NbSelectWithAutocompleteComponent_Template_input_blur_8_listener() {
        return ctx.trySetTouched();
      })("click", function NbSelectWithAutocompleteComponent_Template_input_click_8_listener($event) {
        return $event.stopPropagation();
      })("dblclick", function NbSelectWithAutocompleteComponent_Template_input_dblclick_8_listener($event) {
        return $event.stopPropagation();
      })("input", function NbSelectWithAutocompleteComponent_Template_input_input_8_listener($event) {
        return ctx.onAutocompleteInputChange($event);
      });
      ɵɵelementEnd();
      ɵɵelement(10, "nb-icon", 9);
      ɵɵelementEnd();
      ɵɵtemplate(11, NbSelectWithAutocompleteComponent_nb_option_list_11_Template, 2, 5, "nb-option-list", 10);
    }
    if (rf & 2) {
      const _r3 = ɵɵreference(5);
      ɵɵproperty("hidden", ctx.isOptionsAutocompleteInputShown)("disabled", ctx.disabled)("ngClass", ctx.selectButtonClasses);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.selectionModel.length)("ngIfElse", _r3);
      ɵɵadvance(4);
      ɵɵproperty("hidden", !ctx.isOptionsAutocompleteInputShown);
      ɵɵadvance();
      ɵɵstyleProp("max-width", ctx.lastShownButtonWidth, "px");
      ɵɵproperty("value", ctx.selectionView)("placeholder", ctx.placeholder)("status", ctx.status)("shape", ctx.shape)("fieldSize", ctx.size);
    }
  },
  dependencies: [NgClass, NgIf, NbPortalDirective, NbInputDirective, NbIconComponent, NbOptionListComponent, NbFormFieldComponent, NbSuffixDirective],
  styles: ["\n\n\n\n\n\n\n\n\n\n[_nghost-%COMP%]{display:inline-block;max-width:100%}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:left}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{right:.2em}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:right}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{left:.2em}.full-width[_nghost-%COMP%]{width:100%}.nb-transition[_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}.select-button[_ngcontent-%COMP%], nb-form-field[_ngcontent-%COMP%]{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}nb-icon[_ngcontent-%COMP%]:not([nbSuffix]){font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]:not([nbSuffix]){right:.5rem}[dir=rtl][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]:not([nbSuffix]){left:.5rem}.open[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]:not([nbSuffix]){transform:translateY(-50%) rotate(180deg)}"],
  changeDetection: 0
});
var NbSelectWithAutocompleteComponent = _NbSelectWithAutocompleteComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectWithAutocompleteComponent, [{
    type: Component,
    args: [{
      selector: "nb-select-with-autocomplete",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbSelectWithAutocompleteComponent),
        multi: true
      }, {
        provide: NB_SELECT_INJECTION_TOKEN,
        useExisting: NbSelectWithAutocompleteComponent
      }, {
        provide: NbFormFieldControl,
        useExisting: NbSelectWithAutocompleteComponent
      }, {
        provide: NbFormFieldControlConfig,
        useFactory: nbSelectFormFieldControlConfigFactory
      }],
      template: '<button\n  [hidden]="isOptionsAutocompleteInputShown"\n  [disabled]="disabled"\n  [ngClass]="selectButtonClasses"\n  (blur)="trySetTouched()"\n  (keydown.arrowDown)="show()"\n  (keydown.arrowUp)="show()"\n  class="select-button"\n  type="button"\n  #selectButton\n>\n  <span (click)="disabled && $event.stopPropagation()">\n    <ng-container *ngIf="selectionModel.length; else placeholderTemplate">\n      <ng-container *ngIf="customLabel; else defaultSelectionTemplate">\n        <ng-content select="nb-select-label"></ng-content>\n      </ng-container>\n\n      <ng-template #defaultSelectionTemplate>{{ selectionView }}</ng-template>\n    </ng-container>\n\n    <ng-template #placeholderTemplate>{{ placeholder }}</ng-template>\n  </span>\n\n  <nb-icon\n    icon="chevron-down-outline"\n    pack="nebular-essentials"\n    (click)="disabled && $event.stopPropagation()"\n    aria-hidden="true"\n  >\n  </nb-icon>\n</button>\n\n<nb-form-field [hidden]="!isOptionsAutocompleteInputShown">\n  <input\n    nbInput\n    fullWidth\n    [style.max-width.px]="lastShownButtonWidth"\n    #optionsAutocompleteInput\n    [value]="selectionView"\n    [placeholder]="placeholder"\n    [status]="status"\n    [shape]="shape"\n    [fieldSize]="size"\n    (blur)="trySetTouched()"\n    (click)="$event.stopPropagation()"\n    (dblclick)="$event.stopPropagation()"\n    (input)="onAutocompleteInputChange($event)"\n  />\n  <nb-icon nbSuffix icon="chevron-up-outline" pack="nebular-essentials" aria-hidden="true"> </nb-icon>\n</nb-form-field>\n\n<nb-option-list\n  *nbPortal\n  [size]="size"\n  [position]="overlayPosition"\n  [style.width.px]="optionsWidth"\n  [ngClass]="optionsListClass"\n>\n  <ng-content select="nb-option, nb-option-group"></ng-content>\n</nb-option-list>\n',
      styles: ["/*!\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n *//**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:inline-block;max-width:100%}[dir=ltr] :host .select-button{text-align:left}[dir=ltr] :host .select-button nb-icon{right:.2em}[dir=rtl] :host .select-button{text-align:right}[dir=rtl] :host .select-button nb-icon{left:.2em}:host(.full-width){width:100%}:host(.nb-transition) .select-button{transition-duration:.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}.select-button,nb-form-field{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}nb-icon:not([nbSuffix]){font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr] nb-icon:not([nbSuffix]){right:.5rem}[dir=rtl] nb-icon:not([nbSuffix]){left:.5rem}:host(.open) nb-icon:not([nbSuffix]){transform:translateY(-50%) rotate(180deg)}\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbOverlayService
  }, {
    type: ElementRef
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbFocusKeyManagerFactoryService
  }, {
    type: NbFocusMonitor
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }, {
    type: NbActiveDescendantKeyManagerFactoryService
  }], {
    size: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    shape: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    optionsListClass: [{
      type: Input
    }],
    optionsPanelClass: [{
      type: Input
    }],
    optionsWidth: [{
      type: Input
    }],
    outline: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-outline"]
    }],
    filled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-filled"]
    }],
    hero: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.appearance-hero"]
    }],
    disabled: [{
      type: Input
    }],
    fullWidth: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.full-width"]
    }],
    placeholder: [{
      type: Input
    }],
    compareWith: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    optionsOverlayOffset: [{
      type: Input
    }],
    scrollStrategy: [{
      type: Input
    }],
    withOptionsAutocomplete: [{
      type: Input
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    selectedChange: [{
      type: Output
    }],
    selectOpen: [{
      type: Output
    }],
    selectClose: [{
      type: Output
    }],
    optionsAutocompleteInputChange: [{
      type: Output
    }],
    options: [{
      type: ContentChildren,
      args: [NbOptionComponent, {
        descendants: true
      }]
    }],
    customLabel: [{
      type: ContentChild,
      args: [NbSelectLabelComponent]
    }],
    portal: [{
      type: ViewChild,
      args: [NbPortalDirective]
    }],
    button: [{
      type: ViewChild,
      args: ["selectButton", {
        read: ElementRef
      }]
    }],
    optionsAutocompleteInput: [{
      type: ViewChild,
      args: ["optionsAutocompleteInput", {
        read: ElementRef
      }]
    }],
    isOpen: [{
      type: HostBinding,
      args: ["class.open"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    rectangle: [{
      type: HostBinding,
      args: ["class.shape-rectangle"]
    }],
    round: [{
      type: HostBinding,
      args: ["class.shape-round"]
    }],
    semiRound: [{
      type: HostBinding,
      args: ["class.shape-semi-round"]
    }]
  });
})();
var COMPONENTS$1 = [NbFormFieldComponent, NbPrefixDirective, NbSuffixDirective];
var _NbFormFieldModule = class _NbFormFieldModule {
};
_NbFormFieldModule.ɵfac = function NbFormFieldModule_Factory(t) {
  return new (t || _NbFormFieldModule)();
};
_NbFormFieldModule.ɵmod = ɵɵdefineNgModule({
  type: _NbFormFieldModule,
  declarations: [NbFormFieldComponent, NbPrefixDirective, NbSuffixDirective],
  imports: [CommonModule],
  exports: [NbFormFieldComponent, NbPrefixDirective, NbSuffixDirective]
});
_NbFormFieldModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
var NbFormFieldModule = _NbFormFieldModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFormFieldModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [...COMPONENTS$1],
      exports: [...COMPONENTS$1]
    }]
  }], null, null);
})();
var NB_SELECT_COMPONENTS = [NbSelectWithAutocompleteComponent];
var _NbSelectWithAutocompleteModule = class _NbSelectWithAutocompleteModule {
};
_NbSelectWithAutocompleteModule.ɵfac = function NbSelectWithAutocompleteModule_Factory(t) {
  return new (t || _NbSelectWithAutocompleteModule)();
};
_NbSelectWithAutocompleteModule.ɵmod = ɵɵdefineNgModule({
  type: _NbSelectWithAutocompleteModule,
  declarations: [NbSelectWithAutocompleteComponent],
  imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule, NbFormFieldModule, NbSelectModule],
  exports: [NbSelectWithAutocompleteComponent, NbOptionModule, NbSelectModule]
});
_NbSelectWithAutocompleteModule.ɵinj = ɵɵdefineInjector({
  imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule, NbFormFieldModule, NbSelectModule, NbOptionModule, NbSelectModule]
});
var NbSelectWithAutocompleteModule = _NbSelectWithAutocompleteModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSelectWithAutocompleteModule, [{
    type: NgModule,
    args: [{
      imports: [NbSharedModule, NbOverlayModule, NbButtonModule, NbInputModule, NbCardModule, NbIconModule, NbOptionModule, NbFormFieldModule, NbSelectModule],
      exports: [...NB_SELECT_COMPONENTS, NbOptionModule, NbSelectModule],
      declarations: [...NB_SELECT_COMPONENTS]
    }]
  }], null, null);
})();
var lastAutocompleteId = 0;
var _NbAutocompleteComponent = class _NbAutocompleteComponent {
  get overlayPosition() {
    return this._overlayPosition;
  }
  set overlayPosition(value) {
    this._overlayPosition = value;
    this.cd.detectChanges();
  }
  /**
   * Returns width of the input.
   * */
  get hostWidth() {
    return this.hostRef.nativeElement.getBoundingClientRect().width;
  }
  /**
   * Specifies width (in pixels) to be set on `nb-option`s container (`nb-option-list`)
   * */
  get optionsWidth() {
    return this._optionsWidth ?? this.hostWidth;
  }
  set optionsWidth(value) {
    this._optionsWidth = value;
  }
  constructor(cd) {
    this.cd = cd;
    this.destroy$ = new Subject();
    this.id = `nb-autocomplete-${lastAutocompleteId++}`;
    this._overlayPosition = "";
    this.size = "medium";
    this.activeFirst = false;
    this.selectedChange = new EventEmitter();
  }
  ngAfterContentInit() {
    this.options.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this.cd.detectChanges());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  /**
   * Autocomplete knows nothing about host html input element.
   * So, attach method set input hostRef for styling.
   * */
  setHost(hostRef) {
    this.hostRef = hostRef;
  }
  /**
   * Propagate selected value.
   * */
  emitSelected(selected) {
    this.selectedChange.emit(selected);
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
};
_NbAutocompleteComponent.ɵfac = function NbAutocompleteComponent_Factory(t) {
  return new (t || _NbAutocompleteComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbAutocompleteComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbAutocompleteComponent,
  selectors: [["nb-autocomplete"]],
  contentQueries: function NbAutocompleteComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbOptionComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t);
    }
  },
  viewQuery: function NbAutocompleteComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbPortalDirective, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.portal = _t.first);
    }
  },
  hostVars: 10,
  hostBindings: function NbAutocompleteComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant);
    }
  },
  inputs: {
    handleDisplayFn: "handleDisplayFn",
    size: "size",
    activeFirst: "activeFirst",
    optionsListClass: "optionsListClass",
    optionsPanelClass: "optionsPanelClass",
    optionsWidth: "optionsWidth"
  },
  outputs: {
    selectedChange: "selectedChange"
  },
  ngContentSelectors: _c49,
  decls: 1,
  vars: 0,
  consts: [["role", "listbox", 3, "size", "position", "width", "id", "empty", "ngClass", 4, "nbPortal"], ["role", "listbox", 3, "size", "position", "id", "ngClass"]],
  template: function NbAutocompleteComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c48);
      ɵɵtemplate(0, NbAutocompleteComponent_nb_option_list_0_Template, 2, 8, "nb-option-list", 0);
    }
  },
  dependencies: [NgClass, NbPortalDirective, NbOptionListComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]:hover{cursor:pointer}nb-option-list.empty[_ngcontent-%COMP%]{border:none}"],
  changeDetection: 0
});
var NbAutocompleteComponent = _NbAutocompleteComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAutocompleteComponent, [{
    type: Component,
    args: [{
      selector: "nb-autocomplete",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<nb-option-list *nbPortal\n                [size]="size"\n                [position]="overlayPosition"\n                [style.width.px]="optionsWidth"\n                role="listbox"\n                [id]="id"\n                [class.empty]="!options?.length"\n                [ngClass]="optionsListClass">\n  <ng-content select="nb-option, nb-option-group"></ng-content>\n</nb-option-list>\n',
      styles: ["/*\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host(:hover){cursor:pointer}nb-option-list.empty{border:none}\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }], {
    handleDisplayFn: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    activeFirst: [{
      type: Input
    }],
    optionsListClass: [{
      type: Input
    }],
    optionsPanelClass: [{
      type: Input
    }],
    optionsWidth: [{
      type: Input
    }],
    selectedChange: [{
      type: Output
    }],
    options: [{
      type: ContentChildren,
      args: [NbOptionComponent, {
        descendants: true
      }]
    }],
    portal: [{
      type: ViewChild,
      args: [NbPortalDirective]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }]
  });
})();
var _NbAutocompleteDirective = class _NbAutocompleteDirective {
  /**
   * Determines is autocomplete overlay opened.
   * */
  get isOpen() {
    return this.overlayRef && this.overlayRef.hasAttached();
  }
  /**
   * Determines is autocomplete overlay closed.
   * */
  get isClosed() {
    return !this.isOpen;
  }
  /**
   * Provides autocomplete component.
   * */
  get autocomplete() {
    return this._autocomplete;
  }
  set autocomplete(autocomplete) {
    this._autocomplete = autocomplete;
  }
  get top() {
    return this.isOpen && this.autocomplete.options.length && this.autocomplete.overlayPosition === NbPosition.TOP;
  }
  get bottom() {
    return this.isOpen && this.autocomplete.options.length && this.autocomplete.overlayPosition === NbPosition.BOTTOM;
  }
  get ariaExpanded() {
    return this.isOpen && this.isOpen.toString();
  }
  get ariaOwns() {
    return this.isOpen ? this.autocomplete.id : null;
  }
  get ariaActiveDescendant() {
    return this.isOpen && this.keyManager.activeItem ? this.keyManager.activeItem.id : null;
  }
  constructor(hostRef, overlay, cd, triggerStrategyBuilder, positionBuilder, activeDescendantKeyManagerFactory, renderer) {
    this.hostRef = hostRef;
    this.overlay = overlay;
    this.cd = cd;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.positionBuilder = positionBuilder;
    this.activeDescendantKeyManagerFactory = activeDescendantKeyManagerFactory;
    this.renderer = renderer;
    this.destroy$ = new Subject();
    this._onChange = () => {
    };
    this._onTouched = () => {
    };
    this.overlayOffset = 8;
    this.scrollStrategy = "block";
    this.role = "combobox";
    this.ariaAutocomplete = "list";
    this.hasPopup = "true";
  }
  ngAfterViewInit() {
    this.triggerStrategy = this.createTriggerStrategy();
    this.subscribeOnTriggers();
  }
  ngOnDestroy() {
    if (this.triggerStrategy) {
      this.triggerStrategy.destroy();
    }
    if (this.positionStrategy) {
      this.positionStrategy.dispose();
    }
    if (this.overlayRef) {
      this.overlayRef.dispose();
    }
    this.destroy$.next();
    this.destroy$.complete();
  }
  handleInput() {
    const currentValue = this.hostRef.nativeElement.value;
    this._onChange(currentValue);
    this.setHostInputValue(this.getDisplayValue(currentValue));
    this.show();
  }
  handleKeydown() {
    this.show();
  }
  handleBlur() {
    this._onTouched();
  }
  show() {
    if (this.shouldShow()) {
      this.attachToOverlay();
      this.setActiveItem();
    }
  }
  hide() {
    if (this.isOpen) {
      this.overlayRef.detach();
      this.cd.markForCheck();
    }
  }
  writeValue(value) {
    this.handleInputValueUpdate(value);
  }
  registerOnChange(fn) {
    this._onChange = fn;
  }
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  setDisabledState(disabled) {
    this.renderer.setProperty(this.hostRef.nativeElement, "disabled", disabled);
  }
  subscribeOnOptionClick() {
    this.autocomplete.options.changes.pipe(tap(() => this.setActiveItem()), startWith(this.autocomplete.options), switchMap((options) => {
      return merge(...options.map((option) => option.click));
    }), takeUntil(this.destroy$)).subscribe((clickedOption) => this.handleInputValueUpdate(clickedOption.value, true));
  }
  subscribeOnPositionChange() {
    this.positionStrategy.positionChange.pipe(takeUntil(this.destroy$)).subscribe((position) => {
      this.autocomplete.overlayPosition = position;
      this.cd.detectChanges();
    });
  }
  getActiveItem() {
    return this.keyManager.activeItem;
  }
  setupAutocomplete() {
    this.autocomplete.setHost(this.customOverlayHost || this.hostRef);
  }
  getDisplayValue(value) {
    const displayFn = this.autocomplete.handleDisplayFn;
    return displayFn ? displayFn(value) : value;
  }
  getContainer() {
    return this.overlayRef && this.isOpen && {
      location: {
        nativeElement: this.overlayRef.overlayElement
      }
    };
  }
  handleInputValueUpdate(value, focusInput = false) {
    this.setHostInputValue(value ?? "");
    this._onChange(value);
    if (focusInput) {
      this.hostRef.nativeElement.focus();
    }
    this.autocomplete.emitSelected(value);
    this.hide();
  }
  subscribeOnTriggers() {
    this.triggerStrategy.show$.pipe(filter(() => this.isClosed)).subscribe(() => this.show());
    this.triggerStrategy.hide$.pipe(filter(() => this.isOpen)).subscribe(() => this.hide());
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.FOCUS).host(this.hostRef.nativeElement).container(() => this.getContainer()).build();
  }
  createKeyManager() {
    this.keyManager = this.activeDescendantKeyManagerFactory.create(this.autocomplete.options);
  }
  setHostInputValue(value) {
    this.hostRef.nativeElement.value = this.getDisplayValue(value);
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this.customOverlayHost || this.hostRef).position(NbPosition.BOTTOM).offset(this.overlayOffset).adjustment(NbAdjustment.VERTICAL);
  }
  subscribeOnOverlayKeys() {
    this.overlayRef.keydownEvents().pipe(takeUntil(this.destroy$)).subscribe((event) => {
      if (event.keyCode === ESCAPE && this.isOpen) {
        event.preventDefault();
        this.hostRef.nativeElement.focus();
        this.hide();
      } else if (event.keyCode === ENTER) {
        event.preventDefault();
        const activeItem = this.getActiveItem();
        if (!activeItem) {
          return;
        }
        this.handleInputValueUpdate(activeItem.value, true);
      } else {
        this.keyManager.onKeydown(event);
      }
    });
  }
  setActiveItem() {
    const mode = this.autocomplete.activeFirst ? NbKeyManagerActiveItemMode.FIRST_ACTIVE : NbKeyManagerActiveItemMode.RESET_ACTIVE;
    this.keyManager.setActiveItem(mode);
    this.cd.detectChanges();
  }
  attachToOverlay() {
    if (!this.overlayRef) {
      this.setupAutocomplete();
      this.initOverlay();
    }
    this.overlayRef.attach(this.autocomplete.portal);
  }
  createOverlay() {
    const scrollStrategy = this.createScrollStrategy();
    this.overlayRef = this.overlay.create({
      positionStrategy: this.positionStrategy,
      scrollStrategy,
      panelClass: this.autocomplete.optionsPanelClass
    });
  }
  initOverlay() {
    this.positionStrategy = this.createPositionStrategy();
    this.createKeyManager();
    this.subscribeOnPositionChange();
    this.subscribeOnOptionClick();
    this.checkOverlayVisibility();
    this.createOverlay();
    this.subscribeOnOverlayKeys();
  }
  checkOverlayVisibility() {
    this.autocomplete.options.changes.pipe(takeUntil(this.destroy$)).subscribe(() => {
      if (!this.autocomplete.options.length) {
        this.hide();
      }
    });
  }
  createScrollStrategy() {
    return this.overlay.scrollStrategies[this.scrollStrategy]();
  }
  shouldShow() {
    return this.isClosed;
  }
};
_NbAutocompleteDirective.ɵfac = function NbAutocompleteDirective_Factory(t) {
  return new (t || _NbAutocompleteDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵɵdirectiveInject(NbPositionBuilderService), ɵɵdirectiveInject(NbActiveDescendantKeyManagerFactoryService), ɵɵdirectiveInject(Renderer2));
};
_NbAutocompleteDirective.ɵdir = ɵɵdefineDirective({
  type: _NbAutocompleteDirective,
  selectors: [["input", "nbAutocomplete", ""]],
  hostVars: 10,
  hostBindings: function NbAutocompleteDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("input", function NbAutocompleteDirective_input_HostBindingHandler() {
        return ctx.handleInput();
      })("keydown.arrowDown", function NbAutocompleteDirective_keydown_arrowDown_HostBindingHandler() {
        return ctx.handleKeydown();
      })("keydown.arrowUp", function NbAutocompleteDirective_keydown_arrowUp_HostBindingHandler() {
        return ctx.handleKeydown();
      })("blur", function NbAutocompleteDirective_blur_HostBindingHandler() {
        return ctx.handleBlur();
      });
    }
    if (rf & 2) {
      ɵɵattribute("role", ctx.role)("aria-autocomplete", ctx.ariaAutocomplete)("haspopup", ctx.hasPopup)("aria-expanded", ctx.ariaExpanded)("aria-owns", ctx.ariaOwns)("aria-activedescendant", ctx.ariaActiveDescendant);
      ɵɵclassProp("nb-autocomplete-position-top", ctx.top)("nb-autocomplete-position-bottom", ctx.bottom);
    }
  },
  inputs: {
    autocomplete: [InputFlags.None, "nbAutocomplete", "autocomplete"],
    overlayOffset: "overlayOffset",
    scrollStrategy: "scrollStrategy",
    customOverlayHost: "customOverlayHost"
  },
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbAutocompleteDirective),
    multi: true
  }])]
});
var NbAutocompleteDirective = _NbAutocompleteDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAutocompleteDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbAutocomplete]",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbAutocompleteDirective),
        multi: true
      }]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbOverlayService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbPositionBuilderService
  }, {
    type: NbActiveDescendantKeyManagerFactoryService
  }, {
    type: Renderer2
  }], {
    autocomplete: [{
      type: Input,
      args: ["nbAutocomplete"]
    }],
    overlayOffset: [{
      type: Input
    }],
    scrollStrategy: [{
      type: Input
    }],
    customOverlayHost: [{
      type: Input
    }],
    top: [{
      type: HostBinding,
      args: ["class.nb-autocomplete-position-top"]
    }],
    bottom: [{
      type: HostBinding,
      args: ["class.nb-autocomplete-position-bottom"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    ariaAutocomplete: [{
      type: HostBinding,
      args: ["attr.aria-autocomplete"]
    }],
    hasPopup: [{
      type: HostBinding,
      args: ["attr.haspopup"]
    }],
    ariaExpanded: [{
      type: HostBinding,
      args: ["attr.aria-expanded"]
    }],
    ariaOwns: [{
      type: HostBinding,
      args: ["attr.aria-owns"]
    }],
    ariaActiveDescendant: [{
      type: HostBinding,
      args: ["attr.aria-activedescendant"]
    }],
    handleInput: [{
      type: HostListener,
      args: ["input"]
    }],
    handleKeydown: [{
      type: HostListener,
      args: ["keydown.arrowDown"]
    }, {
      type: HostListener,
      args: ["keydown.arrowUp"]
    }],
    handleBlur: [{
      type: HostListener,
      args: ["blur"]
    }]
  });
})();
var NB_AUTOCOMPLETE_COMPONENTS = [NbAutocompleteComponent, NbAutocompleteDirective];
var _NbAutocompleteModule = class _NbAutocompleteModule {
};
_NbAutocompleteModule.ɵfac = function NbAutocompleteModule_Factory(t) {
  return new (t || _NbAutocompleteModule)();
};
_NbAutocompleteModule.ɵmod = ɵɵdefineNgModule({
  type: _NbAutocompleteModule,
  declarations: [NbAutocompleteComponent, NbAutocompleteDirective],
  imports: [CommonModule, FormsModule, NbOverlayModule, NbCardModule, NbOptionModule],
  exports: [NbAutocompleteComponent, NbAutocompleteDirective, NbOptionModule]
});
_NbAutocompleteModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, NbOverlayModule, NbCardModule, NbOptionModule, NbOptionModule]
});
var NbAutocompleteModule = _NbAutocompleteModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbAutocompleteModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, NbOverlayModule, NbCardModule, NbOptionModule],
      exports: [...NB_AUTOCOMPLETE_COMPONENTS, NbOptionModule],
      declarations: [...NB_AUTOCOMPLETE_COMPONENTS]
    }]
  }], null, null);
})();
var NbWindowState;
(function(NbWindowState2) {
  NbWindowState2["MINIMIZED"] = "minimized";
  NbWindowState2["MAXIMIZED"] = "maximized";
  NbWindowState2["FULL_SCREEN"] = "full-screen";
})(NbWindowState || (NbWindowState = {}));
var NB_WINDOW_DEFAULT_BUTTONS_CONFIG = {
  minimize: true,
  maximize: true,
  fullScreen: true,
  close: true
};
var NbWindowConfig = class {
  constructor(...configs) {
    this.title = "";
    this.titleTemplateContext = {};
    this.initialState = NbWindowState.FULL_SCREEN;
    this.hasBackdrop = true;
    this.closeOnBackdropClick = true;
    this.closeOnEsc = true;
    this.windowClass = "";
    this.context = {};
    this.viewContainerRef = null;
    this.buttons = {};
    Object.assign(this, ...configs);
    this.applyDefaultButtonConfig();
  }
  applyDefaultButtonConfig() {
    Object.assign(this, {
      buttons: __spreadValues(__spreadValues({}, NB_WINDOW_DEFAULT_BUTTONS_CONFIG), this.buttons)
    });
  }
};
var NB_WINDOW_CONTENT = new InjectionToken("Nebular Window Content");
var NB_WINDOW_CONFIG = new InjectionToken("Nebular Window Config");
var NB_WINDOW_CONTEXT = new InjectionToken("Nebular Window Context");
var NbWindowRef = class {
  /**
   * Current window state.
   */
  get state() {
    return this.stateValue;
  }
  set state(newState) {
    if (newState && this.stateValue !== newState) {
      this.prevStateValue = this.state;
      this.stateValue = newState;
      this.stateChange$.next({
        oldState: this.prevStateValue,
        newState
      });
    }
  }
  /**
   * Emits when window state change.
   */
  get stateChange() {
    return this.stateChange$.asObservable();
  }
  /**
   * Emits when window was closed.
   */
  get onClose() {
    return this.closed$.asObservable();
  }
  constructor(config) {
    this.config = config;
    this.stateChange$ = new ReplaySubject(1);
    this._closed = false;
    this.closed$ = new Subject();
    this.state = config.initialState;
  }
  /**
   * Minimize window.
   */
  minimize() {
    this.state = NbWindowState.MINIMIZED;
  }
  /**
   * Maximize window.
   */
  maximize() {
    this.state = NbWindowState.MAXIMIZED;
  }
  /**
   * Set window on top.
   */
  fullScreen() {
    this.state = NbWindowState.FULL_SCREEN;
  }
  toPreviousState() {
    this.state = this.prevStateValue;
  }
  /**
   * Closes window.
   * */
  close(res) {
    if (this._closed) {
      return;
    }
    this._closed = true;
    this.componentRef.destroy();
    this.componentInstance = null;
    this.stateChange$.complete();
    this.closed$.next(res);
    this.closed$.complete();
  }
};
var _NbWindowsContainerComponent = class _NbWindowsContainerComponent {
};
_NbWindowsContainerComponent.ɵfac = function NbWindowsContainerComponent_Factory(t) {
  return new (t || _NbWindowsContainerComponent)();
};
_NbWindowsContainerComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbWindowsContainerComponent,
  selectors: [["nb-windows-container"]],
  viewQuery: function NbWindowsContainerComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c50, 7, ViewContainerRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.viewContainerRef = _t.first);
    }
  },
  decls: 2,
  vars: 0,
  consts: [["viewContainerRef", ""]],
  template: function NbWindowsContainerComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, null, 0);
    }
  },
  styles: ["[_nghost-%COMP%]{display:flex;align-items:flex-end;overflow-x:auto}[_nghost-%COMP%]     nb-window:not(.full-screen){margin:0 2rem}"]
});
var NbWindowsContainerComponent = _NbWindowsContainerComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbWindowsContainerComponent, [{
    type: Component,
    args: [{
      selector: "nb-windows-container",
      template: `<ng-container #viewContainerRef></ng-container>`,
      styles: [":host{display:flex;align-items:flex-end;overflow-x:auto}:host ::ng-deep nb-window:not(.full-screen){margin:0 2rem}\n"]
    }]
  }], null, {
    viewContainerRef: [{
      type: ViewChild,
      args: ["viewContainerRef", {
        read: ViewContainerRef,
        static: true
      }]
    }]
  });
})();
var _NbWindowComponent = class _NbWindowComponent {
  get isFullScreen() {
    return this.windowRef.state === NbWindowState.FULL_SCREEN;
  }
  get maximized() {
    return this.windowRef.state === NbWindowState.MAXIMIZED;
  }
  get minimized() {
    return this.windowRef.state === NbWindowState.MINIMIZED;
  }
  get showMinimize() {
    return this.config.buttons.minimize;
  }
  get showMaximize() {
    return this.config.buttons.maximize;
  }
  get showFullScreen() {
    return this.config.buttons.fullScreen;
  }
  get showClose() {
    return this.config.buttons.close;
  }
  constructor(content, context, windowRef, config, focusTrapFactory, elementRef, renderer) {
    this.content = content;
    this.context = context;
    this.windowRef = windowRef;
    this.config = config;
    this.focusTrapFactory = focusTrapFactory;
    this.elementRef = elementRef;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.focusTrap = this.focusTrapFactory.create(this.elementRef.nativeElement);
    this.focusTrap.blurPreviouslyFocusedElement();
    this.focusTrap.focusInitialElement();
    if (this.config.windowClass) {
      this.renderer.addClass(this.elementRef.nativeElement, this.config.windowClass);
    }
  }
  ngAfterViewChecked() {
    if (!this.overlayContainer || this.overlayContainer.isAttached) {
      return;
    }
    if (this.content instanceof TemplateRef) {
      this.attachTemplate();
    } else {
      this.attachComponent();
    }
  }
  ngOnDestroy() {
    if (this.focusTrap) {
      this.focusTrap.restoreFocus();
    }
    this.close();
  }
  minimize() {
    if (this.windowRef.state === NbWindowState.MINIMIZED) {
      this.windowRef.toPreviousState();
    } else {
      this.windowRef.minimize();
    }
  }
  maximize() {
    this.windowRef.maximize();
  }
  fullScreen() {
    this.windowRef.fullScreen();
  }
  maximizeOrFullScreen() {
    if (this.windowRef.state === NbWindowState.MINIMIZED && this.showMaximize) {
      this.maximize();
    } else {
      this.fullScreen();
    }
  }
  close() {
    this.windowRef.close();
  }
  attachTemplate() {
    this.overlayContainer.attachTemplatePortal(new NbTemplatePortal(this.content, null, this.context));
  }
  attachComponent() {
    const portal = new NbComponentPortal(this.content, null, null, this.cfr);
    const ref = this.overlayContainer.attachComponentPortal(portal, this.context);
    this.windowRef.componentInstance = ref.instance;
    ref.changeDetectorRef.detectChanges();
  }
};
_NbWindowComponent.ɵfac = function NbWindowComponent_Factory(t) {
  return new (t || _NbWindowComponent)(ɵɵdirectiveInject(NB_WINDOW_CONTENT), ɵɵdirectiveInject(NB_WINDOW_CONTEXT), ɵɵdirectiveInject(NbWindowRef), ɵɵdirectiveInject(NbWindowConfig), ɵɵdirectiveInject(NbFocusTrapFactoryService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
};
_NbWindowComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbWindowComponent,
  selectors: [["nb-window"]],
  viewQuery: function NbWindowComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(NbOverlayContainerComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.overlayContainer = _t.first);
    }
  },
  hostVars: 6,
  hostBindings: function NbWindowComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("full-screen", ctx.isFullScreen)("maximized", ctx.maximized)("minimized", ctx.minimized);
    }
  },
  inputs: {
    cfr: "cfr"
  },
  decls: 11,
  vars: 7,
  consts: [["cdkFocusInitial", "", "tabindex", "-1", 4, "ngIf", "ngIfElse"], ["textTitleTemplate", ""], [1, "buttons"], [4, "ngIf"], ["cdkFocusInitial", "", "tabindex", "-1"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["cdkFocusInitial", "", "tabindex", "-1", 1, "title"], ["nbButton", "", "ghost", "", 3, "click"], ["icon", "minus-outline", "pack", "nebular-essentials"], ["nbButton", "", "ghost", "", 3, "click", 4, "ngIf"], ["icon", "collapse-outline", "pack", "nebular-essentials"], ["icon", "expand-outline", "pack", "nebular-essentials"], ["icon", "close-outline", "pack", "nebular-essentials"]],
  template: function NbWindowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "nb-card")(1, "nb-card-header");
      ɵɵtemplate(2, NbWindowComponent_div_2_Template, 2, 4, "div", 0)(3, NbWindowComponent_ng_template_3_Template, 2, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      ɵɵelementStart(5, "div", 2);
      ɵɵtemplate(6, NbWindowComponent_ng_container_6_Template, 3, 0, "ng-container", 3)(7, NbWindowComponent_ng_container_7_Template, 2, 1, "ng-container", 3)(8, NbWindowComponent_ng_container_8_Template, 2, 1, "ng-container", 3)(9, NbWindowComponent_ng_container_9_Template, 3, 0, "ng-container", 3);
      ɵɵelementEnd()();
      ɵɵtemplate(10, NbWindowComponent_nb_card_body_10_Template, 2, 0, "nb-card-body", 3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      const _r2 = ɵɵreference(4);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.config.titleTemplate)("ngIfElse", _r2);
      ɵɵadvance(4);
      ɵɵproperty("ngIf", ctx.showMinimize);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showMaximize);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showFullScreen);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showClose);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.maximized || ctx.isFullScreen);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NbOverlayContainerComponent, NbCardComponent, NbCardBodyComponent, NbCardHeaderComponent, NbIconComponent, NbButtonComponent],
  styles: ["[_nghost-%COMP%]{flex:1 0 auto;min-width:20rem}[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]{margin:0}[_nghost-%COMP%]   nb-card-header[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center;overflow:hidden}[_nghost-%COMP%]   .title[_ngcontent-%COMP%]{flex:1 0 auto;margin-right:3rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[_nghost-%COMP%]   .buttons[_ngcontent-%COMP%]{width:9.5rem;display:flex;justify-content:flex-end}[_nghost-%COMP%]   .buttons[_ngcontent-%COMP%]   [nbButton][_ngcontent-%COMP%]{flex:0 0 3rem}.full-screen[_nghost-%COMP%]{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%)}.maximized[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]{border-bottom-left-radius:0;border-bottom-right-radius:0}.minimized[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]{border-bottom-left-radius:0;border-bottom-right-radius:0;height:auto}.minimized[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]   nb-card-header[_ngcontent-%COMP%]{border-bottom:none}"]
});
var NbWindowComponent = _NbWindowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbWindowComponent, [{
    type: Component,
    args: [{
      selector: "nb-window",
      template: `
    <nb-card>
      <nb-card-header>
        <div *ngIf="config.titleTemplate; else textTitleTemplate" cdkFocusInitial tabindex="-1">
          <ng-container
            *ngTemplateOutlet="config.titleTemplate; context: { $implicit: config.titleTemplateContext }"
          ></ng-container>
        </div>

        <ng-template #textTitleTemplate>
          <div cdkFocusInitial class="title" tabindex="-1">{{ config.title }}</div>
        </ng-template>

        <div class="buttons">
          <ng-container *ngIf="showMinimize">
            <button nbButton ghost (click)="minimize()">
              <nb-icon icon="minus-outline" pack="nebular-essentials"></nb-icon>
            </button>
          </ng-container>

          <ng-container *ngIf="showMaximize">
            <button nbButton ghost *ngIf="isFullScreen" (click)="maximize()">
              <nb-icon icon="collapse-outline" pack="nebular-essentials"></nb-icon>
            </button>
          </ng-container>

          <ng-container *ngIf="showFullScreen">
            <button nbButton ghost *ngIf="minimized || maximized" (click)="maximizeOrFullScreen()">
              <nb-icon icon="expand-outline" pack="nebular-essentials"></nb-icon>
            </button>
          </ng-container>

          <ng-container *ngIf="showClose">
            <button nbButton ghost (click)="close()">
              <nb-icon icon="close-outline" pack="nebular-essentials"></nb-icon>
            </button>
          </ng-container>
        </div>
      </nb-card-header>
      <nb-card-body *ngIf="maximized || isFullScreen">
        <nb-overlay-container></nb-overlay-container>
      </nb-card-body>
    </nb-card>
  `,
      styles: [":host{flex:1 0 auto;min-width:20rem}:host nb-card{margin:0}:host nb-card-header{display:flex;justify-content:space-between;align-items:center;overflow:hidden}:host .title{flex:1 0 auto;margin-right:3rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:host .buttons{width:9.5rem;display:flex;justify-content:flex-end}:host .buttons [nbButton]{flex:0 0 3rem}:host(.full-screen){position:fixed;top:50%;left:50%;transform:translate(-50%,-50%)}:host(.maximized) nb-card{border-bottom-left-radius:0;border-bottom-right-radius:0}:host(.minimized) nb-card{border-bottom-left-radius:0;border-bottom-right-radius:0;height:auto}:host(.minimized) nb-card nb-card-header{border-bottom:none}\n"]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW_CONTENT]
    }]
  }, {
    type: Object,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW_CONTEXT]
    }]
  }, {
    type: NbWindowRef
  }, {
    type: NbWindowConfig
  }, {
    type: NbFocusTrapFactoryService
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    cfr: [{
      type: Input
    }],
    isFullScreen: [{
      type: HostBinding,
      args: ["class.full-screen"]
    }],
    maximized: [{
      type: HostBinding,
      args: ["class.maximized"]
    }],
    minimized: [{
      type: HostBinding,
      args: ["class.minimized"]
    }],
    overlayContainer: [{
      type: ViewChild,
      args: [NbOverlayContainerComponent]
    }]
  });
})();
var _NbWindowService = class _NbWindowService {
  constructor(componentFactoryResolver, overlayService, overlayPositionBuilder, blockScrollStrategy, defaultWindowsConfig, cfr, document) {
    this.componentFactoryResolver = componentFactoryResolver;
    this.overlayService = overlayService;
    this.overlayPositionBuilder = overlayPositionBuilder;
    this.blockScrollStrategy = blockScrollStrategy;
    this.defaultWindowsConfig = defaultWindowsConfig;
    this.cfr = cfr;
    this.openWindows = [];
    this.document = document;
  }
  /**
   * Opens new window.
   * @param windowContent
   * @param windowConfig
   * */
  open(windowContent, windowConfig = {}) {
    if (this.shouldCreateWindowsContainer()) {
      this.createWindowsContainer();
    }
    const config = new NbWindowConfig(this.defaultWindowsConfig, windowConfig);
    const windowRef = new NbWindowRef(config);
    windowRef.componentRef = this.appendWindow(windowContent, config, windowRef);
    this.openWindows.push(windowRef);
    this.subscribeToEvents(windowRef);
    return windowRef;
  }
  shouldCreateWindowsContainer() {
    if (this.windowsContainerViewRef) {
      const containerEl = this.windowsContainerViewRef.element.nativeElement;
      return !this.document.body.contains(containerEl);
    }
    return true;
  }
  createWindowsContainer() {
    if (this.overlayRef) {
      this.overlayRef.dispose();
    }
    this.overlayRef = this.overlayService.create({
      scrollStrategy: this.overlayService.scrollStrategies.noop(),
      positionStrategy: this.overlayPositionBuilder.global().bottom().right(),
      hasBackdrop: true
    });
    const windowsContainerPortal = new NbComponentPortal(NbWindowsContainerComponent, null, null, this.cfr);
    const overlayRef = this.overlayRef.attach(windowsContainerPortal);
    this.windowsContainerViewRef = overlayRef.instance.viewContainerRef;
  }
  appendWindow(content, config, windowRef) {
    const context = content instanceof TemplateRef ? {
      $implicit: config.context,
      windowRef
    } : config.context;
    const providers = [{
      provide: NB_WINDOW_CONTENT,
      useValue: content
    }, {
      provide: NB_WINDOW_CONTEXT,
      useValue: context
    }, {
      provide: NbWindowConfig,
      useValue: config
    }, {
      provide: NbWindowRef,
      useValue: windowRef
    }];
    const parentInjector = config.viewContainerRef ? config.viewContainerRef.injector : this.windowsContainerViewRef.injector;
    const injector = Injector.create({
      parent: parentInjector,
      providers
    });
    const windowFactory2 = this.componentFactoryResolver.resolveComponentFactory(NbWindowComponent);
    const ref = this.windowsContainerViewRef.createComponent(windowFactory2, this.windowsContainerViewRef.length, injector);
    ref.instance.cfr = this.cfr;
    ref.changeDetectorRef.detectChanges();
    return ref;
  }
  subscribeToEvents(windowRef) {
    if (windowRef.config.closeOnBackdropClick) {
      this.overlayRef.backdropClick().subscribe(() => windowRef.close());
    }
    if (windowRef.config.closeOnEsc) {
      this.overlayRef.keydownEvents().pipe(filter((event) => event.keyCode === 27)).subscribe(() => windowRef.close());
    }
    windowRef.stateChange.subscribe(() => this.checkAndUpdateOverlay());
    windowRef.onClose.subscribe(() => {
      this.openWindows.splice(this.openWindows.indexOf(windowRef), 1);
      this.checkAndUpdateOverlay();
    });
  }
  checkAndUpdateOverlay() {
    const fullScreenWindows = this.openWindows.filter((w) => w.state === NbWindowState.FULL_SCREEN);
    if (fullScreenWindows.length > 0) {
      this.blockScrollStrategy.enable();
    } else {
      this.blockScrollStrategy.disable();
    }
    if (fullScreenWindows.some((w) => w.config.hasBackdrop)) {
      this.overlayRef.backdropElement.removeAttribute("hidden");
    } else {
      this.overlayRef.backdropElement.setAttribute("hidden", "");
    }
  }
};
_NbWindowService.ɵfac = function NbWindowService_Factory(t) {
  return new (t || _NbWindowService)(ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(NbOverlayService), ɵɵinject(NbOverlayPositionBuilder), ɵɵinject(NbBlockScrollStrategyAdapter), ɵɵinject(NB_WINDOW_CONFIG), ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(NB_DOCUMENT));
};
_NbWindowService.ɵprov = ɵɵdefineInjectable({
  token: _NbWindowService,
  factory: _NbWindowService.ɵfac
});
var NbWindowService = _NbWindowService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbWindowService, [{
    type: Injectable
  }], () => [{
    type: ComponentFactoryResolver$1
  }, {
    type: NbOverlayService
  }, {
    type: NbOverlayPositionBuilder
  }, {
    type: NbBlockScrollStrategyAdapter
  }, {
    type: NbWindowConfig,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW_CONFIG]
    }]
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], null);
})();
var _NbWindowModule = class _NbWindowModule {
  static forRoot(defaultConfig) {
    return {
      ngModule: _NbWindowModule,
      providers: [NbWindowService, {
        provide: NB_WINDOW_CONFIG,
        useValue: defaultConfig
      }]
    };
  }
  static forChild(defaultConfig) {
    return {
      ngModule: _NbWindowModule,
      providers: [NbWindowService, {
        provide: NB_WINDOW_CONFIG,
        useValue: defaultConfig
      }]
    };
  }
};
_NbWindowModule.ɵfac = function NbWindowModule_Factory(t) {
  return new (t || _NbWindowModule)();
};
_NbWindowModule.ɵmod = ɵɵdefineNgModule({
  type: _NbWindowModule,
  declarations: [NbWindowsContainerComponent, NbWindowComponent],
  imports: [CommonModule, NbOverlayModule, NbCardModule, NbIconModule, NbButtonModule]
});
_NbWindowModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, NbOverlayModule, NbCardModule, NbIconModule, NbButtonModule]
});
var NbWindowModule = _NbWindowModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbWindowModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbOverlayModule, NbCardModule, NbIconModule, NbButtonModule],
      declarations: [NbWindowsContainerComponent, NbWindowComponent]
    }]
  }], null, null);
})();
var _NbTimePickerDirective = class _NbTimePickerDirective {
  /**
   * Provides timepicker component.
   * */
  get timepicker() {
    return this._timePickerComponent;
  }
  set timepicker(timePicker) {
    this._timePickerComponent = timePicker;
    this.pickerInputsChangedSubscription?.unsubscribe();
    this.pickerInputsChangedSubscription = this._timePickerComponent.timepickerFormatChange$.pipe(map(() => this._timePickerComponent.computedTimeFormat), startWith(this._timePickerComponent.computedTimeFormat), distinctUntilChanged(), pairwise(), takeUntil(this.destroy$)).subscribe(([prevFormat, nextFormat]) => {
      if (this.inputValue) {
        const date = this.dateService.parse(this.inputValue, prevFormat);
        this.writeValue(date);
      }
    });
  }
  /**
   * Returns html input element.
   * @docs-private
   * */
  get input() {
    return this.hostRef.nativeElement;
  }
  /**
   * Determines is timepicker overlay opened.
   * @docs-private
   * */
  get isOpen() {
    return this.overlayRef && this.overlayRef.hasAttached();
  }
  /**
   * Determines is timepicker overlay closed.
   * @docs-private
   * */
  get isClosed() {
    return !this.isOpen;
  }
  constructor(document, positionBuilder, hostRef, triggerStrategyBuilder, overlay, cd, calendarTimeModelService, dateService, renderer, placeholder) {
    this.document = document;
    this.positionBuilder = positionBuilder;
    this.hostRef = hostRef;
    this.triggerStrategyBuilder = triggerStrategyBuilder;
    this.overlay = overlay;
    this.cd = cd;
    this.calendarTimeModelService = calendarTimeModelService;
    this.dateService = dateService;
    this.renderer = renderer;
    this.placeholder = placeholder;
    this.overlayOffset = 8;
    this.destroy$ = new Subject();
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
  }
  /**
   * Returns host input value.
   * @docs-private
   * */
  get inputValue() {
    return this.input.value;
  }
  set inputValue(value) {
    this.input.value = value;
  }
  ngAfterViewInit() {
    this.subscribeOnInputChange();
    if (!this.placeholder) {
      this.renderer.setProperty(this.input, "placeholder", this.timepicker.computedTimeFormat);
    }
    this.triggerStrategy = this.createTriggerStrategy();
    this.subscribeOnTriggers();
    this.subscribeToBlur();
  }
  show() {
    if (this.isClosed) {
      this.attachToOverlay();
    }
  }
  hide() {
    if (this.isOpen) {
      this.overlayRef.detach();
      this.cd.markForCheck();
    }
  }
  /**
   * Attaches picker to the timepicker portal.
   * @docs-private
   * */
  attachToOverlay() {
    if (!this.overlayRef) {
      this.setupTimepicker();
      this.initOverlay();
    }
    this.overlayRef.attach(this.timepicker.portal);
  }
  setupTimepicker() {
    if (this.dateService.getId() === "native" && isDevMode()) {
      console.warn("Date.parse does not support parsing time with custom format. See details here https://akveo.github.io/nebular/docs/components/datepicker/overview#native-parse-issue");
    }
    this.timepicker.setHost(this.hostRef);
    if (this.inputValue) {
      const val = this.dateService.getId() === "native" ? this.parseNativeDateString(this.inputValue) : this.inputValue;
      this.timepicker.date = this.dateService.parse(val, this.timepicker.computedTimeFormat);
    } else {
      this.timepicker.date = this.calendarTimeModelService.getResetTime();
    }
  }
  initOverlay() {
    this.positionStrategy = this.createPositionStrategy();
    this.subscribeOnApplyClick();
    this.createOverlay();
  }
  subscribeOnApplyClick() {
    this.timepicker.onSelectTime.pipe(takeUntil(this.destroy$)).subscribe((value) => {
      const time = this.dateService.format(value.time, this.timepicker.computedTimeFormat).toUpperCase();
      this.inputValue = time;
      this.timepicker.date = value.time;
      this.onChange(value.time);
      if (value.save) {
        this.lastInputValue = time;
        this.hide();
      }
    });
  }
  createOverlay() {
    const scrollStrategy = this.createScrollStrategy();
    this.overlayRef = this.overlay.create({
      positionStrategy: this.positionStrategy,
      scrollStrategy
    });
  }
  subscribeOnTriggers() {
    this.triggerStrategy.show$.pipe(filter(() => this.isClosed)).subscribe(() => this.show());
    this.triggerStrategy.hide$.pipe(filter(() => this.isOpen)).subscribe(() => {
      this.inputValue = this.lastInputValue || "";
      this.hide();
    });
  }
  createTriggerStrategy() {
    return this.triggerStrategyBuilder.trigger(NbTrigger.FOCUS).host(this.hostRef.nativeElement).container(() => this.getContainer()).build();
  }
  createPositionStrategy() {
    return this.positionBuilder.connectedTo(this.hostRef).position(NbPosition.BOTTOM).offset(this.overlayOffset).adjustment(NbAdjustment.COUNTERCLOCKWISE);
  }
  getContainer() {
    return this.overlayRef && this.isOpen && {
      location: {
        nativeElement: this.overlayRef.overlayElement
      }
    };
  }
  createScrollStrategy() {
    return this.overlay.scrollStrategies.block();
  }
  subscribeOnInputChange() {
    fromEvent(this.input, "input").pipe(map(() => this.inputValue), takeUntil(this.destroy$)).subscribe((value) => this.handleInputChange(value));
  }
  subscribeToBlur() {
    merge(this.timepicker.blur, fromEvent(this.input, "blur").pipe(filter(() => !this.isOpen && this.document.activeElement !== this.input))).pipe(takeUntil(this.destroy$)).subscribe(() => this.onTouched());
  }
  /**
   * Parses input value and write if it isn't null.
   * @docs-private
   * */
  handleInputChange(value) {
    if (this.dateService.getId() === "native") {
      value = this.parseNativeDateString(value);
    }
    const isValidDate = this.dateService.isValidDateString(value, this.timepicker.computedTimeFormat);
    if (isValidDate) {
      this.lastInputValue = value;
      const date = this.dateService.parse(value, this.timepicker.computedTimeFormat);
      this.onChange(date);
      this.timepicker.date = date;
    }
  }
  updateValue(value) {
    if (value) {
      this.timepicker.date = value;
      const timeString = this.dateService.format(value, this.timepicker.computedTimeFormat).toUpperCase();
      this.inputValue = timeString;
      this.lastInputValue = timeString;
    }
  }
  writeValue(value) {
    this.updateValue(value);
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.input.disabled = isDisabled;
  }
  parseNativeDateString(value) {
    const date = this.dateService.today();
    const year = this.dateService.getYear(date);
    const month = this.calendarTimeModelService.paddToTwoSymbols(this.dateService.getMonth(date));
    const day = this.calendarTimeModelService.paddToTwoSymbols(this.dateService.getDate(date));
    return `${year}-${month}-${day} ${value}`;
  }
};
_NbTimePickerDirective.ɵfac = function NbTimePickerDirective_Factory(t) {
  return new (t || _NbTimePickerDirective)(ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbPositionBuilderService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵɵdirectiveInject(NbOverlayService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbCalendarTimeModelService), ɵɵdirectiveInject(NbDateService), ɵɵdirectiveInject(Renderer2), ɵɵinjectAttribute("placeholder"));
};
_NbTimePickerDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTimePickerDirective,
  selectors: [["input", "nbTimepicker", ""]],
  inputs: {
    timepicker: [InputFlags.None, "nbTimepicker", "timepicker"],
    overlayOffset: "overlayOffset"
  },
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbTimePickerDirective),
    multi: true
  }])]
});
var NbTimePickerDirective = _NbTimePickerDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTimePickerDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbTimepicker]",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbTimePickerDirective),
        multi: true
      }]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPositionBuilderService
  }, {
    type: ElementRef
  }, {
    type: NbTriggerStrategyBuilderService
  }, {
    type: NbOverlayService
  }, {
    type: ChangeDetectorRef
  }, {
    type: NbCalendarTimeModelService
  }, {
    type: NbDateService
  }, {
    type: Renderer2
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["placeholder"]
    }]
  }], {
    timepicker: [{
      type: Input,
      args: ["nbTimepicker"]
    }],
    overlayOffset: [{
      type: Input
    }]
  });
})();
var _NbTimepickerModule = class _NbTimepickerModule {
  static forRoot(config = {}) {
    return {
      ngModule: _NbTimepickerModule,
      providers: [{
        provide: NB_TIME_PICKER_CONFIG,
        useValue: config
      }]
    };
  }
  static forChild(config = {}) {
    return {
      ngModule: _NbTimepickerModule,
      providers: [{
        provide: NB_TIME_PICKER_CONFIG,
        useValue: config
      }]
    };
  }
};
_NbTimepickerModule.ɵfac = function NbTimepickerModule_Factory(t) {
  return new (t || _NbTimepickerModule)();
};
_NbTimepickerModule.ɵmod = ɵɵdefineNgModule({
  type: _NbTimepickerModule,
  declarations: [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective],
  imports: [CommonModule, NbOverlayModule, NbListModule, NbCardModule, NbCalendarKitModule],
  exports: [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective]
});
_NbTimepickerModule.ɵinj = ɵɵdefineInjector({
  providers: [NbCalendarTimeModelService],
  imports: [CommonModule, NbOverlayModule, NbListModule, NbCardModule, NbCalendarKitModule]
});
var NbTimepickerModule = _NbTimepickerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTimepickerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbOverlayModule, NbListModule, NbCardModule, NbCalendarKitModule],
      providers: [NbCalendarTimeModelService],
      exports: [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective],
      declarations: [NbTimePickerComponent, NbTimePickerCellComponent, NbTimePickerDirective]
    }]
  }], null, null);
})();
var _NbDateAdapterService = class _NbDateAdapterService extends NbDatepickerAdapter {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.picker = NbDatepickerComponent;
  }
  parse(date, format) {
    return this.dateService.parse(date, format);
  }
  format(date, format) {
    return this.dateService.format(date, format);
  }
  isValid(date, format) {
    return this.dateService.isValidDateString(date, format);
  }
};
_NbDateAdapterService.ɵfac = function NbDateAdapterService_Factory(t) {
  return new (t || _NbDateAdapterService)(ɵɵinject(NbDateService));
};
_NbDateAdapterService.ɵprov = ɵɵdefineInjectable({
  token: _NbDateAdapterService,
  factory: _NbDateAdapterService.ɵfac
});
var NbDateAdapterService = _NbDateAdapterService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDateAdapterService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var _NbRangeAdapterService = class _NbRangeAdapterService extends NbDatepickerAdapter {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.picker = NbRangepickerComponent;
  }
  parse(range2, format) {
    const [start, end] = range2.split("-").map((subDate) => subDate.trim());
    return {
      start: this.dateService.parse(start, format),
      end: this.dateService.parse(end, format)
    };
  }
  format(range2, format) {
    if (!range2) {
      return "";
    }
    const start = this.dateService.format(range2.start, format);
    const isStartValid = this.dateService.isValidDateString(start, format);
    if (!isStartValid) {
      return "";
    }
    const end = this.dateService.format(range2.end, format);
    const isEndValid = this.dateService.isValidDateString(end, format);
    if (isEndValid) {
      return `${start} - ${end}`;
    } else {
      return start;
    }
  }
  isValid(range2, format) {
    const [start, end] = range2.split("-").map((subDate) => subDate.trim());
    return this.dateService.isValidDateString(start, format) && this.dateService.isValidDateString(end, format);
  }
};
_NbRangeAdapterService.ɵfac = function NbRangeAdapterService_Factory(t) {
  return new (t || _NbRangeAdapterService)(ɵɵinject(NbDateService));
};
_NbRangeAdapterService.ɵprov = ɵɵdefineInjectable({
  token: _NbRangeAdapterService,
  factory: _NbRangeAdapterService.ɵfac
});
var NbRangeAdapterService = _NbRangeAdapterService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRangeAdapterService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var _NbDateTimeAdapterService = class _NbDateTimeAdapterService extends NbDatepickerAdapter {
  constructor(dateService) {
    super();
    this.dateService = dateService;
    this.picker = NbDateTimePickerComponent;
  }
  parse(date, format) {
    return this.dateService.parse(date, format);
  }
  format(date, format) {
    return this.dateService.format(date, format);
  }
  isValid(date, format) {
    return this.dateService.isValidDateString(date, format);
  }
};
_NbDateTimeAdapterService.ɵfac = function NbDateTimeAdapterService_Factory(t) {
  return new (t || _NbDateTimeAdapterService)(ɵɵinject(NbDateService));
};
_NbDateTimeAdapterService.ɵprov = ɵɵdefineInjectable({
  token: _NbDateTimeAdapterService,
  factory: _NbDateTimeAdapterService.ɵfac
});
var NbDateTimeAdapterService = _NbDateTimeAdapterService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDateTimeAdapterService, [{
    type: Injectable
  }], () => [{
    type: NbDateService
  }], null);
})();
var _NbDatepickerModule = class _NbDatepickerModule {
  static forRoot() {
    return {
      ngModule: _NbDatepickerModule,
      providers: [DatePipe, {
        provide: NB_DATE_ADAPTER,
        multi: true,
        useClass: NbDateAdapterService
      }, {
        provide: NB_DATE_ADAPTER,
        multi: true,
        useClass: NbRangeAdapterService
      }, {
        provide: NB_DATE_ADAPTER,
        multi: true,
        useClass: NbDateTimeAdapterService
      }]
    };
  }
};
_NbDatepickerModule.ɵfac = function NbDatepickerModule_Factory(t) {
  return new (t || _NbDatepickerModule)();
};
_NbDatepickerModule.ɵmod = ɵɵdefineNgModule({
  type: _NbDatepickerModule,
  declarations: [NbDatepickerDirective, NbDatepickerContainerComponent, NbCalendarWithTimeComponent, NbDateTimePickerComponent, NbDatepickerComponent, NbRangepickerComponent, NbBasePickerComponent],
  imports: [NbOverlayModule, NbCalendarModule, NbCalendarRangeModule, NbCardModule, NbBaseCalendarModule, NbTimepickerModule, NbCalendarKitModule],
  exports: [NbDatepickerDirective, NbDatepickerComponent, NbRangepickerComponent, NbDateTimePickerComponent, NbCalendarWithTimeComponent]
});
_NbDatepickerModule.ɵinj = ɵɵdefineInjector({
  imports: [NbOverlayModule, NbCalendarModule, NbCalendarRangeModule, NbCardModule, NbBaseCalendarModule, NbTimepickerModule, NbCalendarKitModule]
});
var NbDatepickerModule = _NbDatepickerModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbDatepickerModule, [{
    type: NgModule,
    args: [{
      imports: [NbOverlayModule, NbCalendarModule, NbCalendarRangeModule, NbCardModule, NbBaseCalendarModule, NbTimepickerModule, NbCalendarKitModule],
      exports: [NbDatepickerDirective, NbDatepickerComponent, NbRangepickerComponent, NbDateTimePickerComponent, NbCalendarWithTimeComponent],
      declarations: [NbDatepickerDirective, NbDatepickerContainerComponent, NbCalendarWithTimeComponent, NbDateTimePickerComponent, NbDatepickerComponent, NbRangepickerComponent, NbBasePickerComponent]
    }]
  }], null, null);
})();
var _NbRadioComponent = class _NbRadioComponent {
  get name() {
    return this._name;
  }
  set name(value) {
    if (this._name !== value) {
      this._name = value;
    }
  }
  get checked() {
    return this._checked;
  }
  set checked(value) {
    const boolValue = convertToBoolProperty(value);
    if (this._checked !== boolValue) {
      this._checked = boolValue;
    }
  }
  get value() {
    return this._value;
  }
  set value(value) {
    if (this._value !== value) {
      this._value = value;
    }
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(disabled) {
    const boolValue = convertToBoolProperty(disabled);
    if (this._disabled !== boolValue) {
      this._disabled = boolValue;
    }
  }
  constructor(cd, renderer, statusService) {
    this.cd = cd;
    this.renderer = renderer;
    this.statusService = statusService;
    this._checked = false;
    this._disabled = false;
    this.status = "basic";
    this.valueChange = new EventEmitter();
    this.blur = new EventEmitter();
  }
  get isPrimary() {
    return this.status === "primary";
  }
  get isSuccess() {
    return this.status === "success";
  }
  get isWarning() {
    return this.status === "warning";
  }
  get isDanger() {
    return this.status === "danger";
  }
  get isInfo() {
    return this.status === "info";
  }
  get isBasic() {
    return this.status === "basic";
  }
  get isControl() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  onChange(event) {
    event.stopPropagation();
    this.checked = true;
    this.valueChange.emit(this.value);
  }
  onClick(event) {
    event.stopPropagation();
  }
  /*
   * @docs-private
   * We use this method when setting radio inputs from radio group component.
   * Otherwise Angular won't detect changes in radio template as cached last rendered
   * value didn't updated.
   **/
  _markForCheck() {
    this.cd.markForCheck();
  }
  /*
   * @docs-private
   * Use this method when setting radio name from radio group component.
   * In case option 'name' isn't set on nb-radio component we need to set name
   * right away, so it won't overlap with options without names from other radio
   * groups. Otherwise they all would have same name and will be considered as
   * options from one group so only the last option will stay selected.
   **/
  _setName(name) {
    this.name = name;
    if (this.input) {
      this.renderer.setProperty(this.input.nativeElement, "name", name);
    }
  }
};
_NbRadioComponent.ɵfac = function NbRadioComponent_Factory(t) {
  return new (t || _NbRadioComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NbStatusService));
};
_NbRadioComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbRadioComponent,
  selectors: [["nb-radio"]],
  viewQuery: function NbRadioComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c51, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
    }
  },
  hostVars: 16,
  hostBindings: function NbRadioComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("status-primary", ctx.isPrimary)("status-success", ctx.isSuccess)("status-warning", ctx.isWarning)("status-danger", ctx.isDanger)("status-info", ctx.isInfo)("status-basic", ctx.isBasic)("status-control", ctx.isControl);
    }
  },
  inputs: {
    name: "name",
    checked: "checked",
    value: "value",
    disabled: "disabled",
    status: "status"
  },
  outputs: {
    valueChange: "valueChange",
    blur: "blur"
  },
  ngContentSelectors: _c02,
  decls: 7,
  vars: 4,
  consts: [["type", "radio", 1, "native-input", "visually-hidden", 3, "name", "value", "checked", "disabled", "change", "click"], ["input", ""], [1, "outer-circle"], [1, "inner-circle"], [1, "text"]],
  template: function NbRadioComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "label")(1, "input", 0, 1);
      ɵɵlistener("change", function NbRadioComponent_Template_input_change_1_listener($event) {
        return ctx.onChange($event);
      })("click", function NbRadioComponent_Template_input_click_1_listener($event) {
        return ctx.onClick($event);
      });
      ɵɵelementEnd();
      ɵɵelement(3, "span", 2)(4, "span", 3);
      ɵɵelementStart(5, "span", 4);
      ɵɵprojection(6);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("name", ctx.name)("value", ctx.value)("checked", ctx.checked)("disabled", ctx.disabled);
    }
  },
  styles: ["\n\n\n\n\n\n\n\n\n\n[_nghost-%COMP%]{display:block;position:relative}[_nghost-%COMP%]   label[_ngcontent-%COMP%]{display:inline-flex;margin:0;min-height:inherit;padding:.375rem 0;align-items:center}[dir=ltr]   [_nghost-%COMP%]   label[_ngcontent-%COMP%]{padding-right:1.5rem}[dir=rtl]   [_nghost-%COMP%]   label[_ngcontent-%COMP%]{padding-left:1.5rem}[_nghost-%COMP%]   .outer-circle[_ngcontent-%COMP%], [_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{border-radius:50%;position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr]   [_nghost-%COMP%]   .outer-circle[_ngcontent-%COMP%], [dir=ltr]   [_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{left:0}[dir=rtl]   [_nghost-%COMP%]   .outer-circle[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{right:0}[_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{transform:translateY(-50%) scale(.6)}[dir=ltr]   [_nghost-%COMP%]   .text[_ngcontent-%COMP%]{padding-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .text[_ngcontent-%COMP%]{padding-right:.5rem}"],
  changeDetection: 0
});
var NbRadioComponent = _NbRadioComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRadioComponent, [{
    type: Component,
    args: [{
      selector: "nb-radio",
      template: `
    <label>
      <input
        #input
        type="radio"
        class="native-input visually-hidden"
        [name]="name"
        [value]="value"
        [checked]="checked"
        [disabled]="disabled"
        (change)="onChange($event)"
        (click)="onClick($event)">
      <span class="outer-circle"></span>
      <span class="inner-circle"></span>
      <span class="text">
        <ng-content></ng-content>
      </span>
    </label>
  `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/*\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n *//**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:block;position:relative}:host label{display:inline-flex;margin:0;min-height:inherit;padding:.375rem 0;align-items:center}[dir=ltr] :host label{padding-right:1.5rem}[dir=rtl] :host label{padding-left:1.5rem}:host .outer-circle,:host .inner-circle{border-radius:50%;position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr] :host .outer-circle,[dir=ltr] :host .inner-circle{left:0}[dir=rtl] :host .outer-circle,[dir=rtl] :host .inner-circle{right:0}:host .inner-circle{transform:translateY(-50%) scale(.6)}[dir=ltr] :host .text{padding-left:.5rem}[dir=rtl] :host .text{padding-right:.5rem}\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: NbStatusService
  }], {
    name: [{
      type: Input
    }],
    checked: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    blur: [{
      type: Output
    }],
    input: [{
      type: ViewChild,
      args: ["input", {
        read: ElementRef
      }]
    }],
    isPrimary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    isSuccess: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    isWarning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    isDanger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    isInfo: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    isBasic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    isControl: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var _NbRadioGroupComponent = class _NbRadioGroupComponent {
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.updateValues();
  }
  get name() {
    return this._name;
  }
  set name(name) {
    this._name = name;
    this.updateNames();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(disabled) {
    this._disabled = convertToBoolProperty(disabled);
    this.updateDisabled();
  }
  /**
   * Radio buttons status.
   * Possible values are `primary` (default), `success`, `warning`, `danger`, `info`.
   */
  get status() {
    return this._status;
  }
  set status(value) {
    if (this._status !== value) {
      this._status = value;
      this.updateStatus();
    }
  }
  constructor(hostElement, platformId, document) {
    this.hostElement = hostElement;
    this.platformId = platformId;
    this.document = document;
    this.destroy$ = new Subject();
    this.onChange = (value) => {
    };
    this.onTouched = () => {
    };
    this._status = "basic";
    this.valueChange = new EventEmitter();
  }
  ngAfterContentInit() {
    this.updateNames();
    this.radios.changes.pipe(
      startWith(this.radios),
      // 'changes' emit during change detection run and we can't update
      // option properties right of since they already was initialized.
      // Instead we schedule microtask to update radios after change detection
      // run is finished and trigger one more change detection run.
      switchMap((radios) => from(Promise.resolve(radios))),
      takeUntil(this.destroy$)
    ).subscribe(() => this.updateAndSubscribeToRadios());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  writeValue(value) {
    this.value = value;
  }
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
  updateAndSubscribeToRadios() {
    this.updateValueFromCheckedOption();
    this.updateNames();
    this.updateValues();
    this.updateDisabled();
    this.updateStatus();
    this.subscribeOnRadiosValueChange();
    this.subscribeOnRadiosBlur();
  }
  updateNames() {
    if (this.radios) {
      this.radios.forEach((radio) => radio._setName(this.name));
    }
  }
  updateValues() {
    this.updateAndMarkForCheckRadios((radio) => radio.checked = radio.value === this.value);
  }
  updateDisabled() {
    if (typeof this.disabled !== "undefined") {
      this.updateAndMarkForCheckRadios((radio) => radio.disabled = this.disabled);
    }
  }
  subscribeOnRadiosValueChange() {
    if (!this.radios || !this.radios.length) {
      return;
    }
    merge(...this.radios.map((radio) => radio.valueChange)).pipe(takeUntil(merge(this.radios.changes, this.destroy$))).subscribe((value) => {
      this.writeValue(value);
      this.propagateValue(value);
    });
  }
  propagateValue(value) {
    this.valueChange.emit(value);
    this.onChange(value);
  }
  subscribeOnRadiosBlur() {
    const hasNoRadios = !this.radios || !this.radios.length;
    if (!isPlatformBrowser(this.platformId) || hasNoRadios) {
      return;
    }
    const hostElement = this.hostElement.nativeElement;
    fromEvent(hostElement, "focusin").pipe(filter((event) => hostElement.contains(event.target)), switchMap(() => merge(fromEvent(this.document, "focusin"), fromEvent(this.document, "click"))), filter((event) => !hostElement.contains(event.target)), takeUntil(merge(this.radios.changes, this.destroy$))).subscribe(() => this.onTouched());
  }
  updateStatus() {
    this.updateAndMarkForCheckRadios((radio) => radio.status = this.status);
  }
  updateAndMarkForCheckRadios(updateFn) {
    if (this.radios) {
      this.radios.forEach((radio) => {
        updateFn(radio);
        radio._markForCheck();
      });
    }
  }
  updateValueFromCheckedOption() {
    const checkedRadio = this.radios.find((radio) => radio.checked);
    const isValueMissing = this.value === void 0 || this.value === null;
    if (checkedRadio && isValueMissing && checkedRadio.value !== this.value) {
      this.value = checkedRadio.value;
    }
  }
};
_NbRadioGroupComponent.ɵfac = function NbRadioGroupComponent_Factory(t) {
  return new (t || _NbRadioGroupComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(NB_DOCUMENT));
};
_NbRadioGroupComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbRadioGroupComponent,
  selectors: [["nb-radio-group"]],
  contentQueries: function NbRadioGroupComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbRadioComponent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.radios = _t);
    }
  },
  inputs: {
    value: "value",
    name: "name",
    disabled: "disabled",
    status: "status"
  },
  outputs: {
    valueChange: "valueChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbRadioGroupComponent),
    multi: true
  }])],
  ngContentSelectors: _c53,
  decls: 1,
  vars: 0,
  template: function NbRadioGroupComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c52);
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbRadioGroupComponent = _NbRadioGroupComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRadioGroupComponent, [{
    type: Component,
    args: [{
      selector: "nb-radio-group",
      template: `
    <ng-content select="nb-radio"></ng-content>`,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbRadioGroupComponent),
        multi: true
      }],
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }], {
    value: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    radios: [{
      type: ContentChildren,
      args: [NbRadioComponent, {
        descendants: true
      }]
    }],
    valueChange: [{
      type: Output
    }]
  });
})();
var _NbRadioModule = class _NbRadioModule {
};
_NbRadioModule.ɵfac = function NbRadioModule_Factory(t) {
  return new (t || _NbRadioModule)();
};
_NbRadioModule.ɵmod = ɵɵdefineNgModule({
  type: _NbRadioModule,
  declarations: [NbRadioComponent, NbRadioGroupComponent],
  exports: [NbRadioComponent, NbRadioGroupComponent]
});
_NbRadioModule.ɵinj = ɵɵdefineInjector({});
var NbRadioModule = _NbRadioModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbRadioModule, [{
    type: NgModule,
    args: [{
      imports: [],
      exports: [NbRadioComponent, NbRadioGroupComponent],
      declarations: [NbRadioComponent, NbRadioGroupComponent]
    }]
  }], null, null);
})();
var tagUniqueId = 0;
var _NbTagComponent = class _NbTagComponent {
  get destroy$() {
    return this._destroy$.asObservable();
  }
  get selected() {
    return this._selected;
  }
  set selected(value) {
    if (this.selected !== convertToBoolProperty(value)) {
      this._selected = !this.selected;
      this.selectedChange.emit({
        tag: this,
        selected: this.selected
      });
    }
  }
  /**
   * Controls whether the user can remove a tag or not.
   */
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = convertToBoolProperty(value);
  }
  get filled() {
    return this.appearance === "filled";
  }
  set filled(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "filled";
    }
  }
  get outline() {
    return this.appearance === "outline";
  }
  set outline(value) {
    if (convertToBoolProperty(value)) {
      this.appearance = "outline";
    }
  }
  get basic() {
    return this.status === "basic";
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get info() {
    return this.status === "info";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get control() {
    return this.status === "control";
  }
  get tiny() {
    return this.size === "tiny";
  }
  get small() {
    return this.size === "small";
  }
  get medium() {
    return this.size === "medium";
  }
  get large() {
    return this.size === "large";
  }
  get giant() {
    return this.size === "giant";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  _remove() {
    if (this.removable) {
      this.remove.emit(this);
    }
  }
  constructor(_hostElement, cd, renderer, zone, statusService) {
    this._hostElement = _hostElement;
    this.cd = cd;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this._destroy$ = new Subject();
    this._selected = false;
    this._removable = false;
    this.appearance = "filled";
    this.status = "basic";
    this.size = "medium";
    this.role = "option";
    this.remove = new EventEmitter();
    this.selectedChange = new EventEmitter();
    this._isActive = false;
    this._id = `nb-tag-${tagUniqueId++}`;
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this._hostElement.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this._destroy$.next(this);
  }
  _toggleSelection() {
    this.selected = !this.selected;
    this.cd.markForCheck();
  }
  setActiveStyles() {
    if (!this._isActive) {
      this._isActive = true;
      this.cd.markForCheck();
    }
  }
  setInactiveStyles() {
    if (this._isActive) {
      this._isActive = false;
      this.cd.markForCheck();
    }
  }
};
_NbTagComponent.ɵfac = function NbTagComponent_Factory(t) {
  return new (t || _NbTagComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
};
_NbTagComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTagComponent,
  selectors: [["nb-tag"]],
  hostVars: 37,
  hostBindings: function NbTagComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown.delete", function NbTagComponent_keydown_delete_HostBindingHandler() {
        return ctx._remove();
      })("keydown.backspace", function NbTagComponent_keydown_backspace_HostBindingHandler() {
        return ctx._remove();
      });
    }
    if (rf & 2) {
      ɵɵattribute("aria-selected", ctx.selected)("role", ctx.role)("id", ctx._id);
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("selected", ctx.selected)("active", ctx._isActive)("appearance-filled", ctx.filled)("appearance-outline", ctx.outline)("status-basic", ctx.basic)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-control", ctx.control)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant);
    }
  },
  inputs: {
    text: "text",
    selected: "selected",
    removable: "removable",
    appearance: "appearance",
    status: "status",
    size: "size",
    role: "role"
  },
  outputs: {
    remove: "remove",
    selectedChange: "selectedChange"
  },
  exportAs: ["nbTag"],
  decls: 2,
  vars: 2,
  consts: [["icon", "close-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "class", "click", 4, "ngIf"], ["icon", "close-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "click"]],
  template: function NbTagComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtext(0);
      ɵɵtemplate(1, NbTagComponent_nb_icon_1_Template, 1, 3, "nb-icon", 0);
    }
    if (rf & 2) {
      ɵɵtextInterpolate1("", ctx.text, "\n");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.removable);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  encapsulation: 2,
  changeDetection: 0
});
var NbTagComponent = _NbTagComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTagComponent, [{
    type: Component,
    args: [{
      selector: "nb-tag",
      exportAs: "nbTag",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '{{ text }}\n<nb-icon *ngIf="removable"\n         (click)="_remove()"\n         class="nb-tag-remove size-{{size}}"\n         icon="close-outline"\n         pack="nebular-essentials"\n         aria-hidden="true">\n</nb-icon>\n'
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    text: [{
      type: Input
    }],
    selected: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.selected"]
    }, {
      type: HostBinding,
      args: ["attr.aria-selected"]
    }],
    removable: [{
      type: Input
    }],
    appearance: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    role: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.role"]
    }],
    remove: [{
      type: Output
    }],
    selectedChange: [{
      type: Output
    }],
    _isActive: [{
      type: HostBinding,
      args: ["class.active"]
    }],
    _id: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    filled: [{
      type: HostBinding,
      args: ["class.appearance-filled"]
    }],
    outline: [{
      type: HostBinding,
      args: ["class.appearance-outline"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    tiny: [{
      type: HostBinding,
      args: ["class.size-tiny"]
    }],
    small: [{
      type: HostBinding,
      args: ["class.size-small"]
    }],
    medium: [{
      type: HostBinding,
      args: ["class.size-medium"]
    }],
    large: [{
      type: HostBinding,
      args: ["class.size-large"]
    }],
    giant: [{
      type: HostBinding,
      args: ["class.size-giant"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    _remove: [{
      type: HostListener,
      args: ["keydown.delete"]
    }, {
      type: HostListener,
      args: ["keydown.backspace"]
    }]
  });
})();
var _NbTagInputDirective = class _NbTagInputDirective extends NbInputDirective {
  get _value() {
    return this._hostElement.nativeElement.value;
  }
  _onKeydown(event) {
    this.keyDown$.next(event);
  }
  constructor(_hostElement, focusMonitor, renderer, zone, statusService) {
    super(_hostElement, focusMonitor, renderer, zone, statusService);
    this._hostElement = _hostElement;
    this.focusMonitor = focusMonitor;
    this.renderer = renderer;
    this.zone = zone;
    this.statusService = statusService;
    this.keyDown$ = new Subject();
    this.separatorKeys = [ENTER];
    this.tagAdd = new EventEmitter();
    this.nbTagInputClass = true;
  }
  ngAfterViewInit() {
    super.ngAfterViewInit();
    this.keyDown$.pipe(filter(({
      keyCode
    }) => this.isSeparatorKey(keyCode)), map(() => this._value), takeUntil(this.destroy$)).subscribe((value) => this.tagAdd.emit({
      value,
      input: this._hostElement
    }));
  }
  isSeparatorKey(keyCode) {
    return this.separatorKeys.includes(keyCode);
  }
};
_NbTagInputDirective.ɵfac = function NbTagInputDirective_Factory(t) {
  return new (t || _NbTagInputDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NbFocusMonitor), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
};
_NbTagInputDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTagInputDirective,
  selectors: [["input", "nbTagInput", ""]],
  hostVars: 2,
  hostBindings: function NbTagInputDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function NbTagInputDirective_keydown_HostBindingHandler($event) {
        return ctx._onKeydown($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("nb-tag-input", ctx.nbTagInputClass);
    }
  },
  inputs: {
    separatorKeys: "separatorKeys"
  },
  outputs: {
    tagAdd: "tagAdd"
  },
  exportAs: ["nbTagInput"],
  features: [ɵɵProvidersFeature([{
    provide: NbFormFieldControl,
    useExisting: _NbTagInputDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbTagInputDirective = _NbTagInputDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTagInputDirective, [{
    type: Directive,
    args: [{
      selector: "input[nbTagInput]",
      exportAs: "nbTagInput",
      providers: [{
        provide: NbFormFieldControl,
        useExisting: NbTagInputDirective
      }]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: NbFocusMonitor
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    separatorKeys: [{
      type: Input
    }],
    tagAdd: [{
      type: Output
    }],
    nbTagInputClass: [{
      type: HostBinding,
      args: ["class.nb-tag-input"]
    }],
    _onKeydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var _NbTagListComponent = class _NbTagListComponent {
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = convertToBoolProperty(value);
  }
  get _hasInput() {
    return !!this.tagInput;
  }
  get _isFocused() {
    return this.focused;
  }
  get _isFullWidth() {
    return !!this.tagInput?.fullWidth;
  }
  get _inputClasses() {
    if (this._hasInput) {
      return [`shape-${this.tagInput.shape}`, `size-${this.tagInput.fieldSize}`, this.statusService.getStatusClass(this.tagInput.status)];
    }
    return [`size-${this.size}`];
  }
  _onKeydown(event) {
    this.keyDown$.next(event);
  }
  _onClick({
    target
  }) {
    const clickedTag = this.tags.find((tag) => tag._hostElement.nativeElement === target);
    if (clickedTag) {
      this.tagClick$.next(clickedTag);
    }
  }
  constructor(hostElement, cd, renderer, zone, focusMonitor, activeDescendantKeyManagerFactory, directionService, statusService) {
    this.hostElement = hostElement;
    this.cd = cd;
    this.renderer = renderer;
    this.zone = zone;
    this.focusMonitor = focusMonitor;
    this.activeDescendantKeyManagerFactory = activeDescendantKeyManagerFactory;
    this.directionService = directionService;
    this.statusService = statusService;
    this.destroy$ = new Subject();
    this.keyDown$ = new Subject();
    this.tagClick$ = new Subject();
    this.focused = false;
    this.size = "medium";
    this.tabIndex = 0;
    this.role = "listbox";
    this._multiple = false;
    this.activeTagId = null;
    this.tagRemove = new EventEmitter();
  }
  ngOnInit() {
    this.focusMonitor.monitor(this.hostElement, true).pipe(map((origin) => !!origin), finalize(() => this.focusMonitor.stopMonitoring(this.hostElement)), takeUntil(this.destroy$)).subscribe((isFocused) => this.onFocusChange(isFocused));
  }
  ngAfterContentInit() {
    this.initKeyManager();
    this.setAutocompleteCustomHost();
  }
  ngAfterViewInit() {
    this.listenToLayoutDirectionChange();
    this.listenListKeyDown();
    this.listenInputKeyDown();
    this.listenTagClick();
    this.listenTagRemove();
    this.listenTagDestroy();
    this.listenActiveTagChange();
    this.listenNoTags();
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostElement.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
  initKeyManager() {
    this.keyManager = this.activeDescendantKeyManagerFactory.create(this.tags).withHorizontalOrientation(this.directionService.getDirection()).withWrap();
  }
  listenToLayoutDirectionChange() {
    this.directionService.onDirectionChange().pipe(takeUntil(this.destroy$)).subscribe((direction) => this.keyManager.withHorizontalOrientation(direction));
  }
  listenListKeyDown() {
    const tagListKeyDown$ = this.keyDown$.pipe(filter(({
      target
    }) => target === this.hostElement.nativeElement));
    const activeTagKeyDown$ = tagListKeyDown$.pipe(filter(() => !!this.keyManager.activeItem));
    tagListKeyDown$.pipe(takeUntil(this.destroy$)).subscribe((event) => this.keyManager.onKeydown(event));
    activeTagKeyDown$.pipe(filter(({
      keyCode
    }) => keyCode === SPACE), takeUntil(this.destroy$)).subscribe((event) => {
      this.toggleTag(this.keyManager.activeItem);
      event.preventDefault();
    });
    activeTagKeyDown$.pipe(filter(({
      keyCode
    }) => this.isBackspaceOrDelete(keyCode)), map(() => this.keyManager.activeItem), takeUntil(this.destroy$)).subscribe((tagToRemove) => tagToRemove._remove());
  }
  listenInputKeyDown() {
    const inputKeyDown$ = this.keyDown$.pipe(filter(({
      target
    }) => target === this.tagInput?._hostElement.nativeElement));
    inputKeyDown$.pipe(filter(({
      keyCode
    }) => {
      return this.tagInput._value === "" && this.isBackspaceOrDelete(keyCode) && this.tags.length > 0;
    }), takeUntil(this.destroy$)).subscribe(() => {
      this.hostElement.nativeElement.focus();
      this.keyManager.setLastItemActive();
      this.cd.markForCheck();
    });
  }
  listenTagClick() {
    this.tagClick$.pipe(takeUntil(this.destroy$)).subscribe((clickedTag) => {
      this.toggleTag(clickedTag);
      this.keyManager.setActiveItem(clickedTag);
    });
  }
  listenTagRemove() {
    this.tags.changes.pipe(startWith(this.tags), switchMap((tags) => merge(...tags.map((tag) => tag.remove))), takeUntil(this.destroy$)).subscribe((tagToRemove) => this.tagRemove.emit(tagToRemove));
  }
  listenTagDestroy() {
    this.tags.changes.pipe(startWith(this.tags), switchMap((tags) => merge(...tags.map((tag) => tag.destroy$))), filter((destroyedTag) => destroyedTag === this.keyManager.activeItem), map((destroyedTag) => destroyedTag === this.tags.last), takeUntil(this.destroy$)).subscribe((isLastTagDestroyed) => {
      if (isLastTagDestroyed) {
        this.keyManager.setPreviousItemActive();
      } else {
        this.keyManager.setNextItemActive();
      }
    });
  }
  listenNoTags() {
    this.tags.changes.pipe(startWith(this.tags), filter((tags) => tags.length === 0), takeUntil(this.destroy$)).subscribe(() => this.focusInputIfActive());
  }
  listenActiveTagChange() {
    this.keyManager.change.pipe(map(() => this.keyManager.activeItem?._id), takeUntil(this.destroy$)).subscribe((activeTagId) => {
      this.activeTagId = activeTagId;
      this.cd.markForCheck();
    });
  }
  onFocusChange(isFocused) {
    this.focused = isFocused;
    this.cd.markForCheck();
    if (!isFocused || this.tagInput?.focused$.value) {
      this.keyManager?.setActiveItem(-1);
      return;
    }
    if (this.tags.length === 0 && this._hasInput) {
      this.focusInput();
    } else {
      this.keyManager.setFirstItemActive();
    }
  }
  isBackspaceOrDelete(keyCode) {
    return keyCode === BACKSPACE || keyCode === DELETE;
  }
  setAutocompleteCustomHost() {
    if (this.autocompleteDirective) {
      this.autocompleteDirective.customOverlayHost = this.hostElement;
    }
  }
  toggleTag(tagToToggle) {
    tagToToggle._toggleSelection();
    if (tagToToggle.selected && !this.multiple) {
      this.tags.forEach((tag) => {
        if (tag !== tagToToggle) {
          tag.selected = false;
        }
      });
    }
  }
  focusInput() {
    if (this._hasInput) {
      this.tagInput._hostElement.nativeElement.focus();
    }
  }
  focusInputIfActive() {
    if (this._isFocused) {
      this.focusInput();
    }
  }
};
_NbTagListComponent.ɵfac = function NbTagListComponent_Factory(t) {
  return new (t || _NbTagListComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbFocusMonitor), ɵɵdirectiveInject(NbActiveDescendantKeyManagerFactoryService), ɵɵdirectiveInject(NbLayoutDirectionService), ɵɵdirectiveInject(NbStatusService));
};
_NbTagListComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTagListComponent,
  selectors: [["nb-tag-list"]],
  contentQueries: function NbTagListComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbTagInputDirective, 5);
      ɵɵcontentQuery(dirIndex, NbAutocompleteDirective, 5);
      ɵɵcontentQuery(dirIndex, NbTagComponent, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tagInput = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.autocompleteDirective = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tags = _t);
    }
  },
  hostVars: 12,
  hostBindings: function NbTagListComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function NbTagListComponent_keydown_HostBindingHandler($event) {
        return ctx._onKeydown($event);
      })("click", function NbTagListComponent_click_HostBindingHandler($event) {
        return ctx._onClick($event);
      });
    }
    if (rf & 2) {
      ɵɵattribute("tabindex", ctx.tabIndex)("role", ctx.role)("aria-multiselectable", ctx.multiple)("aria-activedescendant", ctx.activeTagId);
      ɵɵclassMap(ctx._inputClasses);
      ɵɵclassProp("nb-tag-list-with-input", ctx._hasInput)("focus", ctx._isFocused)("input-full-width", ctx._isFullWidth);
    }
  },
  inputs: {
    size: "size",
    tabIndex: "tabIndex",
    role: "role",
    multiple: "multiple"
  },
  outputs: {
    tagRemove: "tagRemove"
  },
  exportAs: ["nbTagList"],
  ngContentSelectors: _c55,
  decls: 2,
  vars: 0,
  consts: [[1, "nb-tag-list-tags-wrapper"]],
  template: function NbTagListComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c54);
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
var NbTagListComponent = _NbTagListComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTagListComponent, [{
    type: Component,
    args: [{
      selector: "nb-tag-list",
      template: `
    <div class="nb-tag-list-tags-wrapper">
      <ng-content select="nb-tag, input[nbTagInput]"></ng-content>
    </div>
  `,
      exportAs: "nbTagList",
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: Renderer2
  }, {
    type: NgZone
  }, {
    type: NbFocusMonitor
  }, {
    type: NbActiveDescendantKeyManagerFactoryService
  }, {
    type: NbLayoutDirectionService
  }, {
    type: NbStatusService
  }], {
    tags: [{
      type: ContentChildren,
      args: [NbTagComponent]
    }],
    tagInput: [{
      type: ContentChild,
      args: [NbTagInputDirective]
    }],
    autocompleteDirective: [{
      type: ContentChild,
      args: [NbAutocompleteDirective]
    }],
    size: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    role: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.role"]
    }],
    multiple: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-multiselectable"]
    }],
    activeTagId: [{
      type: HostBinding,
      args: ["attr.aria-activedescendant"]
    }],
    tagRemove: [{
      type: Output
    }],
    _hasInput: [{
      type: HostBinding,
      args: ["class.nb-tag-list-with-input"]
    }],
    _isFocused: [{
      type: HostBinding,
      args: ["class.focus"]
    }],
    _isFullWidth: [{
      type: HostBinding,
      args: ["class.input-full-width"]
    }],
    _inputClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    _onKeydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }],
    _onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var _NbTagModule = class _NbTagModule {
};
_NbTagModule.ɵfac = function NbTagModule_Factory(t) {
  return new (t || _NbTagModule)();
};
_NbTagModule.ɵmod = ɵɵdefineNgModule({
  type: _NbTagModule,
  declarations: [NbTagComponent, NbTagListComponent, NbTagInputDirective],
  imports: [CommonModule, NbIconModule],
  exports: [NbTagComponent, NbTagListComponent, NbTagInputDirective]
});
_NbTagModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, NbIconModule]
});
var NbTagModule = _NbTagModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTagModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbIconModule],
      declarations: [NbTagComponent, NbTagListComponent, NbTagInputDirective],
      exports: [NbTagComponent, NbTagListComponent, NbTagInputDirective]
    }]
  }], null, null);
})();
var NB_DEFAULT_ROW_LEVEL = 0;
var NbTreeGridPresentationNode = class {
  constructor(data, children, expanded, level) {
    this.data = data;
    this.children = children;
    this.expanded = expanded;
    this.level = level;
  }
  /**
   * True if row has child rows
   */
  hasChildren() {
    return !!this.children && !!this.children.length;
  }
};
var _NbTreeGridFilterService = class _NbTreeGridFilterService {
  filter(query, data) {
    if (!query) {
      return data;
    }
    return data.reduce((filtered, node) => {
      let filteredChildren;
      if (node.children) {
        filteredChildren = this.filter(query, node.children);
        node.children = filteredChildren;
      }
      node.expanded = false;
      if (filteredChildren && filteredChildren.length) {
        node.expanded = true;
        filtered.push(node);
      } else if (this.filterPredicate(node.data, query)) {
        filtered.push(node);
      }
      return filtered;
    }, []);
  }
  filterPredicate(data, searchQuery) {
    const preparedQuery = searchQuery.trim().toLocaleLowerCase();
    for (const val of Object.values(data)) {
      const preparedVal = `${val}`.trim().toLocaleLowerCase();
      if (preparedVal.includes(preparedQuery)) {
        return true;
      }
    }
    return false;
  }
};
_NbTreeGridFilterService.ɵfac = function NbTreeGridFilterService_Factory(t) {
  return new (t || _NbTreeGridFilterService)();
};
_NbTreeGridFilterService.ɵprov = ɵɵdefineInjectable({
  token: _NbTreeGridFilterService,
  factory: _NbTreeGridFilterService.ɵfac
});
var NbTreeGridFilterService = _NbTreeGridFilterService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFilterService, [{
    type: Injectable
  }], null, null);
})();
var NbSortDirection;
(function(NbSortDirection2) {
  NbSortDirection2["ASCENDING"] = "asc";
  NbSortDirection2["DESCENDING"] = "desc";
  NbSortDirection2["NONE"] = "";
})(NbSortDirection || (NbSortDirection = {}));
var sortDirections = [NbSortDirection.ASCENDING, NbSortDirection.DESCENDING, NbSortDirection.NONE];
var _NbSortDirective = class _NbSortDirective {
  constructor() {
    this.sort = new EventEmitter();
  }
  emitSort(sortRequest) {
    if (this.sortable && this.sortable.sort) {
      this.sortable.sort(sortRequest);
    }
    this.sort.emit(sortRequest);
  }
};
_NbSortDirective.ɵfac = function NbSortDirective_Factory(t) {
  return new (t || _NbSortDirective)();
};
_NbSortDirective.ɵdir = ɵɵdefineDirective({
  type: _NbSortDirective,
  selectors: [["", "nbSort", ""]],
  inputs: {
    sortable: [InputFlags.None, "nbSort", "sortable"]
  },
  outputs: {
    sort: "sort"
  }
});
var NbSortDirective = _NbSortDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSortDirective, [{
    type: Directive,
    args: [{
      selector: "[nbSort]"
    }]
  }], null, {
    sortable: [{
      type: Input,
      args: ["nbSort"]
    }],
    sort: [{
      type: Output
    }]
  });
})();
var _NbSortHeaderIconDirective = class _NbSortHeaderIconDirective {
};
_NbSortHeaderIconDirective.ɵfac = function NbSortHeaderIconDirective_Factory(t) {
  return new (t || _NbSortHeaderIconDirective)();
};
_NbSortHeaderIconDirective.ɵdir = ɵɵdefineDirective({
  type: _NbSortHeaderIconDirective,
  selectors: [["", "nbSortHeaderIcon", ""]]
});
var NbSortHeaderIconDirective = _NbSortHeaderIconDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSortHeaderIconDirective, [{
    type: Directive,
    args: [{
      selector: "[nbSortHeaderIcon]"
    }]
  }], null, null);
})();
var _NbSortIconComponent = class _NbSortIconComponent {
  constructor() {
    this.direction = NbSortDirection.NONE;
  }
  isAscending() {
    return this.direction === NbSortDirection.ASCENDING;
  }
  isDescending() {
    return this.direction === NbSortDirection.DESCENDING;
  }
  isDirectionSet() {
    return this.isAscending() || this.isDescending();
  }
};
_NbSortIconComponent.ɵfac = function NbSortIconComponent_Factory(t) {
  return new (t || _NbSortIconComponent)();
};
_NbSortIconComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSortIconComponent,
  selectors: [["nb-sort-icon"]],
  inputs: {
    direction: "direction"
  },
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true", 4, "ngIf"], ["icon", "chevron-up-outline", "pack", "nebular-essentials", "aria-hidden", "true", 4, "ngIf"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true"], ["icon", "chevron-up-outline", "pack", "nebular-essentials", "aria-hidden", "true"]],
  template: function NbSortIconComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, NbSortIconComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.isDirectionSet());
    }
  },
  dependencies: [NgIf, NbIconComponent],
  encapsulation: 2
});
var NbSortIconComponent = _NbSortIconComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSortIconComponent, [{
    type: Component,
    args: [{
      selector: "nb-sort-icon",
      template: `
    <ng-container *ngIf="isDirectionSet()">
      <nb-icon *ngIf="isAscending()" icon="chevron-down-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
      <nb-icon *ngIf="isDescending()" icon="chevron-up-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
    </ng-container>
  `
    }]
  }], null, {
    direction: [{
      type: Input
    }]
  });
})();
var _NbSortHeaderComponent = class _NbSortHeaderComponent {
  /**
   * Disable sort header
   */
  set disabled(value) {
    this.disabledValue = convertToBoolProperty(value);
  }
  get disabled() {
    return this.disabledValue;
  }
  sortIfEnabled() {
    if (!this.disabled) {
      this.sortData();
    }
  }
  constructor(sort, columnDef) {
    this.sort = sort;
    this.columnDef = columnDef;
    this.disabledValue = false;
  }
  isAscending() {
    return this.direction === NbSortDirection.ASCENDING;
  }
  isDescending() {
    return this.direction === NbSortDirection.DESCENDING;
  }
  sortData() {
    const sortRequest = this.createSortRequest();
    this.sort.emitSort(sortRequest);
  }
  getIconContext() {
    return {
      $implicit: this.direction,
      isAscending: this.isAscending(),
      isDescending: this.isDescending(),
      isNone: !this.isAscending() && !this.isDescending()
    };
  }
  getDisabledAttributeValue() {
    return this.disabled ? "" : null;
  }
  createSortRequest() {
    this.direction = this.getNextDirection();
    return {
      direction: this.direction,
      column: this.columnDef.name
    };
  }
  getNextDirection() {
    const sortDirectionCycle = sortDirections;
    let nextDirectionIndex = sortDirectionCycle.indexOf(this.direction) + 1;
    if (nextDirectionIndex >= sortDirectionCycle.length) {
      nextDirectionIndex = 0;
    }
    return sortDirectionCycle[nextDirectionIndex];
  }
};
_NbSortHeaderComponent.ɵfac = function NbSortHeaderComponent_Factory(t) {
  return new (t || _NbSortHeaderComponent)(ɵɵdirectiveInject(NbSortDirective), ɵɵdirectiveInject(NB_SORT_HEADER_COLUMN_DEF));
};
_NbSortHeaderComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbSortHeaderComponent,
  selectors: [["", "nbSortHeader", ""]],
  contentQueries: function NbSortHeaderComponent_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, NbSortHeaderIconDirective, 5, TemplateRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.sortIcon = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function NbSortHeaderComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbSortHeaderComponent_click_HostBindingHandler() {
        return ctx.sortIfEnabled();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("disabled", ctx.disabled);
    }
  },
  inputs: {
    direction: [InputFlags.None, "nbSortHeader", "direction"],
    disabled: "disabled"
  },
  attrs: _c56,
  ngContentSelectors: _c02,
  decls: 5,
  vars: 5,
  consts: [["type", "button", 1, "nb-tree-grid-header-change-sort-button", 3, "click"], [3, "direction", 4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["customIcon", ""], [3, "direction"]],
  template: function NbSortHeaderComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function NbSortHeaderComponent_Template_button_click_0_listener() {
        return ctx.sortData();
      });
      ɵɵprojection(1);
      ɵɵelementEnd();
      ɵɵtemplate(2, NbSortHeaderComponent_nb_sort_icon_2_Template, 1, 1, "nb-sort-icon", 1)(3, NbSortHeaderComponent_ng_template_3_Template, 0, 0, "ng-template", 2, 3, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const _r2 = ɵɵreference(4);
      ɵɵattribute("disabled", ctx.getDisabledAttributeValue());
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.sortIcon)("ngIfElse", _r2);
      ɵɵadvance();
      ɵɵproperty("ngTemplateOutlet", ctx.sortIcon)("ngTemplateOutletContext", ctx.getIconContext());
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, NbSortIconComponent],
  encapsulation: 2
});
var NbSortHeaderComponent = _NbSortHeaderComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbSortHeaderComponent, [{
    type: Component,
    args: [{
      selector: "[nbSortHeader]",
      template: `
    <button
      class="nb-tree-grid-header-change-sort-button"
      type="button"
      [attr.disabled]="getDisabledAttributeValue()"
      (click)="sortData()">
      <ng-content></ng-content>
    </button>
    <nb-sort-icon *ngIf="!sortIcon; else customIcon" [direction]="direction"></nb-sort-icon>
    <ng-template #customIcon [ngTemplateOutlet]="sortIcon" [ngTemplateOutletContext]="getIconContext()"></ng-template>
  `
    }]
  }], () => [{
    type: NbSortDirective
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_SORT_HEADER_COLUMN_DEF]
    }]
  }], {
    sortIcon: [{
      type: ContentChild,
      args: [NbSortHeaderIconDirective, {
        read: TemplateRef
      }]
    }],
    direction: [{
      type: Input,
      args: ["nbSortHeader"]
    }],
    disabled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.disabled"]
    }],
    sortIfEnabled: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var _NbTreeGridSortService = class _NbTreeGridSortService {
  sort(request, data) {
    if (!request) {
      return data;
    }
    const sorted = data.sort((na, nb) => this.comparator(request, na, nb));
    for (const node of data) {
      if (node.children) {
        node.children = this.sort(request, node.children);
      }
    }
    return sorted;
  }
  comparator(request, na, nb) {
    const key = request.column;
    const dir = request.direction;
    const a = na.data[key];
    const b = nb.data[key];
    let res = 0;
    if (a > b) {
      res = 1;
    }
    if (a < b) {
      res = -1;
    }
    return dir === NbSortDirection.ASCENDING ? res : res * -1;
  }
};
_NbTreeGridSortService.ɵfac = function NbTreeGridSortService_Factory(t) {
  return new (t || _NbTreeGridSortService)();
};
_NbTreeGridSortService.ɵprov = ɵɵdefineInjectable({
  token: _NbTreeGridSortService,
  factory: _NbTreeGridSortService.ɵfac
});
var NbTreeGridSortService = _NbTreeGridSortService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridSortService, [{
    type: Injectable
  }], null, null);
})();
var _NbTreeGridService = class _NbTreeGridService {
  expand(data, row, options = {}) {
    const node = this.find(data, row);
    node.expanded = true;
    if (options.deep && node.hasChildren()) {
      node.children.forEach((n) => this.expand(data, n.data, options));
    }
  }
  collapse(data, row, options = {}) {
    const node = this.find(data, row);
    node.expanded = false;
    if (options.deep && node.hasChildren()) {
      node.children.forEach((n) => this.collapse(data, n.data, options));
    }
  }
  toggle(data, row, options = {}) {
    const node = this.find(data, row);
    if (node.expanded) {
      this.collapse(data, row, options);
    } else {
      this.expand(data, row, options);
    }
  }
  find(data, row) {
    const toCheck = [...data];
    for (const node of toCheck) {
      if (node.data === row) {
        return node;
      }
      if (node.hasChildren()) {
        toCheck.push(...node.children);
      }
    }
    return void 0;
  }
};
_NbTreeGridService.ɵfac = function NbTreeGridService_Factory(t) {
  return new (t || _NbTreeGridService)();
};
_NbTreeGridService.ɵprov = ɵɵdefineInjectable({
  token: _NbTreeGridService,
  factory: _NbTreeGridService.ɵfac
});
var NbTreeGridService = _NbTreeGridService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridService, [{
    type: Injectable
  }], null, null);
})();
var _NbTreeGridDataService = class _NbTreeGridDataService {
  constructor() {
    this.defaultGetters = {
      dataGetter: (node) => node.data,
      childrenGetter: (d) => d.children || void 0,
      expandedGetter: (d) => !!d.expanded
    };
  }
  toPresentationNodes(nodes, customGetters, level = NB_DEFAULT_ROW_LEVEL) {
    const getters = __spreadValues(__spreadValues({}, this.defaultGetters), customGetters);
    return this.mapNodes(nodes, getters, level);
  }
  mapNodes(nodes, getters, level) {
    const {
      dataGetter,
      childrenGetter,
      expandedGetter
    } = getters;
    return nodes.map((node) => {
      const childrenNodes = childrenGetter(node);
      let children;
      if (childrenNodes) {
        children = this.toPresentationNodes(childrenNodes, getters, level + 1);
      }
      return new NbTreeGridPresentationNode(dataGetter(node), children, expandedGetter(node), level);
    });
  }
  flattenExpanded(nodes) {
    return nodes.reduce((res, node) => {
      res.push(node);
      if (node.expanded && node.hasChildren()) {
        res.push(...this.flattenExpanded(node.children));
      }
      return res;
    }, []);
  }
  copy(nodes) {
    return nodes.map((node) => {
      let children;
      if (node.hasChildren()) {
        children = this.copy(node.children);
      }
      return new NbTreeGridPresentationNode(node.data, children, node.expanded, node.level);
    });
  }
};
_NbTreeGridDataService.ɵfac = function NbTreeGridDataService_Factory(t) {
  return new (t || _NbTreeGridDataService)();
};
_NbTreeGridDataService.ɵprov = ɵɵdefineInjectable({
  token: _NbTreeGridDataService,
  factory: _NbTreeGridDataService.ɵfac
});
var NbTreeGridDataService = _NbTreeGridDataService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridDataService, [{
    type: Injectable
  }], null, null);
})();
var NbTreeGridDataSource = class extends NbDataSource {
  constructor(sortService, filterService, treeGridService, treeGridDataService) {
    super();
    this.sortService = sortService;
    this.filterService = filterService;
    this.treeGridService = treeGridService;
    this.treeGridDataService = treeGridDataService;
    this.renderData = new BehaviorSubject([]);
    this.filterRequest = new BehaviorSubject("");
    this.sortRequest = new BehaviorSubject(null);
  }
  setData(data, customGetters) {
    let presentationData = [];
    if (data) {
      presentationData = this.treeGridDataService.toPresentationNodes(data, customGetters);
    }
    this.data = new BehaviorSubject(presentationData);
    this.updateChangeSubscription();
  }
  connect(collectionViewer) {
    return this.renderData;
  }
  disconnect(collectionViewer) {
  }
  expand(row) {
    this.treeGridService.expand(this.data.value, row);
    this.data.next(this.data.value);
  }
  collapse(row) {
    this.treeGridService.collapse(this.data.value, row);
    this.data.next(this.data.value);
  }
  toggle(row, options) {
    this.treeGridService.toggle(this.data.value, row, options);
    this.data.next(this.data.value);
  }
  toggleByIndex(dataIndex, options) {
    const node = this.renderData.value && this.renderData.value[dataIndex];
    if (node) {
      this.toggle(node.data, options);
    }
  }
  getLevel(rowIndex) {
    const row = this.renderData.value[rowIndex];
    return row ? row.level : NB_DEFAULT_ROW_LEVEL;
  }
  sort(sortRequest) {
    this.sortRequest.next(sortRequest);
  }
  filter(searchQuery) {
    this.filterRequest.next(searchQuery);
  }
  updateChangeSubscription() {
    const dataStream = this.data;
    const filteredData = combineLatest([dataStream, this.filterRequest]).pipe(map(([data]) => this.treeGridDataService.copy(data)), map((data) => this.filterData(data)));
    const sortedData = combineLatest([filteredData, this.sortRequest]).pipe(map(([data]) => this.sortData(data)));
    sortedData.pipe(map((data) => this.treeGridDataService.flattenExpanded(data))).subscribe((data) => this.renderData.next(data));
  }
  filterData(data) {
    return this.filterService.filter(this.filterRequest.value, data);
  }
  sortData(data) {
    return this.sortService.sort(this.sortRequest.value, data);
  }
};
var _NbTreeGridDataSourceBuilder = class _NbTreeGridDataSourceBuilder {
  constructor(filterService, sortService, treeGridService, treeGridDataService) {
    this.filterService = filterService;
    this.sortService = sortService;
    this.treeGridService = treeGridService;
    this.treeGridDataService = treeGridDataService;
  }
  create(data, customGetters) {
    const dataSource = new NbTreeGridDataSource(this.sortService, this.filterService, this.treeGridService, this.treeGridDataService);
    dataSource.setData(data, customGetters);
    return dataSource;
  }
};
_NbTreeGridDataSourceBuilder.ɵfac = function NbTreeGridDataSourceBuilder_Factory(t) {
  return new (t || _NbTreeGridDataSourceBuilder)(ɵɵinject(NbTreeGridFilterService), ɵɵinject(NbTreeGridSortService), ɵɵinject(NbTreeGridService), ɵɵinject(NbTreeGridDataService));
};
_NbTreeGridDataSourceBuilder.ɵprov = ɵɵdefineInjectable({
  token: _NbTreeGridDataSourceBuilder,
  factory: _NbTreeGridDataSourceBuilder.ɵfac
});
var NbTreeGridDataSourceBuilder = _NbTreeGridDataSourceBuilder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridDataSourceBuilder, [{
    type: Injectable
  }], () => [{
    type: NbTreeGridFilterService
  }, {
    type: NbTreeGridSortService
  }, {
    type: NbTreeGridService
  }, {
    type: NbTreeGridDataService
  }], null);
})();
var NB_TREE_GRID = new InjectionToken("NB_TREE_GRID");
var _NbColumnsService = class _NbColumnsService {
  constructor(differs) {
    this.differs = differs;
    this.columnHide$ = new Subject();
    this.columnShow$ = new Subject();
  }
  setColumns(columns) {
    if (!this.changesDiffer) {
      this.changesDiffer = this.differs.find(columns || []).create();
    }
    if (this.changesDiffer.diff(columns)) {
      this.allColumns = Array.from(columns);
      this.visibleColumns = Array.from(columns);
    }
  }
  getVisibleColumns() {
    return this.visibleColumns;
  }
  hideColumn(column) {
    const toRemove = this.visibleColumns.indexOf(column);
    if (toRemove > -1) {
      this.visibleColumns.splice(toRemove, 1);
      this.columnHide$.next();
    }
  }
  showColumn(column) {
    if (this.visibleColumns.includes(column)) {
      return;
    }
    this.visibleColumns.splice(this.findInsertIndex(column), 0, column);
    this.columnShow$.next();
  }
  onColumnsChange() {
    return merge(this.columnShow$, this.columnHide$);
  }
  findInsertIndex(column) {
    const initialIndex = this.allColumns.indexOf(column);
    if (initialIndex === 0 || !this.visibleColumns.length) {
      return 0;
    }
    if (initialIndex === this.allColumns.length - 1) {
      return this.visibleColumns.length;
    }
    const leftSiblingIndex = initialIndex - 1;
    for (let i = leftSiblingIndex; i >= 0; i--) {
      const leftSibling = this.allColumns[i];
      const index = this.visibleColumns.indexOf(leftSibling);
      if (index !== -1) {
        return index + 1;
      }
    }
    const rightSiblingIndex = initialIndex + 1;
    for (let i = rightSiblingIndex; i < this.allColumns.length; i++) {
      const rightSibling = this.allColumns[i];
      const index = this.visibleColumns.indexOf(rightSibling);
      if (index !== -1) {
        return index;
      }
    }
    throw new Error(`Can't restore column position.`);
  }
};
_NbColumnsService.ɵfac = function NbColumnsService_Factory(t) {
  return new (t || _NbColumnsService)(ɵɵinject(IterableDiffers));
};
_NbColumnsService.ɵprov = ɵɵdefineInjectable({
  token: _NbColumnsService,
  factory: _NbColumnsService.ɵfac
});
var NbColumnsService = _NbColumnsService;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbColumnsService, [{
    type: Injectable
  }], () => [{
    type: IterableDiffers
  }], null);
})();
var _NbTreeGridComponent = class _NbTreeGridComponent extends NbTable {
  constructor(dataSourceBuilder, differs, changeDetectorRef, elementRef, role, dir, document, platform, window2, _viewRepeater, _coalescedStyleScheduler, _viewportRuler, _stickyPositioningListener) {
    super(differs, changeDetectorRef, elementRef, role, dir, document, platform, _viewRepeater, _coalescedStyleScheduler, _viewportRuler, _stickyPositioningListener);
    this.dataSourceBuilder = dataSourceBuilder;
    this.window = window2;
    this._viewRepeater = _viewRepeater;
    this._coalescedStyleScheduler = _coalescedStyleScheduler;
    this._stickyPositioningListener = _stickyPositioningListener;
    this.destroy$ = new Subject();
    this.levelPadding = "";
    this.equalColumnsWidthValue = false;
    this.treeClass = true;
    this.platform = platform;
  }
  /**
   * The table's data
   * @param data
   * @type {<T>[] | NbTreeGridDataSource}
   */
  set source(data) {
    if (!data) {
      return;
    }
    if (data instanceof NbTreeGridDataSource) {
      this._source = data;
    } else {
      this._source = this.dataSourceBuilder.create(data);
    }
    this.dataSource = this._source;
  }
  /**
   * Make all columns equal width. False by default.
   */
  set equalColumnsWidth(value) {
    this.equalColumnsWidthValue = convertToBoolProperty(value);
  }
  get equalColumnsWidth() {
    return this.equalColumnsWidthValue;
  }
  ngAfterViewInit() {
    this.checkDefsCount();
    const rowsChange$ = merge(this._contentRowDefs.changes, this._contentHeaderRowDefs.changes, this._contentFooterRowDefs.changes);
    rowsChange$.pipe(takeUntil(this.destroy$)).subscribe(() => this.checkDefsCount());
    if (this.platform.isBrowser) {
      this.updateVisibleColumns();
      const windowResize$ = fromEvent(this.window, "resize").pipe(debounceTime(50));
      merge(rowsChange$, this._contentColumnDefs.changes, windowResize$).pipe(takeUntil(this.destroy$)).subscribe(() => this.updateVisibleColumns());
    }
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.destroy$.next();
    this.destroy$.complete();
  }
  toggleRow(row, options) {
    const context = this.getRowContext(row);
    this._source.toggle(context.$implicit.data, options);
  }
  toggleCellRow(cell) {
    const context = this.getCellContext(cell);
    this._source.toggle(context.$implicit.data);
  }
  getColumnWidth() {
    if (this.equalColumnsWidth) {
      return `${100 / this.getColumnsCount()}%`;
    }
    return "";
  }
  getCellLevel(cell, columnName) {
    if (this.isFirstColumn(columnName)) {
      return this.getCellContext(cell).$implicit.level;
    }
    return NB_DEFAULT_ROW_LEVEL;
  }
  getRowContext(row) {
    return this.getContextByRowEl(row.elementRef.nativeElement);
  }
  getCellContext(cell) {
    return this.getContextByCellEl(cell.elementRef.nativeElement);
  }
  getContextByCellEl(cellEl) {
    return this.getContextByRowEl(cellEl.parentElement);
  }
  getContextByRowEl(rowEl) {
    const rowsContainer = this._rowOutlet.viewContainer;
    for (let i = 0; i < rowsContainer.length; i++) {
      const rowViewRef = rowsContainer.get(i);
      if (rowViewRef.rootNodes.includes(rowEl)) {
        return rowViewRef.context;
      }
    }
    return void 0;
  }
  getColumns() {
    let rowDef;
    if (this._contentHeaderRowDefs.length) {
      rowDef = this._contentHeaderRowDefs.first;
    } else {
      rowDef = this._contentRowDefs.first;
    }
    return Array.from(rowDef.getVisibleColumns() || []);
  }
  getColumnsCount() {
    return this.getColumns().length;
  }
  isFirstColumn(columnName) {
    return this.getColumns()[0] === columnName;
  }
  checkDefsCount() {
    if (this._contentRowDefs.length > 1) {
      throw new Error(`Found multiple row definitions`);
    }
    if (this._contentHeaderRowDefs.length > 1) {
      throw new Error(`Found multiple header row definitions`);
    }
    if (this._contentFooterRowDefs.length > 1) {
      throw new Error(`Found multiple footer row definitions`);
    }
  }
  updateVisibleColumns() {
    const width = this.window.innerWidth;
    const columnDefs = this._contentColumnDefs;
    const columnsToHide = columnDefs.filter((col) => col.shouldHide(width)).map((col) => col.name);
    const columnsToShow = columnDefs.filter((col) => col.shouldShow(width)).map((col) => col.name);
    if (!columnsToHide.length && !columnsToShow.length) {
      return;
    }
    const rowDefs = [this._contentHeaderRowDefs.first, this._contentRowDefs.first, this._contentFooterRowDefs.first].filter((d) => !!d);
    for (const rowDef of rowDefs) {
      for (const column of columnsToHide) {
        rowDef.hideColumn(column);
      }
      for (const column of columnsToShow) {
        rowDef.showColumn(column);
      }
    }
  }
};
_NbTreeGridComponent.ɵfac = function NbTreeGridComponent_Factory(t) {
  return new (t || _NbTreeGridComponent)(ɵɵdirectiveInject(NbTreeGridDataSourceBuilder), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵinjectAttribute("role"), ɵɵdirectiveInject(NbDirectionality), ɵɵdirectiveInject(NB_DOCUMENT), ɵɵdirectiveInject(NbPlatform), ɵɵdirectiveInject(NB_WINDOW), ɵɵdirectiveInject(NB_VIEW_REPEATER_STRATEGY), ɵɵdirectiveInject(NB_COALESCED_STYLE_SCHEDULER), ɵɵdirectiveInject(NbViewportRulerAdapter), ɵɵdirectiveInject(NB_STICKY_POSITIONING_LISTENER, 12));
};
_NbTreeGridComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTreeGridComponent,
  selectors: [["table", "nbTreeGrid", ""]],
  hostVars: 2,
  hostBindings: function NbTreeGridComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("nb-tree-grid", ctx.treeClass);
    }
  },
  inputs: {
    source: [InputFlags.None, "nbTreeGrid", "source"],
    levelPadding: "levelPadding",
    equalColumnsWidth: "equalColumnsWidth"
  },
  features: [ɵɵProvidersFeature([{
    provide: NB_TREE_GRID,
    useExisting: _NbTreeGridComponent
  }, NbColumnsService, ...NB_TABLE_PROVIDERS]), ɵɵInheritDefinitionFeature],
  attrs: _c57,
  decls: 4,
  vars: 0,
  consts: [["nbHeaderRowOutlet", ""], ["nbRowOutlet", ""], ["nbNoDataRowOutlet", ""], ["nbFooterRowOutlet", ""]],
  template: function NbTreeGridComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0)(1, 1)(2, 2)(3, 3);
    }
  },
  dependencies: [NbDataRowOutletDirective, NbHeaderRowOutletDirective, NbFooterRowOutletDirective, NbNoDataRowOutletDirective],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{table-layout:fixed;border-spacing:0;border-collapse:collapse;width:100%;max-width:100%;overflow:auto}  .nb-tree-grid-cell,   .nb-tree-grid-header-cell,   .nb-tree-grid-footer-cell{overflow:hidden}"]
});
var NbTreeGridComponent = _NbTreeGridComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridComponent, [{
    type: Component,
    args: [{
      selector: "table[nbTreeGrid]",
      template: NB_TABLE_TEMPLATE,
      providers: [{
        provide: NB_TREE_GRID,
        useExisting: NbTreeGridComponent
      }, NbColumnsService, ...NB_TABLE_PROVIDERS],
      styles: ["/*\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{table-layout:fixed;border-spacing:0;border-collapse:collapse;width:100%;max-width:100%;overflow:auto}::ng-deep .nb-tree-grid-cell,::ng-deep .nb-tree-grid-header-cell,::ng-deep .nb-tree-grid-footer-cell{overflow:hidden}\n"]
    }]
  }], () => [{
    type: NbTreeGridDataSourceBuilder
  }, {
    type: IterableDiffers
  }, {
    type: ChangeDetectorRef
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["role"]
    }]
  }, {
    type: NbDirectionality
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_DOCUMENT]
    }]
  }, {
    type: NbPlatform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_VIEW_REPEATER_STRATEGY]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_COALESCED_STYLE_SCHEDULER]
    }]
  }, {
    type: NbViewportRulerAdapter
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: SkipSelf
    }, {
      type: Inject,
      args: [NB_STICKY_POSITIONING_LISTENER]
    }]
  }], {
    source: [{
      type: Input,
      args: ["nbTreeGrid"]
    }],
    levelPadding: [{
      type: Input
    }],
    equalColumnsWidth: [{
      type: Input
    }],
    treeClass: [{
      type: HostBinding,
      args: ["class.nb-tree-grid"]
    }]
  });
})();
var _NbTreeGridRowDefDirective = class _NbTreeGridRowDefDirective extends NbRowDefDirective {
  constructor(template, differs, columnsService) {
    super(template, differs);
    this.columnsService = columnsService;
  }
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
    if (changes["columns"]) {
      this.updateColumns(this.columns);
    }
  }
  updateColumns(columns) {
    this.columnsService.setColumns(columns);
  }
  getVisibleColumns() {
    return this.columnsService.getVisibleColumns();
  }
  /** @docs-private */
  hideColumn(column) {
    this.columnsService.hideColumn(column);
  }
  /** @docs-private */
  showColumn(column) {
    this.columnsService.showColumn(column);
  }
};
_NbTreeGridRowDefDirective.ɵfac = function NbTreeGridRowDefDirective_Factory(t) {
  return new (t || _NbTreeGridRowDefDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(NbColumnsService));
};
_NbTreeGridRowDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridRowDefDirective,
  selectors: [["", "nbTreeGridRowDef", ""]],
  inputs: {
    columns: [InputFlags.None, "nbTreeGridRowDefColumns", "columns"]
  },
  features: [ɵɵProvidersFeature([{
    provide: NbCdkRowDef,
    useExisting: _NbTreeGridRowDefDirective
  }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
var NbTreeGridRowDefDirective = _NbTreeGridRowDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridRowDef]",
      providers: [{
        provide: NbCdkRowDef,
        useExisting: NbTreeGridRowDefDirective
      }]
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: NbColumnsService
  }], {
    columns: [{
      type: Input,
      args: ["nbTreeGridRowDefColumns"]
    }]
  });
})();
var _NbTreeGridHeaderRowDefDirective = class _NbTreeGridHeaderRowDefDirective extends NbHeaderRowDefDirective {
  constructor(template, differs, columnsService) {
    super(template, differs);
    this.columnsService = columnsService;
  }
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
    if (changes["columns"]) {
      this.updateColumns(this.columns);
    }
  }
  updateColumns(columns) {
    this.columnsService.setColumns(columns);
  }
  getVisibleColumns() {
    return this.columnsService.getVisibleColumns();
  }
  /** @docs-private */
  hideColumn(column) {
    this.columnsService.hideColumn(column);
  }
  /** @docs-private */
  showColumn(column) {
    this.columnsService.showColumn(column);
  }
};
_NbTreeGridHeaderRowDefDirective.ɵfac = function NbTreeGridHeaderRowDefDirective_Factory(t) {
  return new (t || _NbTreeGridHeaderRowDefDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(NbColumnsService));
};
_NbTreeGridHeaderRowDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridHeaderRowDefDirective,
  selectors: [["", "nbTreeGridHeaderRowDef", ""]],
  inputs: {
    columns: [InputFlags.None, "nbTreeGridHeaderRowDef", "columns"]
  },
  features: [ɵɵProvidersFeature([{
    provide: NbCdkHeaderRowDef,
    useExisting: _NbTreeGridHeaderRowDefDirective
  }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
var NbTreeGridHeaderRowDefDirective = _NbTreeGridHeaderRowDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridHeaderRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridHeaderRowDef]",
      providers: [{
        provide: NbCdkHeaderRowDef,
        useExisting: NbTreeGridHeaderRowDefDirective
      }]
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: NbColumnsService
  }], {
    columns: [{
      type: Input,
      args: ["nbTreeGridHeaderRowDef"]
    }]
  });
})();
var _NbTreeGridFooterRowDefDirective = class _NbTreeGridFooterRowDefDirective extends NbFooterRowDefDirective {
  constructor(template, differs, columnsService) {
    super(template, differs);
    this.columnsService = columnsService;
  }
  ngOnChanges(changes) {
    super.ngOnChanges(changes);
    if (changes["columns"]) {
      this.updateColumns(this.columns);
    }
  }
  updateColumns(columns) {
    this.columnsService.setColumns(columns);
  }
  getVisibleColumns() {
    return this.columnsService.getVisibleColumns();
  }
  /** @docs-private */
  hideColumn(column) {
    this.columnsService.hideColumn(column);
  }
  /** @docs-private */
  showColumn(column) {
    this.columnsService.showColumn(column);
  }
};
_NbTreeGridFooterRowDefDirective.ɵfac = function NbTreeGridFooterRowDefDirective_Factory(t) {
  return new (t || _NbTreeGridFooterRowDefDirective)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(NbColumnsService));
};
_NbTreeGridFooterRowDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridFooterRowDefDirective,
  selectors: [["", "nbTreeGridFooterRowDef", ""]],
  inputs: {
    columns: [InputFlags.None, "nbTreeGridFooterRowDef", "columns"]
  },
  features: [ɵɵProvidersFeature([{
    provide: NbCdkFooterRowDef,
    useExisting: _NbTreeGridFooterRowDefDirective
  }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
var NbTreeGridFooterRowDefDirective = _NbTreeGridFooterRowDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFooterRowDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridFooterRowDef]",
      providers: [{
        provide: NbCdkFooterRowDef,
        useExisting: NbTreeGridFooterRowDefDirective
      }]
    }]
  }], () => [{
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: NbColumnsService
  }], {
    columns: [{
      type: Input,
      args: ["nbTreeGridFooterRowDef"]
    }]
  });
})();
var _NbTreeGridCellDefDirective = class _NbTreeGridCellDefDirective extends NbCellDefDirective {
};
_NbTreeGridCellDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbTreeGridCellDefDirective_BaseFactory;
  return function NbTreeGridCellDefDirective_Factory(t) {
    return (ɵNbTreeGridCellDefDirective_BaseFactory || (ɵNbTreeGridCellDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbTreeGridCellDefDirective)))(t || _NbTreeGridCellDefDirective);
  };
})();
_NbTreeGridCellDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridCellDefDirective,
  selectors: [["", "nbTreeGridCellDef", ""]],
  features: [ɵɵProvidersFeature([{
    provide: NbCdkCellDef,
    useExisting: _NbTreeGridCellDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbTreeGridCellDefDirective = _NbTreeGridCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridCellDef]",
      providers: [{
        provide: NbCdkCellDef,
        useExisting: NbTreeGridCellDefDirective
      }]
    }]
  }], null, null);
})();
var _NbTreeGridHeaderCellDefDirective = class _NbTreeGridHeaderCellDefDirective extends NbHeaderCellDefDirective {
};
_NbTreeGridHeaderCellDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbTreeGridHeaderCellDefDirective_BaseFactory;
  return function NbTreeGridHeaderCellDefDirective_Factory(t) {
    return (ɵNbTreeGridHeaderCellDefDirective_BaseFactory || (ɵNbTreeGridHeaderCellDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbTreeGridHeaderCellDefDirective)))(t || _NbTreeGridHeaderCellDefDirective);
  };
})();
_NbTreeGridHeaderCellDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridHeaderCellDefDirective,
  selectors: [["", "nbTreeGridHeaderCellDef", ""]],
  features: [ɵɵProvidersFeature([{
    provide: NbCdkHeaderCellDef,
    useExisting: _NbTreeGridHeaderCellDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbTreeGridHeaderCellDefDirective = _NbTreeGridHeaderCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridHeaderCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridHeaderCellDef]",
      providers: [{
        provide: NbCdkHeaderCellDef,
        useExisting: NbTreeGridHeaderCellDefDirective
      }]
    }]
  }], null, null);
})();
var _NbTreeGridFooterCellDefDirective = class _NbTreeGridFooterCellDefDirective extends NbFooterCellDefDirective {
};
_NbTreeGridFooterCellDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbTreeGridFooterCellDefDirective_BaseFactory;
  return function NbTreeGridFooterCellDefDirective_Factory(t) {
    return (ɵNbTreeGridFooterCellDefDirective_BaseFactory || (ɵNbTreeGridFooterCellDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbTreeGridFooterCellDefDirective)))(t || _NbTreeGridFooterCellDefDirective);
  };
})();
_NbTreeGridFooterCellDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridFooterCellDefDirective,
  selectors: [["", "nbTreeGridFooterCellDef", ""]],
  features: [ɵɵProvidersFeature([{
    provide: NbCdkFooterCellDef,
    useExisting: _NbTreeGridFooterCellDefDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbTreeGridFooterCellDefDirective = _NbTreeGridFooterCellDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFooterCellDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridFooterCellDef]",
      providers: [{
        provide: NbCdkFooterCellDef,
        useExisting: NbTreeGridFooterCellDefDirective
      }]
    }]
  }], null, null);
})();
var NB_ROW_DOUBLE_CLICK_DELAY = 200;
var _NbTreeGridRowComponent = class _NbTreeGridRowComponent extends NbRowComponent {
  toggleIfEnabledNode() {
    if (!this.clickToToggle) {
      return;
    }
    timer(NB_ROW_DOUBLE_CLICK_DELAY).pipe(take(1), takeUntil(this.doubleClick$)).subscribe(() => this.tree.toggleRow(this));
  }
  toggleIfEnabledNodeDeep() {
    if (!this.clickToToggle) {
      return;
    }
    this.doubleClick$.next();
    this.tree.toggleRow(this, {
      deep: true
    });
  }
  constructor(tree, elementRef) {
    super();
    this.elementRef = elementRef;
    this.doubleClick$ = new Subject();
    this.doubleClickDelay = NB_ROW_DOUBLE_CLICK_DELAY;
    this.clickToToggle = true;
    this.tree = tree;
  }
  ngOnDestroy() {
    this.doubleClick$.complete();
  }
};
_NbTreeGridRowComponent.ɵfac = function NbTreeGridRowComponent_Factory(t) {
  return new (t || _NbTreeGridRowComponent)(ɵɵdirectiveInject(NB_TREE_GRID), ɵɵdirectiveInject(ElementRef));
};
_NbTreeGridRowComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTreeGridRowComponent,
  selectors: [["tr", "nbTreeGridRow", ""]],
  hostAttrs: ["role", "row", 1, "nb-tree-grid-row"],
  hostBindings: function NbTreeGridRowComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbTreeGridRowComponent_click_HostBindingHandler() {
        return ctx.toggleIfEnabledNode();
      })("dblclick", function NbTreeGridRowComponent_dblclick_HostBindingHandler() {
        return ctx.toggleIfEnabledNodeDeep();
      });
    }
  },
  inputs: {
    doubleClickDelay: "doubleClickDelay",
    clickToToggle: "clickToToggle"
  },
  features: [ɵɵProvidersFeature([{
    provide: NbCdkRow,
    useExisting: _NbTreeGridRowComponent
  }]), ɵɵInheritDefinitionFeature],
  attrs: _c58,
  decls: 1,
  vars: 0,
  consts: [["nbCellOutlet", ""]],
  template: function NbTreeGridRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [NbCellOutletDirective],
  encapsulation: 2
});
var NbTreeGridRowComponent = _NbTreeGridRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridRowComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "tr[nbTreeGridRow]",
      template: `<ng-container nbCellOutlet></ng-container>`,
      // eslint-disable-next-line @angular-eslint/no-host-metadata-property
      host: {
        class: "nb-tree-grid-row",
        role: "row"
      },
      providers: [{
        provide: NbCdkRow,
        useExisting: NbTreeGridRowComponent
      }]
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TREE_GRID]
    }]
  }, {
    type: ElementRef
  }], {
    doubleClickDelay: [{
      type: Input
    }],
    clickToToggle: [{
      type: Input
    }],
    toggleIfEnabledNode: [{
      type: HostListener,
      args: ["click"]
    }],
    toggleIfEnabledNodeDeep: [{
      type: HostListener,
      args: ["dblclick"]
    }]
  });
})();
var _NbTreeGridHeaderRowComponent = class _NbTreeGridHeaderRowComponent extends NbHeaderRowComponent {
};
_NbTreeGridHeaderRowComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbTreeGridHeaderRowComponent_BaseFactory;
  return function NbTreeGridHeaderRowComponent_Factory(t) {
    return (ɵNbTreeGridHeaderRowComponent_BaseFactory || (ɵNbTreeGridHeaderRowComponent_BaseFactory = ɵɵgetInheritedFactory(_NbTreeGridHeaderRowComponent)))(t || _NbTreeGridHeaderRowComponent);
  };
})();
_NbTreeGridHeaderRowComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTreeGridHeaderRowComponent,
  selectors: [["tr", "nbTreeGridHeaderRow", ""]],
  hostAttrs: ["role", "row", 1, "nb-tree-grid-header-row"],
  features: [ɵɵProvidersFeature([{
    provide: NbCdkHeaderRow,
    useExisting: _NbTreeGridHeaderRowComponent
  }]), ɵɵInheritDefinitionFeature],
  attrs: _c59,
  decls: 1,
  vars: 0,
  consts: [["nbCellOutlet", ""]],
  template: function NbTreeGridHeaderRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [NbCellOutletDirective],
  encapsulation: 2
});
var NbTreeGridHeaderRowComponent = _NbTreeGridHeaderRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridHeaderRowComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "tr[nbTreeGridHeaderRow]",
      template: ` <ng-container nbCellOutlet></ng-container>`,
      // eslint-disable-next-line @angular-eslint/no-host-metadata-property
      host: {
        class: "nb-tree-grid-header-row",
        role: "row"
      },
      providers: [{
        provide: NbCdkHeaderRow,
        useExisting: NbTreeGridHeaderRowComponent
      }]
    }]
  }], null, null);
})();
var _NbTreeGridFooterRowComponent = class _NbTreeGridFooterRowComponent extends NbFooterRowComponent {
};
_NbTreeGridFooterRowComponent.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbTreeGridFooterRowComponent_BaseFactory;
  return function NbTreeGridFooterRowComponent_Factory(t) {
    return (ɵNbTreeGridFooterRowComponent_BaseFactory || (ɵNbTreeGridFooterRowComponent_BaseFactory = ɵɵgetInheritedFactory(_NbTreeGridFooterRowComponent)))(t || _NbTreeGridFooterRowComponent);
  };
})();
_NbTreeGridFooterRowComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTreeGridFooterRowComponent,
  selectors: [["tr", "nbTreeGridFooterRow", ""]],
  hostAttrs: ["role", "row", 1, "nb-tree-grid-footer-row"],
  features: [ɵɵProvidersFeature([{
    provide: NbCdkFooterRow,
    useExisting: _NbTreeGridFooterRowComponent
  }]), ɵɵInheritDefinitionFeature],
  attrs: _c60,
  decls: 1,
  vars: 0,
  consts: [["nbCellOutlet", ""]],
  template: function NbTreeGridFooterRowComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [NbCellOutletDirective],
  encapsulation: 2
});
var NbTreeGridFooterRowComponent = _NbTreeGridFooterRowComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFooterRowComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "tr[nbTreeGridFooterRow]",
      template: ` <ng-container nbCellOutlet></ng-container>`,
      // eslint-disable-next-line @angular-eslint/no-host-metadata-property
      host: {
        class: "nb-tree-grid-footer-row",
        role: "row"
      },
      providers: [{
        provide: NbCdkFooterRow,
        useExisting: NbTreeGridFooterRowComponent
      }]
    }]
  }], null, null);
})();
var _NbTreeGridColumnDefDirective = class _NbTreeGridColumnDefDirective extends NbColumnDefDirective {
  constructor() {
    super(...arguments);
    this.hideOnValue = null;
    this.showOnValue = null;
  }
  /**
   * Column name
   */
  get name() {
    return this._name;
  }
  set name(value) {
    this._setNameInput(value);
  }
  /**
   * Amount of pixels of viewport at which column should be hidden.
   * type number
   */
  get hideOn() {
    return this.hideOnValue;
  }
  set hideOn(value) {
    this.hideOnValue = !value && value !== 0 ? null : parseInt(value, 10);
  }
  /**
   * Amount of pixels of viewport at which column should be shown.
   * type number
   */
  get showOn() {
    return this.showOnValue;
  }
  set showOn(value) {
    this.showOnValue = !value && value !== 0 ? null : parseInt(value, 10);
  }
  ngOnChanges() {
    if (this.hideOn != null && this.showOn != null) {
      throw new Error(`hideOn and showOn are mutually exclusive and can't be used simultaneously.`);
    }
  }
  shouldHide(width) {
    return !this.shouldShow(width);
  }
  shouldShow(width) {
    if (this.hideOn == null && this.showOn == null) {
      return true;
    }
    if (this.hideOn != null) {
      return width > this.hideOn;
    }
    return width >= this.showOn;
  }
};
_NbTreeGridColumnDefDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbTreeGridColumnDefDirective_BaseFactory;
  return function NbTreeGridColumnDefDirective_Factory(t) {
    return (ɵNbTreeGridColumnDefDirective_BaseFactory || (ɵNbTreeGridColumnDefDirective_BaseFactory = ɵɵgetInheritedFactory(_NbTreeGridColumnDefDirective)))(t || _NbTreeGridColumnDefDirective);
  };
})();
_NbTreeGridColumnDefDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridColumnDefDirective,
  selectors: [["", "nbTreeGridColumnDef", ""]],
  inputs: {
    name: [InputFlags.None, "nbTreeGridColumnDef", "name"],
    hideOn: "hideOn",
    showOn: "showOn"
  },
  features: [ɵɵProvidersFeature([{
    provide: NbCdkColumnDef,
    useExisting: _NbTreeGridColumnDefDirective
  }, {
    provide: NB_SORT_HEADER_COLUMN_DEF,
    useExisting: _NbTreeGridColumnDefDirective
  }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
var NbTreeGridColumnDefDirective = _NbTreeGridColumnDefDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridColumnDefDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridColumnDef]",
      providers: [{
        provide: NbCdkColumnDef,
        useExisting: NbTreeGridColumnDefDirective
      }, {
        provide: NB_SORT_HEADER_COLUMN_DEF,
        useExisting: NbTreeGridColumnDefDirective
      }]
    }]
  }], null, {
    name: [{
      type: Input,
      args: ["nbTreeGridColumnDef"]
    }],
    hideOn: [{
      type: Input
    }],
    showOn: [{
      type: Input
    }]
  });
})();
var _NbTreeGridCellDirective = class _NbTreeGridCellDirective extends NbCellDirective {
  get columnWidth() {
    this.latestWidth = this.tree.getColumnWidth();
    if (this.latestWidth) {
      return this.latestWidth;
    }
    return null;
  }
  get leftPadding() {
    if (this.directionService.isLtr()) {
      return this.getStartPadding();
    }
    return null;
  }
  get rightPadding() {
    if (this.directionService.isRtl()) {
      return this.getStartPadding();
    }
    return null;
  }
  constructor(columnDef, elementRef, tree, platformId, window2, sanitizer, directionService, columnService, cd) {
    super(columnDef, elementRef);
    this.platformId = platformId;
    this.window = window2;
    this.sanitizer = sanitizer;
    this.directionService = directionService;
    this.columnService = columnService;
    this.cd = cd;
    this.destroy$ = new Subject();
    this.initialLeftPadding = "";
    this.initialRightPadding = "";
    this.tree = tree;
    this.columnDef = columnDef;
    this.elementRef = elementRef;
  }
  ngOnInit() {
    if (isPlatformBrowser(this.platformId)) {
      const style2 = this.window.getComputedStyle(this.elementRef.nativeElement);
      this.initialLeftPadding = style2.paddingLeft;
      this.initialRightPadding = style2.paddingRight;
    }
    this.columnService.onColumnsChange().pipe(filter(() => this.latestWidth !== this.tree.getColumnWidth()), takeUntil(this.destroy$)).subscribe(() => this.cd.detectChanges());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  toggleRow() {
    this.tree.toggleCellRow(this);
  }
  get initialStartPadding() {
    return this.directionService.isLtr() ? this.initialLeftPadding : this.initialRightPadding;
  }
  getStartPadding() {
    const rowLevel = this.tree.getCellLevel(this, this.columnDef.name);
    if (rowLevel === NB_DEFAULT_ROW_LEVEL) {
      return null;
    }
    const nestingLevel = rowLevel + 1;
    let padding = "";
    if (this.tree.levelPadding) {
      padding = `calc(${this.tree.levelPadding} * ${nestingLevel})`;
    } else if (this.initialStartPadding) {
      padding = `calc(${this.initialStartPadding} * ${nestingLevel})`;
    }
    if (!padding) {
      return null;
    }
    return this.sanitizer.bypassSecurityTrustStyle(padding);
  }
};
_NbTreeGridCellDirective.ɵfac = function NbTreeGridCellDirective_Factory(t) {
  return new (t || _NbTreeGridCellDirective)(ɵɵdirectiveInject(NbTreeGridColumnDefDirective), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NB_TREE_GRID), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(NB_WINDOW), ɵɵdirectiveInject(DomSanitizer), ɵɵdirectiveInject(NbLayoutDirectionService), ɵɵdirectiveInject(NbColumnsService), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbTreeGridCellDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridCellDirective,
  selectors: [["td", "nbTreeGridCell", ""]],
  hostAttrs: ["role", "gridcell", 1, "nb-tree-grid-cell"],
  hostVars: 6,
  hostBindings: function NbTreeGridCellDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵstyleProp("width", ctx.columnWidth)("padding-left", ctx.leftPadding)("padding-right", ctx.rightPadding);
    }
  },
  features: [ɵɵProvidersFeature([{
    provide: NbCdkCell,
    useExisting: _NbTreeGridCellDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbTreeGridCellDirective = _NbTreeGridCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridCellDirective, [{
    type: Directive,
    args: [{
      selector: "td[nbTreeGridCell]",
      host: {
        "class": "nb-tree-grid-cell",
        "role": "gridcell"
      },
      providers: [{
        provide: NbCdkCell,
        useExisting: NbTreeGridCellDirective
      }]
    }]
  }], () => [{
    type: NbTreeGridColumnDefDirective
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TREE_GRID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_WINDOW]
    }]
  }, {
    type: DomSanitizer
  }, {
    type: NbLayoutDirectionService
  }, {
    type: NbColumnsService
  }, {
    type: ChangeDetectorRef
  }], {
    columnWidth: [{
      type: HostBinding,
      args: ["style.width"]
    }],
    leftPadding: [{
      type: HostBinding,
      args: ["style.padding-left"]
    }],
    rightPadding: [{
      type: HostBinding,
      args: ["style.padding-right"]
    }]
  });
})();
var _NbTreeGridHeaderCellDirective = class _NbTreeGridHeaderCellDirective extends NbHeaderCellDirective {
  get columnWidth() {
    this.latestWidth = this.tree.getColumnWidth();
    return this.latestWidth || null;
  }
  constructor(columnDef, elementRef, tree, columnService, cd) {
    super(columnDef, elementRef);
    this.columnService = columnService;
    this.cd = cd;
    this.destroy$ = new Subject();
    this.tree = tree;
  }
  ngOnInit() {
    this.columnService.onColumnsChange().pipe(filter(() => this.latestWidth !== this.tree.getColumnWidth()), takeUntil(this.destroy$)).subscribe(() => this.cd.detectChanges());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NbTreeGridHeaderCellDirective.ɵfac = function NbTreeGridHeaderCellDirective_Factory(t) {
  return new (t || _NbTreeGridHeaderCellDirective)(ɵɵdirectiveInject(NbTreeGridColumnDefDirective), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NB_TREE_GRID), ɵɵdirectiveInject(NbColumnsService), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbTreeGridHeaderCellDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridHeaderCellDirective,
  selectors: [["th", "nbTreeGridHeaderCell", ""]],
  hostAttrs: ["role", "columnheader", 1, "nb-tree-grid-header-cell"],
  hostVars: 2,
  hostBindings: function NbTreeGridHeaderCellDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵstyleProp("width", ctx.columnWidth);
    }
  },
  features: [ɵɵProvidersFeature([{
    provide: NbCdkHeaderCell,
    useExisting: _NbTreeGridHeaderCellDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbTreeGridHeaderCellDirective = _NbTreeGridHeaderCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridHeaderCellDirective, [{
    type: Directive,
    args: [{
      selector: "th[nbTreeGridHeaderCell]",
      host: {
        "class": "nb-tree-grid-header-cell",
        "role": "columnheader"
      },
      providers: [{
        provide: NbCdkHeaderCell,
        useExisting: NbTreeGridHeaderCellDirective
      }]
    }]
  }], () => [{
    type: NbTreeGridColumnDefDirective
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TREE_GRID]
    }]
  }, {
    type: NbColumnsService
  }, {
    type: ChangeDetectorRef
  }], {
    columnWidth: [{
      type: HostBinding,
      args: ["style.width"]
    }]
  });
})();
var _NbTreeGridFooterCellDirective = class _NbTreeGridFooterCellDirective extends NbFooterCellDirective {
  get columnWidth() {
    this.latestWidth = this.tree.getColumnWidth();
    return this.latestWidth || null;
  }
  constructor(columnDef, elementRef, tree, columnService, cd) {
    super(columnDef, elementRef);
    this.columnService = columnService;
    this.cd = cd;
    this.destroy$ = new Subject();
    this.tree = tree;
  }
  ngOnInit() {
    this.columnService.onColumnsChange().pipe(filter(() => this.latestWidth !== this.tree.getColumnWidth()), takeUntil(this.destroy$)).subscribe(() => this.cd.detectChanges());
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
};
_NbTreeGridFooterCellDirective.ɵfac = function NbTreeGridFooterCellDirective_Factory(t) {
  return new (t || _NbTreeGridFooterCellDirective)(ɵɵdirectiveInject(NbTreeGridColumnDefDirective), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NB_TREE_GRID), ɵɵdirectiveInject(NbColumnsService), ɵɵdirectiveInject(ChangeDetectorRef));
};
_NbTreeGridFooterCellDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridFooterCellDirective,
  selectors: [["td", "nbTreeGridFooterCell", ""]],
  hostAttrs: ["role", "gridcell", 1, "nb-tree-grid-footer-cell"],
  hostVars: 2,
  hostBindings: function NbTreeGridFooterCellDirective_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵstyleProp("width", ctx.columnWidth);
    }
  },
  features: [ɵɵProvidersFeature([{
    provide: NbCdkFooterCell,
    useExisting: _NbTreeGridFooterCellDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbTreeGridFooterCellDirective = _NbTreeGridFooterCellDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridFooterCellDirective, [{
    type: Directive,
    args: [{
      selector: "td[nbTreeGridFooterCell]",
      host: {
        "class": "nb-tree-grid-footer-cell",
        "role": "gridcell"
      },
      providers: [{
        provide: NbCdkFooterCell,
        useExisting: NbTreeGridFooterCellDirective
      }]
    }]
  }], () => [{
    type: NbTreeGridColumnDefDirective
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [NB_TREE_GRID]
    }]
  }, {
    type: NbColumnsService
  }, {
    type: ChangeDetectorRef
  }], {
    columnWidth: [{
      type: HostBinding,
      args: ["style.width"]
    }]
  });
})();
var _NbFilterDirective = class _NbFilterDirective {
  filter(filterRequest) {
    this.filterable.filter(filterRequest);
  }
};
_NbFilterDirective.ɵfac = function NbFilterDirective_Factory(t) {
  return new (t || _NbFilterDirective)();
};
_NbFilterDirective.ɵdir = ɵɵdefineDirective({
  type: _NbFilterDirective,
  selectors: [["", "nbFilter", ""]],
  inputs: {
    filterable: [InputFlags.None, "nbFilter", "filterable"]
  }
});
var NbFilterDirective = _NbFilterDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFilterDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFilter]"
    }]
  }], null, {
    filterable: [{
      type: Input,
      args: ["nbFilter"]
    }]
  });
})();
var _NbFilterInputDirective = class _NbFilterInputDirective extends NbFilterDirective {
  constructor() {
    super(...arguments);
    this.search$ = new Subject();
    this.destroy$ = new Subject();
    this.debounceTime = 200;
  }
  ngOnInit() {
    this.search$.pipe(debounceTime(this.debounceTime), takeUntil(this.destroy$)).subscribe((query) => {
      super.filter(query);
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    this.search$.complete();
  }
  filter(event) {
    this.search$.next(event.target.value);
  }
};
_NbFilterInputDirective.ɵfac = /* @__PURE__ */ (() => {
  let ɵNbFilterInputDirective_BaseFactory;
  return function NbFilterInputDirective_Factory(t) {
    return (ɵNbFilterInputDirective_BaseFactory || (ɵNbFilterInputDirective_BaseFactory = ɵɵgetInheritedFactory(_NbFilterInputDirective)))(t || _NbFilterInputDirective);
  };
})();
_NbFilterInputDirective.ɵdir = ɵɵdefineDirective({
  type: _NbFilterInputDirective,
  selectors: [["", "nbFilterInput", ""]],
  hostBindings: function NbFilterInputDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("input", function NbFilterInputDirective_input_HostBindingHandler($event) {
        return ctx.filter($event);
      });
    }
  },
  inputs: {
    filterable: [InputFlags.None, "nbFilterInput", "filterable"],
    debounceTime: "debounceTime"
  },
  features: [ɵɵProvidersFeature([{
    provide: NbFilterDirective,
    useExisting: _NbFilterInputDirective
  }]), ɵɵInheritDefinitionFeature]
});
var NbFilterInputDirective = _NbFilterInputDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbFilterInputDirective, [{
    type: Directive,
    args: [{
      selector: "[nbFilterInput]",
      providers: [{
        provide: NbFilterDirective,
        useExisting: NbFilterInputDirective
      }]
    }]
  }], null, {
    filterable: [{
      type: Input,
      args: ["nbFilterInput"]
    }],
    debounceTime: [{
      type: Input
    }],
    filter: [{
      type: HostListener,
      args: ["input", ["$event"]]
    }]
  });
})();
var _NbTreeGridRowToggleDirective = class _NbTreeGridRowToggleDirective {
  toggleRow($event) {
    this.cell.toggleRow();
    $event.stopPropagation();
  }
  constructor(cell) {
    this.cell = cell;
  }
};
_NbTreeGridRowToggleDirective.ɵfac = function NbTreeGridRowToggleDirective_Factory(t) {
  return new (t || _NbTreeGridRowToggleDirective)(ɵɵdirectiveInject(NbTreeGridCellDirective));
};
_NbTreeGridRowToggleDirective.ɵdir = ɵɵdefineDirective({
  type: _NbTreeGridRowToggleDirective,
  selectors: [["", "nbTreeGridRowToggle", ""]],
  hostBindings: function NbTreeGridRowToggleDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbTreeGridRowToggleDirective_click_HostBindingHandler($event) {
        return ctx.toggleRow($event);
      });
    }
  }
});
var NbTreeGridRowToggleDirective = _NbTreeGridRowToggleDirective;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridRowToggleDirective, [{
    type: Directive,
    args: [{
      selector: "[nbTreeGridRowToggle]"
    }]
  }], () => [{
    type: NbTreeGridCellDirective
  }], {
    toggleRow: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var _NbTreeGridRowToggleComponent = class _NbTreeGridRowToggleComponent {
  set expanded(value) {
    this.expandedValue = value;
  }
  get expanded() {
    return this.expandedValue;
  }
  toggleRow($event) {
    this.cell.toggleRow();
    $event.stopPropagation();
  }
  constructor(cell) {
    this.cell = cell;
  }
};
_NbTreeGridRowToggleComponent.ɵfac = function NbTreeGridRowToggleComponent_Factory(t) {
  return new (t || _NbTreeGridRowToggleComponent)(ɵɵdirectiveInject(NbTreeGridCellDirective));
};
_NbTreeGridRowToggleComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbTreeGridRowToggleComponent,
  selectors: [["nb-tree-grid-row-toggle"]],
  hostBindings: function NbTreeGridRowToggleComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function NbTreeGridRowToggleComponent_click_HostBindingHandler($event) {
        return ctx.toggleRow($event);
      });
    }
  },
  inputs: {
    expanded: "expanded"
  },
  decls: 2,
  vars: 2,
  consts: [[1, "row-toggle-button"], ["pack", "nebular-essentials", "aria-hidden", "true", 3, "icon"]],
  template: function NbTreeGridRowToggleComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "button", 0);
      ɵɵelement(1, "nb-icon", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵattribute("aria-label", ctx.expanded ? "collapse" : "expand");
      ɵɵadvance();
      ɵɵproperty("icon", ctx.expanded ? "chevron-down-outline" : "chevron-right-outline");
    }
  },
  dependencies: [NbIconComponent],
  styles: ["button[_ngcontent-%COMP%]{background:transparent;border:none;padding:0}"]
});
var NbTreeGridRowToggleComponent = _NbTreeGridRowToggleComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridRowToggleComponent, [{
    type: Component,
    args: [{
      selector: "nb-tree-grid-row-toggle",
      template: `
    <button class="row-toggle-button" [attr.aria-label]="expanded ? 'collapse' : 'expand'">
      <nb-icon [icon]="expanded ? 'chevron-down-outline' : 'chevron-right-outline'"
               pack="nebular-essentials"
               aria-hidden="true">
      </nb-icon>
    </button>
  `,
      styles: ["button{background:transparent;border:none;padding:0}\n"]
    }]
  }], () => [{
    type: NbTreeGridCellDirective
  }], {
    expanded: [{
      type: Input
    }],
    toggleRow: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var COMPONENTS = [
  // Tree Grid
  NbTreeGridComponent,
  NbTreeGridRowDefDirective,
  NbTreeGridRowComponent,
  NbTreeGridCellDefDirective,
  NbTreeGridCellDirective,
  NbTreeGridHeaderRowDefDirective,
  NbTreeGridHeaderRowComponent,
  NbTreeGridHeaderCellDefDirective,
  NbTreeGridHeaderCellDirective,
  NbTreeGridFooterRowDefDirective,
  NbTreeGridFooterRowComponent,
  NbTreeGridFooterCellDefDirective,
  NbTreeGridFooterCellDirective,
  NbTreeGridColumnDefDirective,
  // Sort directives
  NbSortDirective,
  NbSortHeaderComponent,
  NbSortIconComponent,
  // Filter directives
  NbFilterDirective,
  NbFilterInputDirective,
  NbTreeGridRowToggleDirective,
  NbTreeGridRowToggleComponent,
  NbSortHeaderIconDirective
];
var _NbTreeGridModule = class _NbTreeGridModule {
};
_NbTreeGridModule.ɵfac = function NbTreeGridModule_Factory(t) {
  return new (t || _NbTreeGridModule)();
};
_NbTreeGridModule.ɵmod = ɵɵdefineNgModule({
  type: _NbTreeGridModule,
  declarations: [
    // Tree Grid
    NbTreeGridComponent,
    NbTreeGridRowDefDirective,
    NbTreeGridRowComponent,
    NbTreeGridCellDefDirective,
    NbTreeGridCellDirective,
    NbTreeGridHeaderRowDefDirective,
    NbTreeGridHeaderRowComponent,
    NbTreeGridHeaderCellDefDirective,
    NbTreeGridHeaderCellDirective,
    NbTreeGridFooterRowDefDirective,
    NbTreeGridFooterRowComponent,
    NbTreeGridFooterCellDefDirective,
    NbTreeGridFooterCellDirective,
    NbTreeGridColumnDefDirective,
    // Sort directives
    NbSortDirective,
    NbSortHeaderComponent,
    NbSortIconComponent,
    // Filter directives
    NbFilterDirective,
    NbFilterInputDirective,
    NbTreeGridRowToggleDirective,
    NbTreeGridRowToggleComponent,
    NbSortHeaderIconDirective
  ],
  imports: [CommonModule, NbTableModule, NbIconModule],
  exports: [
    NbTableModule,
    // Tree Grid
    NbTreeGridComponent,
    NbTreeGridRowDefDirective,
    NbTreeGridRowComponent,
    NbTreeGridCellDefDirective,
    NbTreeGridCellDirective,
    NbTreeGridHeaderRowDefDirective,
    NbTreeGridHeaderRowComponent,
    NbTreeGridHeaderCellDefDirective,
    NbTreeGridHeaderCellDirective,
    NbTreeGridFooterRowDefDirective,
    NbTreeGridFooterRowComponent,
    NbTreeGridFooterCellDefDirective,
    NbTreeGridFooterCellDirective,
    NbTreeGridColumnDefDirective,
    // Sort directives
    NbSortDirective,
    NbSortHeaderComponent,
    NbSortIconComponent,
    // Filter directives
    NbFilterDirective,
    NbFilterInputDirective,
    NbTreeGridRowToggleDirective,
    NbTreeGridRowToggleComponent,
    NbSortHeaderIconDirective
  ]
});
_NbTreeGridModule.ɵinj = ɵɵdefineInjector({
  providers: [NbTreeGridSortService, NbTreeGridFilterService, NbTreeGridService, NbTreeGridDataService, NbTreeGridDataSourceBuilder],
  imports: [CommonModule, NbTableModule, NbIconModule, NbTableModule]
});
var NbTreeGridModule = _NbTreeGridModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbTreeGridModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbTableModule, NbIconModule],
      declarations: [...COMPONENTS],
      exports: [NbTableModule, ...COMPONENTS],
      providers: [NbTreeGridSortService, NbTreeGridFilterService, NbTreeGridService, NbTreeGridDataService, NbTreeGridDataSourceBuilder]
    }]
  }], null, null);
})();
var _NbToggleComponent = class _NbToggleComponent {
  /**
   * Toggle checked
   * @type {boolean}
   */
  get checked() {
    return this._checked;
  }
  set checked(value) {
    this._checked = convertToBoolProperty(value);
  }
  /**
   * Controls input disabled state
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = convertToBoolProperty(value);
  }
  get primary() {
    return this.status === "primary";
  }
  get success() {
    return this.status === "success";
  }
  get warning() {
    return this.status === "warning";
  }
  get danger() {
    return this.status === "danger";
  }
  get info() {
    return this.status === "info";
  }
  get basic() {
    return this.status === "basic";
  }
  get control() {
    return this.status === "control";
  }
  get additionalClasses() {
    if (this.statusService.isCustomStatus(this.status)) {
      return [this.statusService.getStatusClass(this.status)];
    }
    return [];
  }
  get labelLeft() {
    return this.labelPosition === "left";
  }
  get labelRight() {
    return this.labelPosition === "right";
  }
  get labelStart() {
    return this.labelPosition === "start";
  }
  get labelEnd() {
    return this.labelPosition === "end";
  }
  constructor(changeDetector, layoutDirection, renderer, hostElement, zone, statusService) {
    this.changeDetector = changeDetector;
    this.layoutDirection = layoutDirection;
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.zone = zone;
    this.statusService = statusService;
    this.onChange = () => {
    };
    this.onTouched = () => {
    };
    this.destroy$ = new Subject();
    this._checked = false;
    this._disabled = false;
    this.status = "basic";
    this.labelPosition = "end";
    this.checkedChange = new EventEmitter();
  }
  ngOnInit() {
    this.layoutDirection.onDirectionChange().pipe(takeUntil(this.destroy$)).subscribe(() => this.changeDetector.detectChanges());
  }
  ngAfterViewInit() {
    this.zone.runOutsideAngular(() => setTimeout(() => {
      this.renderer.addClass(this.hostElement.nativeElement, "nb-transition");
    }));
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  checkState() {
    if (this.checked) {
      return this.layoutDirection.isLtr() ? "right" : "left";
    }
    return this.layoutDirection.isLtr() ? "left" : "right";
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  writeValue(val) {
    this.checked = val;
    this.changeDetector.markForCheck();
  }
  setDisabledState(val) {
    this.disabled = convertToBoolProperty(val);
    this.changeDetector.markForCheck();
  }
  updateValue(event) {
    const input = event.target;
    this.checked = input.checked;
    this.checkedChange.emit(this.checked);
    this.onChange(this.checked);
  }
  onInputClick(event) {
    event.stopPropagation();
  }
};
_NbToggleComponent.ɵfac = function NbToggleComponent_Factory(t) {
  return new (t || _NbToggleComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NbLayoutDirectionService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(NbStatusService));
};
_NbToggleComponent.ɵcmp = ɵɵdefineComponent({
  type: _NbToggleComponent,
  selectors: [["nb-toggle"]],
  hostVars: 24,
  hostBindings: function NbToggleComponent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassMap(ctx.additionalClasses);
      ɵɵclassProp("status-primary", ctx.primary)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-info", ctx.info)("status-basic", ctx.basic)("status-control", ctx.control)("toggle-label-left", ctx.labelLeft)("toggle-label-right", ctx.labelRight)("toggle-label-start", ctx.labelStart)("toggle-label-end", ctx.labelEnd);
    }
  },
  inputs: {
    checked: "checked",
    disabled: "disabled",
    status: "status",
    labelPosition: "labelPosition"
  },
  outputs: {
    checkedChange: "checkedChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => _NbToggleComponent),
    multi: true
  }])],
  ngContentSelectors: _c02,
  decls: 7,
  vars: 7,
  consts: [[1, "toggle-label"], ["type", "checkbox", "role", "switch", 1, "native-input", "visually-hidden", 3, "disabled", "checked", "change", "blur", "click"], [1, "toggle"], [1, "toggle-switcher"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials", 4, "ngIf"], [1, "text"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials"]],
  template: function NbToggleComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "label", 0)(1, "input", 1);
      ɵɵlistener("change", function NbToggleComponent_Template_input_change_1_listener($event) {
        return ctx.updateValue($event);
      })("blur", function NbToggleComponent_Template_input_blur_1_listener() {
        return ctx.onTouched();
      })("click", function NbToggleComponent_Template_input_click_1_listener($event) {
        return ctx.onInputClick($event);
      });
      ɵɵelementEnd();
      ɵɵelementStart(2, "div", 2)(3, "span", 3);
      ɵɵtemplate(4, NbToggleComponent_nb_icon_4_Template, 1, 0, "nb-icon", 4);
      ɵɵelementEnd()();
      ɵɵelementStart(5, "span", 5);
      ɵɵprojection(6);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("disabled", ctx.disabled)("checked", ctx.checked);
      ɵɵattribute("aria-checked", ctx.checked);
      ɵɵadvance();
      ɵɵclassProp("checked", ctx.checked);
      ɵɵadvance();
      ɵɵproperty("@position", ctx.checkState());
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.checked);
    }
  },
  dependencies: [NgIf, NbIconComponent],
  styles: ["\n\n\n\n\n[_nghost-%COMP%]{display:inline-flex;outline:none}.toggle-label-left[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-right:.6875rem}[dir=ltr]   .toggle-label-left[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:-1}[dir=rtl]   .toggle-label-left[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:1}.toggle-label-right[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-left:.6875rem}[dir=ltr]   .toggle-label-right[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:1}[dir=rtl]   .toggle-label-right[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:-1}.toggle-label-start[_nghost-%COMP%]   .toggle-label[_ngcontent-%COMP%]{flex-direction:row-reverse}[dir=ltr]   .toggle-label-start[_nghost-%COMP%]   .toggle-label[_ngcontent-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-right:.6875rem}[dir=rtl]   .toggle-label-start[_nghost-%COMP%]   .toggle-label[_ngcontent-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-left:.6875rem}[dir=ltr]   .toggle-label-end[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-left:.6875rem}[dir=rtl]   .toggle-label-end[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-right:.6875rem}.nb-transition[_nghost-%COMP%]   .toggle[_ngcontent-%COMP%]{transition-duration:.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}.toggle-label[_ngcontent-%COMP%]{position:relative;display:inline-flex;align-items:center}.toggle[_ngcontent-%COMP%]{position:relative;display:inline-flex;box-sizing:content-box}.toggle-switcher[_ngcontent-%COMP%]{position:absolute;border-radius:50%;margin:1px}.toggle-switcher[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}"],
  data: {
    animation: [trigger("position", [state("right", style({
      right: 0,
      left: "*"
    })), state("left", style({
      left: 0,
      right: "*"
    })), transition(":enter", [animate(0)]), transition("right <=> left", [animate("0.15s")])])]
  },
  changeDetection: 0
});
var NbToggleComponent = _NbToggleComponent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToggleComponent, [{
    type: Component,
    args: [{
      selector: "nb-toggle",
      animations: [trigger("position", [state("right", style({
        right: 0,
        left: "*"
      })), state("left", style({
        left: 0,
        right: "*"
      })), transition(":enter", [animate(0)]), transition("right <=> left", [animate("0.15s")])])],
      template: `
    <label class="toggle-label">
      <input type="checkbox"
             class="native-input visually-hidden"
             role="switch"
             [attr.aria-checked]="checked"
             [disabled]="disabled"
             [checked]="checked"
             (change)="updateValue($event)"
             (blur)="onTouched()"
             (click)="onInputClick($event)">
      <div class="toggle" [class.checked]="checked">
        <span [@position]="checkState()" class="toggle-switcher">
          <nb-icon *ngIf="checked" icon="checkmark-bold-outline" pack="nebular-essentials"></nb-icon>
        </span>
      </div>
      <span class="text">
        <ng-content></ng-content>
      </span>
    </label>
  `,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NbToggleComponent),
        multi: true
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ["/**\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:inline-flex;outline:none}:host(.toggle-label-left) .text:not(:empty){padding-right:.6875rem}[dir=ltr] :host(.toggle-label-left) .text:not(:empty){order:-1}[dir=rtl] :host(.toggle-label-left) .text:not(:empty){order:1}:host(.toggle-label-right) .text:not(:empty){padding-left:.6875rem}[dir=ltr] :host(.toggle-label-right) .text:not(:empty){order:1}[dir=rtl] :host(.toggle-label-right) .text:not(:empty){order:-1}:host(.toggle-label-start) .toggle-label{flex-direction:row-reverse}[dir=ltr] :host(.toggle-label-start) .toggle-label .text:not(:empty){padding-right:.6875rem}[dir=rtl] :host(.toggle-label-start) .toggle-label .text:not(:empty){padding-left:.6875rem}[dir=ltr] :host(.toggle-label-end) .text:not(:empty){padding-left:.6875rem}[dir=rtl] :host(.toggle-label-end) .text:not(:empty){padding-right:.6875rem}:host(.nb-transition) .toggle{transition-duration:.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}.toggle-label{position:relative;display:inline-flex;align-items:center}.toggle{position:relative;display:inline-flex;box-sizing:content-box}.toggle-switcher{position:absolute;border-radius:50%;margin:1px}.toggle-switcher nb-icon{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}\n"]
    }]
  }], () => [{
    type: ChangeDetectorRef
  }, {
    type: NbLayoutDirectionService
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: NgZone
  }, {
    type: NbStatusService
  }], {
    checked: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    status: [{
      type: Input
    }],
    labelPosition: [{
      type: Input
    }],
    checkedChange: [{
      type: Output
    }],
    primary: [{
      type: HostBinding,
      args: ["class.status-primary"]
    }],
    success: [{
      type: HostBinding,
      args: ["class.status-success"]
    }],
    warning: [{
      type: HostBinding,
      args: ["class.status-warning"]
    }],
    danger: [{
      type: HostBinding,
      args: ["class.status-danger"]
    }],
    info: [{
      type: HostBinding,
      args: ["class.status-info"]
    }],
    basic: [{
      type: HostBinding,
      args: ["class.status-basic"]
    }],
    control: [{
      type: HostBinding,
      args: ["class.status-control"]
    }],
    additionalClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    labelLeft: [{
      type: HostBinding,
      args: ["class.toggle-label-left"]
    }],
    labelRight: [{
      type: HostBinding,
      args: ["class.toggle-label-right"]
    }],
    labelStart: [{
      type: HostBinding,
      args: ["class.toggle-label-start"]
    }],
    labelEnd: [{
      type: HostBinding,
      args: ["class.toggle-label-end"]
    }]
  });
})();
var _NbToggleModule = class _NbToggleModule {
};
_NbToggleModule.ɵfac = function NbToggleModule_Factory(t) {
  return new (t || _NbToggleModule)();
};
_NbToggleModule.ɵmod = ɵɵdefineNgModule({
  type: _NbToggleModule,
  declarations: [NbToggleComponent],
  imports: [CommonModule, NbIconModule],
  exports: [NbToggleComponent]
});
_NbToggleModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, NbIconModule]
});
var NbToggleModule = _NbToggleModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NbToggleModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, NbIconModule],
      declarations: [NbToggleComponent],
      exports: [NbToggleComponent]
    }]
  }], null, null);
})();

export {
  NB_THEME_OPTIONS,
  NB_MEDIA_BREAKPOINTS,
  NB_BUILT_IN_JS_THEMES,
  NB_JS_THEMES,
  NB_WINDOW,
  NB_DOCUMENT,
  DEFAULT_MEDIA_BREAKPOINTS,
  NbMediaBreakpointsService,
  DEFAULT_THEME,
  COSMIC_THEME,
  CORPORATE_THEME,
  DARK_THEME,
  BUILT_IN_THEMES,
  NbJSThemesRegistry,
  NbThemeService,
  NbSpinnerService,
  NbLayoutDirection,
  NB_LAYOUT_DIRECTION,
  NbLayoutDirectionService,
  NbLayoutScrollService,
  NbLayoutRulerService,
  NbFocusTrap,
  NbFocusTrapFactoryService,
  NbFocusKeyManager,
  NbFocusKeyManagerFactoryService,
  NbFocusMonitor,
  NbA11yModule,
  NbPortalDirective,
  NbPortalOutletDirective,
  NbComponentPortal,
  NbOverlay,
  NbOverlayPositionBuilder,
  NbTemplatePortal,
  NbOverlayContainer,
  NbFlexibleConnectedPositionStrategy,
  NbPortalInjector,
  NbCdkMappingModule,
  NbGlobalLogicalPosition,
  NbGlobalPhysicalPosition,
  NbPositionHelper,
  NbPlatform,
  NbViewportRulerAdapter,
  NbOverlayContainerAdapter,
  NbAdjustment,
  NbPosition,
  NbAdjustableConnectedPositionStrategy,
  NbGlobalPositionStrategy,
  NbPositionBuilderService,
  NbPositionedContainerComponent,
  NbOverlayContainerComponent,
  patch,
  createContainer,
  NbOverlayService,
  NbScrollDispatcherAdapter,
  NbBlockScrollStrategyAdapter,
  NbScrollStrategyOptions,
  NbCdkAdapterModule,
  NbTrigger,
  NbTriggerStrategyBase,
  NbClickTriggerStrategy,
  NbHoverTriggerStrategy,
  NbHintTriggerStrategy,
  NbFocusTriggerStrategy,
  NbNoopTriggerStrategy,
  NbTriggerStrategyBuilderService,
  NbOverlayModule,
  NbStatusService,
  windowFactory,
  NbThemeModule,
  NbColorHelper,
  NbIconPackType,
  NbFontIcon,
  NbSvgIcon,
  NbIconDefinition,
  NbIconLibraries,
  NbIconComponent,
  NbIconModule,
  NbCardHeaderComponent,
  NbCardBodyComponent,
  NbCardFooterComponent,
  NbCardComponent,
  NbRevealCardComponent,
  NbFlipCardComponent,
  NbCardFrontComponent,
  NbCardBackComponent,
  NbCardModule,
  NbCalendarViewMode,
  NbCalendarSize,
  NbDateService,
  NbCalendarYearModelService,
  NbButton,
  NbButtonComponent,
  NbCalendarViewModeComponent,
  NbCalendarPageableNavigationComponent,
  NbCalendarYearCellComponent,
  NbCalendarPickerRowComponent,
  NbCalendarPickerComponent,
  NbCalendarYearPickerComponent,
  NbCalendarMonthCellComponent,
  MONTHS_IN_VIEW,
  MONTHS_IN_COLUMN,
  NbCalendarMonthPickerComponent,
  NbCalendarDayCellComponent,
  NbCalendarMonthModelService,
  NbCalendarDaysNamesComponent,
  NbCalendarWeekNumberComponent,
  NbCalendarDayPickerComponent,
  NbBaseCalendarComponent,
  NbCalendarComponent,
  NbButtonModule,
  NbNativeDateService,
  NbCalendarTimeModelService,
  NbCalendarActionsComponent,
  NbCalendarKitModule,
  NbBaseCalendarModule,
  NbCalendarModule,
  NbBaseCalendarRangeCell,
  NbCalendarRangeDayCellComponent,
  NbCalendarRangeYearCellComponent,
  NbCalendarRangeMonthCellComponent,
  NbCalendarRangeComponent,
  NbCalendarRangeModule,
  NB_TIME_PICKER_CONFIG,
  NB_DEFAULT_TIMEPICKER_LOCALIZATION_CONFIG,
  NbListComponent,
  NbListItemComponent,
  NbTimePickerCellComponent,
  NbTimePickerComponent,
  NbCalendarWithTimeComponent,
  NbDatepickerContainerComponent,
  NbDatepickerAdapter,
  NbDatepicker,
  NB_DATE_ADAPTER,
  NB_DATE_SERVICE_OPTIONS,
  NbDatepickerDirective,
  NbBasePicker,
  NbBasePickerComponent,
  NbDatepickerComponent,
  NbRangepickerComponent,
  NbDateTimePickerComponent,
  NbRestoreScrollTopHelper,
  NbLayoutComponent,
  NbLayoutColumnComponent,
  NbLayoutHeaderComponent,
  NbLayoutFooterComponent,
  NbLtrDirective,
  NbRtlDirective,
  NbLayoutModule,
  NbMenuItem,
  NbMenuService,
  NbBadgeComponent,
  NbToggleStates,
  NbMenuItemComponent,
  NbMenuComponent,
  NbBadgeModule,
  NbMenuModule,
  NbRouteTabsetComponent,
  NbRouteTabsetModule,
  NbSidebarService,
  NbSidebarHeaderComponent,
  NbSidebarFooterComponent,
  NbSidebarComponent,
  NbSidebarModule,
  NbTabContentDirective,
  NbTabTitleDirective,
  NbTabComponent,
  NbTabsetComponent,
  NbTabsetModule,
  NbUserComponent,
  NbUserModule,
  NbActionComponent,
  NbActionsComponent,
  NbActionsModule,
  NbSearchService,
  NbSearchFieldComponent,
  NbSearchComponent,
  NbSearchModule,
  NbCheckboxComponent,
  NbCheckboxModule,
  NbDynamicOverlay,
  NbDynamicOverlayChange,
  NbDynamicOverlayHandler,
  NbPopoverComponent,
  NbPopoverDirective,
  NbPopoverModule,
  NbContextMenuComponent,
  NbContextMenuDirective,
  NbContextMenuModule,
  NbProgressBarComponent,
  NbProgressBarModule,
  NbAlertComponent,
  NbAlertModule,
  NbFormFieldControl,
  NbFormFieldControlConfig,
  NbInputDirective,
  NbChatFormComponent,
  NbChatCustomMessageService,
  NbChatMessageTextComponent,
  NbChatMessageFileComponent,
  NbChatMessageQuoteComponent,
  NbChatOptions,
  NbChatMessageMapComponent,
  NbChatAvatarComponent,
  NbChatMessageComponent,
  NbChatTitleDirective,
  NbChatComponent,
  NbInputModule,
  NbChatCustomMessageDirective,
  NbChatModule,
  NbSpinnerComponent,
  NbSpinnerDirective,
  NbSpinnerModule,
  NB_STEPPER,
  NbStepComponent,
  NbStepperComponent,
  NbStepperNextDirective,
  NbStepperPreviousDirective,
  NbStepperModule,
  NbAccordionComponent,
  NbAccordionItemComponent,
  NbAccordionItemBodyComponent,
  NbAccordionItemHeaderComponent,
  NbAccordionModule,
  NB_BUTTON_GROUP,
  NbButtonToggleDirective,
  NbButtonGroupComponent,
  NbButtonGroupModule,
  NbListPageTrackerDirective,
  NbScrollableContainerDimensions,
  NbInfiniteListDirective,
  NbListModule,
  NbDirectionality,
  NbBidiModule,
  NbCellDefDirective,
  NbHeaderCellDefDirective,
  NbFooterCellDefDirective,
  NB_SORT_HEADER_COLUMN_DEF,
  NbColumnDefDirective,
  NbHeaderCellDirective,
  NbFooterCellDirective,
  NbCellDirective,
  NbDataSource,
  NbDataRowOutletDirective,
  NbHeaderRowOutletDirective,
  NbFooterRowOutletDirective,
  NbNoDataRowOutletDirective,
  NbCellOutletDirective,
  NbHeaderRowDefDirective,
  NbFooterRowDefDirective,
  NbRowDefDirective,
  NbHeaderRowComponent,
  NbFooterRowComponent,
  NbRowComponent,
  NB_TABLE_TEMPLATE,
  NB_VIEW_REPEATER_STRATEGY,
  NB_COALESCED_STYLE_SCHEDULER,
  NB_TABLE_PROVIDERS,
  NbTable,
  NbTableModule,
  NB_DIALOG_CONFIG,
  NbDialogConfig,
  NbDialogRef,
  NbDialogContainerComponent,
  NbDialogService,
  NbDialogModule,
  NbToastComponent,
  NbToastrContainerComponent,
  NB_TOASTR_CONFIG,
  NbToastrConfig,
  NbToastRef,
  NbToastContainer,
  NbToastrContainerRegistry,
  NbToastrService,
  NbToastrModule,
  NbToast,
  NbTooltipComponent,
  NbTooltipDirective,
  NbTooltipModule,
  NB_SELECT_INJECTION_TOKEN,
  NbOptionComponent,
  NbOptionListComponent,
  NbSelectLabelComponent,
  nbSelectFormFieldControlConfigFactory,
  NbSelectComponent,
  NbOptionGroupComponent,
  NbOptionModule,
  NbSelectModule,
  NbPrefixDirective,
  NbSuffixDirective,
  NbFormFieldComponent,
  NbSelectWithAutocompleteComponent,
  NbFormFieldModule,
  NbSelectWithAutocompleteModule,
  NbAutocompleteComponent,
  NbAutocompleteDirective,
  NbAutocompleteModule,
  NbWindowState,
  NB_WINDOW_DEFAULT_BUTTONS_CONFIG,
  NbWindowConfig,
  NB_WINDOW_CONTENT,
  NB_WINDOW_CONFIG,
  NB_WINDOW_CONTEXT,
  NbWindowRef,
  NbWindowsContainerComponent,
  NbWindowComponent,
  NbWindowService,
  NbWindowModule,
  NbTimePickerDirective,
  NbTimepickerModule,
  NbDateAdapterService,
  NbRangeAdapterService,
  NbDateTimeAdapterService,
  NbDatepickerModule,
  NbRadioComponent,
  NbRadioGroupComponent,
  NbRadioModule,
  NbTagComponent,
  NbTagInputDirective,
  NbTagListComponent,
  NbTagModule,
  NB_DEFAULT_ROW_LEVEL,
  NbTreeGridPresentationNode,
  NbTreeGridFilterService,
  NbSortDirection,
  NbSortDirective,
  NbSortHeaderIconDirective,
  NbSortIconComponent,
  NbSortHeaderComponent,
  NbTreeGridSortService,
  NbTreeGridService,
  NbTreeGridDataService,
  NbTreeGridDataSource,
  NbTreeGridDataSourceBuilder,
  NB_TREE_GRID,
  NbColumnsService,
  NbTreeGridComponent,
  NbTreeGridRowDefDirective,
  NbTreeGridHeaderRowDefDirective,
  NbTreeGridFooterRowDefDirective,
  NbTreeGridCellDefDirective,
  NbTreeGridHeaderCellDefDirective,
  NbTreeGridFooterCellDefDirective,
  NB_ROW_DOUBLE_CLICK_DELAY,
  NbTreeGridRowComponent,
  NbTreeGridHeaderRowComponent,
  NbTreeGridFooterRowComponent,
  NbTreeGridColumnDefDirective,
  NbTreeGridCellDirective,
  NbTreeGridHeaderCellDirective,
  NbTreeGridFooterCellDirective,
  NbFilterDirective,
  NbFilterInputDirective,
  NbTreeGridRowToggleDirective,
  NbTreeGridRowToggleComponent,
  NbTreeGridModule,
  NbToggleComponent,
  NbToggleModule
};
/*! Bundled license information:

@nebular/theme/fesm2022/nebular-theme.mjs:
  (**
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license information.
   *)

@nebular/theme/fesm2022/nebular-theme.mjs:
  (*
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license information.
   *)
  (**
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license information.
   *)
  (*
   * @license
   * Copyright Akveo. All Rights Reserved.
   * Licensed under the MIT License. See License.txt in the project root for license infornbion.
   *)
*/
//# sourceMappingURL=chunk-HEWCRMGN.js.map
